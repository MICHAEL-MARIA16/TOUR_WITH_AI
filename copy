analyse the files and satisfy my requirements carefully analyse the code and rectify
// backend/controllers/tripController.js
const Place = require('../models/Place');
const OptimizationAlgorithms = require('../utils/optimizationAlgorithms');
const DistanceCalculator = require('../utils/distanceCalculator');

class TripController {
  constructor() {
    this.optimizationAlgorithms = new OptimizationAlgorithms();
    this.distanceCalculator = new DistanceCalculator();
  }

  // Generate optimized trip with AI-powered recommendations
  generateTrip = async (req, res) => {
    try {
      const {
        preferences = {},
        constraints = {},
        algorithm = 'advanced-greedy',
        startLocation = null,
        enableAutoRerouting = true
      } = req.body;

      const {
        interests = [],
        duration = 480, // 8 hours default
        budget = Infinity,
        accessibility = {},
        groupType = 'family',
        season = 'any'
      } = preferences;

      // Get places based on interests
      let places = [];
      if (interests.length > 0) {
        places = await Place.find({
          category: { $in: interests },
          isActive: { $ne: false }
        }).sort({ rating: -1 });
      } else {
        places = await Place.find({
          isActive: { $ne: false }
        }).sort({ rating: -1 }).limit(20);
      }

      if (places.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'No places found matching your criteria'
        });
      }

      // Apply filters based on constraints
      places = this.applyConstraintFilters(places, constraints);

      // Select algorithm based on problem size and preferences
      const selectedAlgorithm = this.selectOptimalAlgorithm(places.length, algorithm);

      const optimizationConstraints = {
        startLocation,
        timeConstraints: { maxDuration: duration },
        budget,
        accessibility,
        strategy: this.getOptimizationStrategy(groupType),
        ...constraints
      };

      // Run optimization
      const optimizationResult = await this.runOptimization(
        places,
        selectedAlgorithm,
        optimizationConstraints
      );

      // Generate detailed itinerary
      const itinerary = await this.generateDetailedItinerary(
        optimizationResult.route,
        optimizationConstraints
      );

      // Calculate additional metrics
      const tripMetrics = await this.calculateTripMetrics(
        optimizationResult.route,
        itinerary
      );

      // Generate rerouting alternatives if enabled
      let reroutingOptions = null;
      if (enableAutoRerouting) {
        reroutingOptions = await this.generateReroutingOptions(
          optimizationResult.route,
          places,
          optimizationConstraints
        );
      }

      res.status(200).json({
        success: true,
        data: {
          tripId: this.generateTripId(),
          optimizedRoute: optimizationResult.route,
          itinerary,
          metrics: {
            ...optimizationResult,
            ...tripMetrics
          },
          algorithm: selectedAlgorithm,
          recommendations: await this.generateRecommendations(optimizationResult.route),
          alternatives: await this.generateAlternatives(places, optimizationResult.route),
          reroutingOptions: reroutingOptions
        }
      });

    } catch (error) {
      console.error('Trip generation error:', error);
      res.status(500).json({
        success: false,
        message: 'Error generating trip',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // NEW: Automatic rerouting endpoint for handling closures and preference changes
  handleAutoRerouting = async (req, res) => {
    try {
      const {
        tripId,
        currentRoute,
        closedPlaces = [],
        newPreferences = {},
        changedConstraints = {},
        reroutingType = 'auto', // 'closure', 'preference', 'constraint', 'auto'
        currentPosition = null
      } = req.body;

      if (!currentRoute || currentRoute.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Current route is required for rerouting'
        });
      }

      // Validate closed places and remove them from route
      const activeRoute = currentRoute.filter(place => 
        !closedPlaces.includes(place.id)
      );

      // If too many places are closed, find alternatives
      let replacementPlaces = [];
      if (closedPlaces.length > 0) {
        replacementPlaces = await this.findReplacementPlaces(
          closedPlaces,
          currentRoute,
          newPreferences,
          changedConstraints
        );
      }

      // Generate rerouting options based on type
      const reroutingResult = await this.executeRerouting({
        activeRoute,
        replacementPlaces,
        reroutingType,
        newPreferences,
        changedConstraints,
        currentPosition,
        originalRoute: currentRoute
      });

      // Calculate impact of rerouting
      const reroutingImpact = await this.calculateReroutingImpact(
        currentRoute,
        reroutingResult.newRoute
      );

      res.status(200).json({
        success: true,
        data: {
          tripId,
          reroutingType,
          originalRoute: currentRoute,
          newRoute: reroutingResult.newRoute,
          replacedPlaces: closedPlaces,
          addedPlaces: replacementPlaces,
          impact: reroutingImpact,
          alternatives: reroutingResult.alternatives,
          confidence: reroutingResult.confidence,
          recommendations: await this.generateReroutingRecommendations(reroutingResult)
        }
      });

    } catch (error) {
      console.error('Auto rerouting error:', error);
      res.status(500).json({
        success: false,
        message: 'Error during automatic rerouting',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // NEW: Check route validity and suggest preemptive rerouting
  validateRouteStatus = async (req, res) => {
    try {
      const { tripId, route } = req.body;

      const validationResults = await Promise.all(
        route.map(async (place) => {
          const placeStatus = await this.checkPlaceStatus(place.id);
          return {
            placeId: place.id,
            name: place.name,
            ...placeStatus
          };
        })
      );

      const closedPlaces = validationResults.filter(result => 
        !result.isOpen || result.hasIssues
      );

      const needsRerouting = closedPlaces.length > 0;

      let reroutingSuggestions = null;
      if (needsRerouting) {
        reroutingSuggestions = await this.generatePreemptiveRerouting(
          route,
          closedPlaces
        );
      }

      res.status(200).json({
        success: true,
        data: {
          tripId,
          isValid: !needsRerouting,
          validationResults,
          closedPlaces: closedPlaces.map(p => ({ id: p.placeId, name: p.name, reason: p.reason })),
          needsRerouting,
          reroutingSuggestions
        }
      });

    } catch (error) {
      console.error('Route validation error:', error);
      res.status(500).json({
        success: false,
        message: 'Error validating route status',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // NEW: Dynamic preference adjustment during trip
  adjustTripPreferences = async (req, res) => {
    try {
      const {
        tripId,
        currentRoute,
        currentPosition,
        newPreferences,
        keepVisitedPlaces = true,
        maxRouteChanges = 3
      } = req.body;

      // Determine which places have been visited
      const visitedPlaces = keepVisitedPlaces 
        ? await this.determineVisitedPlaces(currentRoute, currentPosition)
        : [];

      const remainingRoute = currentRoute.filter(place => 
        !visitedPlaces.includes(place.id)
      );

      // Find new places based on updated preferences
      const newCandidates = await this.findPlacesForNewPreferences(
        newPreferences,
        remainingRoute,
        currentPosition
      );

      // Optimize the adjusted route
      const adjustedRoute = await this.optimizeAdjustedRoute({
        visitedPlaces: currentRoute.filter(p => visitedPlaces.includes(p.id)),
        remainingRoute,
        newCandidates,
        maxRouteChanges,
        currentPosition,
        preferences: newPreferences
      });

      const adjustmentImpact = await this.calculateAdjustmentImpact(
        currentRoute,
        adjustedRoute.fullRoute
      );

      res.status(200).json({
        success: true,
        data: {
          tripId,
          originalRoute: currentRoute,
          adjustedRoute: adjustedRoute.fullRoute,
          visitedPlaces,
          changedPlaces: adjustedRoute.changes,
          newPlaces: adjustedRoute.additions,
          removedPlaces: adjustedRoute.removals,
          impact: adjustmentImpact,
          confidence: adjustedRoute.confidence
        }
      });

    } catch (error) {
      console.error('Preference adjustment error:', error);
      res.status(500).json({
        success: false,
        message: 'Error adjusting trip preferences',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // Optimize existing trip
  optimizeTrip = async (req, res) => {
    try {
      const {
        places,
        constraints = {},
        algorithm = 'genetic',
        currentRoute = []
      } = req.body;

      if (!places || places.length < 2) {
        return res.status(400).json({
          success: false,
          message: 'At least 2 places are required for optimization'
        });
      }

      // Validate places exist in database
      const validPlaces = await Place.find({
        id: { $in: places.map(p => p.id || p) }
      });

      if (validPlaces.length !== places.length) {
        return res.status(400).json({
          success: false,
          message: 'Some places were not found in the database'
        });
      }

      const selectedAlgorithm = this.selectOptimalAlgorithm(validPlaces.length, algorithm);

      const optimizationResult = await this.runOptimization(
        validPlaces,
        selectedAlgorithm,
        constraints
      );

      // Calculate improvement metrics
      const improvement = currentRoute.length > 0 ? 
        await this.calculateImprovement(currentRoute, optimizationResult.route) : null;

      res.status(200).json({
        success: true,
        data: {
          optimizedRoute: optimizationResult.route,
          metrics: optimizationResult,
          algorithm: selectedAlgorithm,
          improvement,
          executionTime: Date.now() - req.startTime
        }
      });

    } catch (error) {
      console.error('Trip optimization error:', error);
      res.status(500).json({
        success: false,
        message: 'Error optimizing trip',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // Get AI-powered trip suggestions
  getTripSuggestions = async (req, res) => {
    try {
      const {
        currentLocation,
        interests = [],
        duration = 480,
        budget = 'moderate',
        groupSize = 2,
        accessibility = {}
      } = req.query;

      // Get suggested places based on criteria
      const suggestions = await this.generateTripSuggestions({
        currentLocation: currentLocation ? JSON.parse(currentLocation) : null,
        interests: Array.isArray(interests) ? interests : [interests],
        duration: parseInt(duration),
        budget,
        groupSize: parseInt(groupSize),
        accessibility: typeof accessibility === 'string' ? JSON.parse(accessibility) : accessibility
      });

      res.status(200).json({
        success: true,
        data: suggestions
      });

    } catch (error) {
      console.error('Trip suggestions error:', error);
      res.status(500).json({
        success: false,
        message: 'Error generating trip suggestions',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // Calculate travel matrix between places
  calculateTravelMatrix = async (req, res) => {
    try {
      const { placeIds } = req.body;

      if (!placeIds || placeIds.length < 2) {
        return res.status(400).json({
          success: false,
          message: 'At least 2 places are required for travel matrix'
        });
      }

      const places = await Place.find({
        id: { $in: placeIds }
      });

      if (places.length !== placeIds.length) {
        return res.status(400).json({
          success: false,
          message: 'Some places were not found'
        });
      }

      const locations = places.map(place => place.location);
      const travelMatrix = await this.distanceCalculator.calculateDistanceMatrix(
        locations,
        locations
      );

      // Enhance matrix with place information
      const enhancedMatrix = places.map((fromPlace, i) => ({
        from: {
          id: fromPlace.id,
          name: fromPlace.name,
          location: fromPlace.location
        },
        destinations: places.map((toPlace, j) => ({
          to: {
            id: toPlace.id,
            name: toPlace.name,
            location: toPlace.location
          },
          distance: travelMatrix.distances[i][j],
          duration: travelMatrix.durations[i][j],
          travelMode: 'driving'
        }))
      }));

      res.status(200).json({
        success: true,
        data: {
          matrix: enhancedMatrix,
          summary: {
            totalPlaces: places.length,
            avgDistance: this.calculateAverageDistance(travelMatrix.distances),
            maxDistance: this.getMaxDistance(travelMatrix.distances),
            minDistance: this.getMinDistance(travelMatrix.distances)
          }
        }
      });

    } catch (error) {
      console.error('Travel matrix calculation error:', error);
      res.status(500).json({
        success: false,
        message: 'Error calculating travel matrix',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  };

  // NEW: Advanced Rerouting Methods

  async generateReroutingOptions(route, allPlaces, constraints) {
    const alternatives = [];

    // Generate different rerouting scenarios
    for (let i = 0; i < route.length; i++) {
      const placeToReplace = route[i];
      const similarPlaces = await this.findSimilarPlaces([placeToReplace], allPlaces, 3);

      if (similarPlaces.length > 0) {
        for (const replacement of similarPlaces) {
          const newRoute = [...route];
          newRoute[i] = replacement;

          const routeMetrics = await this.calculateRouteMetrics(newRoute);
          alternatives.push({
            type: 'single-replacement',
            originalPlace: { id: placeToReplace.id, name: placeToReplace.name },
            replacementPlace: { id: replacement.id, name: replacement.name },
            position: i,
            route: newRoute,
            metrics: routeMetrics,
            impact: await this.calculateReplacementImpact(placeToReplace, replacement)
          });
        }
      }
    }

    // Sort by impact and return top alternatives
    return alternatives
      .sort((a, b) => b.impact.score - a.impact.score)
      .slice(0, 5);
  }

  async findReplacementPlaces(closedPlaceIds, originalRoute, newPreferences, constraints) {
    const replacements = [];

    for (const closedId of closedPlaceIds) {
      const originalPlace = originalRoute.find(p => p.id === closedId);
      if (!originalPlace) continue;

      // Find similar places based on category, rating, and location
      const candidates = await Place.find({
        id: { $ne: closedId },
        category: originalPlace.category,
        rating: { $gte: originalPlace.rating - 0.5 },
        isActive: { $ne: false },
        $or: [
          { state: originalPlace.state },
          {
            'location.latitude': {
              $gte: originalPlace.location.latitude - 1.0,
              $lte: originalPlace.location.latitude + 1.0
            },
            'location.longitude': {
              $gte: originalPlace.location.longitude - 1.0,
              $lte: originalPlace.location.longitude + 1.0
            }
          }
        ]
      }).sort({ rating: -1 }).limit(5);

      // Apply preference filters if provided
      const filteredCandidates = newPreferences.interests 
        ? candidates.filter(place => newPreferences.interests.includes(place.category))
        : candidates;

      if (filteredCandidates.length > 0) {
        replacements.push({
          originalPlace: originalPlace,
          replacementOptions: filteredCandidates,
          bestReplacement: filteredCandidates[0],
          replacementScore: await this.calculateReplacementScore(originalPlace, filteredCandidates[0])
        });
      }
    }

    return replacements;
  }

  async executeRerouting({ activeRoute, replacementPlaces, reroutingType, newPreferences, changedConstraints, currentPosition, originalRoute }) {
    let newRoute = [...activeRoute];
    const alternatives = [];
    let confidence = 0.8;

    switch (reroutingType) {
      case 'closure':
        // Handle place closures
        for (const replacement of replacementPlaces) {
          const originalIndex = originalRoute.findIndex(p => p.id === replacement.originalPlace.id);
          if (originalIndex !== -1 && originalIndex < newRoute.length) {
            newRoute.splice(originalIndex, 0, replacement.bestReplacement);
          } else {
            newRoute.push(replacement.bestReplacement);
          }
        }
        confidence = replacementPlaces.length > 0 ? 0.7 : 0.9;
        break;

      case 'preference':
        // Handle preference changes
        const newPlaces = await this.findPlacesForNewPreferences(newPreferences, newRoute, currentPosition);
        newRoute = await this.integrateNewPreferences(newRoute, newPlaces, newPreferences);
        confidence = 0.75;
        break;

      case 'constraint':
        // Handle constraint changes
        newRoute = this.applyConstraintFilters(newRoute, changedConstraints);
        if (newRoute.length < originalRoute.length) {
          const additionalPlaces = await this.findAdditionalPlaces(newRoute, changedConstraints);
          newRoute = [...newRoute, ...additionalPlaces];
        }
        confidence = 0.8;
        break;

      case 'auto':
      default:
        // Intelligent automatic rerouting
        if (replacementPlaces.length > 0) {
          newRoute = await this.executeRerouting({
            activeRoute, replacementPlaces, reroutingType: 'closure', 
            newPreferences, changedConstraints, currentPosition, originalRoute
          }).then(result => result.newRoute);
        }

        if (Object.keys(newPreferences).length > 0) {
          newRoute = await this.executeRerouting({
            activeRoute: newRoute, replacementPlaces: [], reroutingType: 'preference',
            newPreferences, changedConstraints, currentPosition, originalRoute
          }).then(result => result.newRoute);
        }

        confidence = 0.85;
        break;
    }

    // Optimize the new route
    const optimizedRoute = await this.optimizationAlgorithms.advancedGreedyOptimization(
      newRoute, 
      { startLocation: currentPosition, ...changedConstraints }
    );

    // Generate alternative routes
    for (let i = 0; i < 3; i++) {
      const alternative = await this.generateAlternativeRoute(newRoute, originalRoute, i);
      if (alternative) alternatives.push(alternative);
    }

    return {
      newRoute: optimizedRoute.route,
      alternatives,
      confidence,
      optimizationMetrics: optimizedRoute
    };
  }

  async checkPlaceStatus(placeId) {
    try {
      const place = await Place.findOne({ id: placeId });
      if (!place) {
        return { isOpen: false, reason: 'Place not found', hasIssues: true };
      }

      // Simulate real-time status check (in production, this would call external APIs)
      const currentHour = new Date().getHours();
      const isBusinessHours = currentHour >= 9 && currentHour <= 18;

      return {
        isOpen: place.isActive !== false && isBusinessHours,
        reason: !place.isActive ? 'Permanently closed' : !isBusinessHours ? 'Currently closed' : null,
        hasIssues: place.isActive === false,
        lastUpdated: new Date(),
        openingHours: place.openingHours || '9:00 AM - 6:00 PM'
      };
    } catch (error) {
      return { isOpen: false, reason: 'Status check failed', hasIssues: true };
    }
  }

  async generatePreemptiveRerouting(route, closedPlaces) {
    const suggestions = [];

    for (const closedPlace of closedPlaces) {
      const alternatives = await this.findSimilarPlaces(
        [{ id: closedPlace.placeId }], 
        await Place.find({ isActive: { $ne: false } }), 
        3
      );

      suggestions.push({
        closedPlace: closedPlace,
        alternatives: alternatives,
        urgency: this.calculateReroutingUrgency(closedPlace),
        autoApply: closedPlace.reason === 'Permanently closed'
      });
    }

    return suggestions.sort((a, b) => b.urgency - a.urgency);
  }

  async determineVisitedPlaces(route, currentPosition) {
    if (!currentPosition) return [];

    const visitedPlaces = [];

    for (const place of route) {
      const distance = await this.distanceCalculator.calculateDistance(
        currentPosition,
        place.location
      );

      // If very close to a place or passed it, consider it visited
      if (distance < 1) { // Less than 1km
        visitedPlaces.push(place.id);
      }
    }

    return visitedPlaces;
  }

  async findPlacesForNewPreferences(newPreferences, currentRoute, currentPosition) {
    const currentCategories = [...new Set(currentRoute.map(p => p.category))];
    const newInterests = newPreferences.interests || [];

    // Find places that match new interests but aren't in current categories
    const newCategories = newInterests.filter(interest => !currentCategories.includes(interest));

    if (newCategories.length === 0) return [];

    let query = {
      category: { $in: newCategories },
      isActive: { $ne: false }
    };

    // Add location proximity if current position is available
    if (currentPosition) {
      query = {
        ...query,
        'location.latitude': {
          $gte: currentPosition.latitude - 2.0,
          $lte: currentPosition.latitude + 2.0
        },
        'location.longitude': {
          $gte: currentPosition.longitude - 2.0,
          $lte: currentPosition.longitude + 2.0
        }
      };
    }

    const newPlaces = await Place.find(query)
      .sort({ rating: -1 })
      .limit(10);

    return newPlaces;
  }

  async optimizeAdjustedRoute({ visitedPlaces, remainingRoute, newCandidates, maxRouteChanges, currentPosition, preferences }) {
    const allCandidates = [...remainingRoute, ...newCandidates];

    // Score each place based on new preferences
    const scoredCandidates = await Promise.all(
      allCandidates.map(async (place) => ({
        ...place,
        score: await this.calculatePlaceScore(place, preferences, currentPosition)
      }))
    );

    // Select best places within the change limit
    const sortedCandidates = scoredCandidates.sort((a, b) => b.score - a.score);
    const selectedPlaces = sortedCandidates.slice(0, remainingRoute.length + Math.min(maxRouteChanges, newCandidates.length));

    // Optimize the route
    const optimizedResult = await this.optimizationAlgorithms.advancedGreedyOptimization(
      selectedPlaces,
      { startLocation: currentPosition, ...preferences }
    );

    const fullRoute = [...visitedPlaces, ...optimizedResult.route];

    return {
      fullRoute,
      changes: this.identifyRouteChanges(remainingRoute, optimizedResult.route),
      additions: selectedPlaces.filter(p => !remainingRoute.some(r => r.id === p.id)),
      removals: remainingRoute.filter(p => !selectedPlaces.some(s => s.id === p.id)),
      confidence: 0.8
    };
  }

  // Helper Methods (continued from original)
  applyConstraintFilters(places, constraints) {
    return places.filter(place => {
      // Accessibility filters
      if (constraints.accessibility?.wheelchairAccess && !place.wheelchairAccessible) {
        return false;
      }

      if (constraints.accessibility?.kidFriendly && !place.kidFriendly) {
        return false;
      }

      // Budget filters
      if (constraints.budget && typeof constraints.budget === 'number') {
        const entryCost = place.entryFee?.indian || 0;
        if (entryCost > constraints.budget * 0.3) { // Max 30% of budget per place
          return false;
        }
      }

      // Time filters
      if (constraints.timeConstraints?.minDuration && 
          place.averageVisitDuration < constraints.timeConstraints.minDuration) {
        return false;
      }

      return true;
    });
  }

  selectOptimalAlgorithm(placeCount, preferredAlgorithm) {
    // Algorithm selection logic based on problem complexity
    if (placeCount <= 3) return 'advanced-greedy';
    if (placeCount <= 8 && preferredAlgorithm === 'optimal') return 'dynamicProgramming';
    if (placeCount <= 12) return 'genetic';
    if (placeCount <= 20) return 'simulatedAnnealing';
    return 'antColony';
  }

  getOptimizationStrategy(groupType) {
    const strategies = {
      family: 'comfort',
      solo: 'efficiency',
      couple: 'scenic',
      group: 'balanced',
      business: 'fast'
    };
    return strategies[groupType] || 'balanced';
  }

  async runOptimization(places, algorithm, constraints) {
    const algorithms = {
      'advanced-greedy': this.optimizationAlgorithms.advancedGreedyOptimization,
      'genetic': this.optimizationAlgorithms.geneticAlgorithmOptimization,
      'dynamicProgramming': this.optimizationAlgorithms.dynamicProgrammingTSP,
      'simulatedAnnealing': this.optimizationAlgorithms.simulatedAnnealingOptimization,
      'antColony': this.optimizationAlgorithms.antColonyOptimization,
      'multiObjective': this.optimizationAlgorithms.multiObjectiveOptimization
    };

    const optimizationFunction = algorithms[algorithm] || algorithms['advanced-greedy'];
    return await optimizationFunction.call(this.optimizationAlgorithms, places, constraints);
  }

  // NEW: Additional helper methods for rerouting

  async calculateReroutingImpact(originalRoute, newRoute) {
    const originalMetrics = await this.calculateRouteMetrics(originalRoute);
    const newMetrics = await this.calculateRouteMetrics(newRoute);

    return {
      routeChanges: {
        placesRemoved: originalRoute.filter(p => !newRoute.some(n => n.id === p.id)).length,
        placesAdded: newRoute.filter(p => !originalRoute.some(o => o.id === p.id)).length,
        placesReordered: this.countReorderedPlaces(originalRoute, newRoute)
      },
      metrics: {
        distanceChange: newMetrics.totalDistance - originalMetrics.totalDistance,
        timeChange: newMetrics.totalTime - originalMetrics.totalTime,
        costChange: this.calculateCostChange(originalRoute, newRoute),
        ratingChange: this.calculateRatingChange(originalRoute, newRoute)
      },
      severity: this.calculateReroutingSeverity(originalRoute, newRoute)
    };
  }

  async calculateAdjustmentImpact(originalRoute, adjustedRoute) {
    return this.calculateReroutingImpact(originalRoute, adjustedRoute);
  }

  async calculateReplacementImpact(originalPlace, replacementPlace) {
    const distanceFromOriginal = await this.distanceCalculator.calculateDistance(
      originalPlace.location,
      replacementPlace.location
    );

    return {
      score: this.calculateReplacementScore(originalPlace, replacementPlace),
      ratingDifference: (replacementPlace.rating || 0) - (originalPlace.rating || 0),
      categoryMatch: originalPlace.category === replacementPlace.category,
      locationDistance: distanceFromOriginal,
      costDifference: (replacementPlace.entryFee?.indian || 0) - (originalPlace.entryFee?.indian || 0),
      timeDifference: (replacementPlace.averageVisitDuration || 0) - (originalPlace.averageVisitDuration || 0)
    };
  }

  calculateReplacementScore(originalPlace, replacementPlace) {
    let score = 0;

    // Category match bonus
    if (originalPlace.category === replacementPlace.category) score += 40;

    // Rating comparison
    const ratingDiff = (replacementPlace.rating || 0) - (originalPlace.rating || 0);
    score += Math.max(-20, Math.min(20, ratingDiff * 10));

    // Location proximity (closer is better)
    // This would need actual distance calculation in production
    score += 20; // Placeholder

    // Cost comparison (similar cost is better)
    const costDiff = Math.abs((replacementPlace.entryFee?.indian || 0) - (originalPlace.entryFee?.indian || 0));
    score += Math.max(0, 20 - costDiff / 10);

    // Time compatibility
    const timeDiff = Math.abs((replacementPlace.averageVisitDuration || 0) - (originalPlace.averageVisitDuration || 0));
    score += Math.max(0, 20 - timeDiff / 10);

    return Math.max(0, Math.min(100, score));
  }

  calculateReroutingUrgency(closedPlace) {
    let urgency = 50; // Base urgency

    if (closedPlace.reason === 'Permanently closed') urgency += 40;
    if (closedPlace.reason === 'Currently closed') urgency += 20;
    if (closedPlace.hasIssues) urgency += 30;

    return Math.min(100, urgency);
  }

  async calculatePlaceScore(place, preferences, currentPosition) {
    let score = place.rating || 0;

    // Interest match bonus
    if (preferences.interests?.includes(place.category)) {
      score += 2;
    }

    // Accessibility bonus
    if (preferences.accessibility?.wheelchairAccess && place.wheelchairAccessible) {
      score += 1;
    }
    if (preferences.accessibility?.kidFriendly && place.kidFriendly) {
      score += 1;
    }

    // Budget consideration
    if (preferences.budget && typeof preferences.budget === 'number') {
      const cost = place.entryFee?.indian || 0;
      if (cost <= preferences.budget * 0.2) score += 0.5;
    }

    // Proximity bonus if current position is available
    if (currentPosition) {
      const distance = await this.distanceCalculator.calculateDistance(
        currentPosition,
        place.location
      );
      score += Math.max(0, 2 - distance / 50); // Bonus for closer places
    }

    return score;
  }

  identifyRouteChanges(originalRoute, newRoute) {
    const changes = [];

    // Find additions
    newRoute.forEach((place, index) => {
      if (!originalRoute.some(p => p.id === place.id)) {
        changes.push({
          type: 'addition',
          place: place,
          position: index
        });
      }
    });

    // Find removals
    originalRoute.forEach((place, index) => {
      if (!newRoute.some(p => p.id === place.id)) {
        changes.push({
          type: 'removal',
          place: place,
          originalPosition: index
        });
      }
    });

    // Find reorders
    const commonPlaces = originalRoute.filter(p => newRoute.some(n => n.id === p.id));
    commonPlaces.forEach(place => {
      const originalIndex = originalRoute.findIndex(p => p.id === place.id);
      const newIndex = newRoute.findIndex(p => p.id === place.id);

      if (originalIndex !== newIndex) {
        changes.push({
          type: 'reorder',
          place: place,
          from: originalIndex,
          to: newIndex
        });
      }
    });

    return changes;
  }

  countReorderedPlaces(originalRoute, newRoute) {
    let reorderedCount = 0;

    originalRoute.forEach((place, index) => {
      const newIndex = newRoute.findIndex(p => p.id === place.id);
      if (newIndex !== -1 && newIndex !== index) {
        reorderedCount++;
      }
    });

    return reorderedCount;
  }

  calculateCostChange(originalRoute, newRoute) {
    const originalCost = originalRoute.reduce((sum, place) => sum + (place.entryFee?.indian || 0), 0);
    const newCost = newRoute.reduce((sum, place) => sum + (place.entryFee?.indian || 0), 0);
    return newCost - originalCost;
  }

  calculateRatingChange(originalRoute, newRoute) {
    const originalRating = originalRoute.reduce((sum, place) => sum + (place.rating || 0), 0) / originalRoute.length;
    const newRating = newRoute.reduce((sum, place) => sum + (place.rating || 0), 0) / newRoute.length;
    return newRating - originalRating;
  }

  calculateReroutingSeverity(originalRoute, newRoute) {
    const placesChanged = originalRoute.filter(p => !newRoute.some(n => n.id === p.id)).length;
    const changePercentage = (placesChanged / originalRoute.length) * 100;

    if (changePercentage <= 20) return 'low';
    if (changePercentage <= 50) return 'medium';
    return 'high';
  }

  async generateAlternativeRoute(baseRoute, originalRoute, variation) {
    // Create variations by swapping/replacing places
    const alternative = [...baseRoute];

    if (variation === 0 && alternative.length > 2) {
      // Swap two random places
      const idx1 = Math.floor(Math.random() * alternative.length);
      const idx2 = Math.floor(Math.random() * alternative.length);
      [alternative[idx1], alternative[idx2]] = [alternative[idx2], alternative[idx1]];
    } else if (variation === 1 && alternative.length > 0) {
      // Replace one place with a similar alternative
      const replaceIndex = Math.floor(Math.random() * alternative.length);
      const placeToReplace = alternative[replaceIndex];
      const alternatives = await this.findSimilarPlaces([placeToReplace], [], 1);
      if (alternatives.length > 0) {
        alternative[replaceIndex] = alternatives[0];
      }
    } else if (variation === 2) {
      // Reverse a portion of the route
      if (alternative.length > 2) {
        const start = Math.floor(Math.random() * (alternative.length - 1));
        const end = start + Math.floor(Math.random() * (alternative.length - start - 1)) + 1;
        const reversed = alternative.slice(start, end + 1).reverse();
        alternative.splice(start, end - start + 1, ...reversed);
      }
    }

    const metrics = await this.calculateRouteMetrics(alternative);

    return {
      route: alternative,
      variation: variation,
      metrics: metrics,
      description: this.getAlternativeDescription(variation)
    };
  }

  getAlternativeDescription(variation) {
    const descriptions = [
      'Optimized for reduced travel time',
      'Alternative places with similar experiences',
      'Reordered for better flow'
    ];
    return descriptions[variation] || 'Alternative route option';
  }

  async generateReroutingRecommendations(reroutingResult) {
    const recommendations = [];

    // Analyze the rerouting result and provide specific recommendations
    if (reroutingResult.confidence < 0.7) {
      recommendations.push({
        type: 'warning',
        message: 'Route changes have moderate confidence. Consider reviewing alternatives.',
        action: 'review_alternatives'
      });
    }

    if (reroutingResult.newRoute.length < 3) {
      recommendations.push({
        type: 'suggestion',
        message: 'Route has few places. Consider adding more destinations.',
        action: 'add_places'
      });
    }

    const totalDistance = await this.calculateTotalDistance(reroutingResult.newRoute);
    if (totalDistance > 300) { // 300km
      recommendations.push({
        type: 'tip',
        message: 'Route covers long distances. Plan for sufficient travel time.',
        action: 'adjust_timing'
      });
    }

    recommendations.push({
      type: 'info',
      message: 'New route has been optimized. Check timings and make reservations if needed.',
      action: 'confirm_bookings'
    });

    return recommendations;
  }

  async integrateNewPreferences(currentRoute, newPlaces, preferences) {
    // Combine current route with new places based on preferences
    const combinedPlaces = [...currentRoute, ...newPlaces];

    // Score and select best places
    const scoredPlaces = await Promise.all(
      combinedPlaces.map(async place => ({
        ...place,
        score: await this.calculatePlaceScore(place, preferences)
      }))
    );

    // Select top places (maintain reasonable route length)
    const maxPlaces = Math.min(10, Math.max(currentRoute.length, currentRoute.length + 2));
    const selectedPlaces = scoredPlaces
      .sort((a, b) => b.score - a.score)
      .slice(0, maxPlaces);

    return selectedPlaces;
  }

  async findAdditionalPlaces(currentRoute, constraints) {
    const currentCategories = [...new Set(currentRoute.map(p => p.category))];
    const currentStates = [...new Set(currentRoute.map(p => p.state))];

    // Find places in same regions with different categories
    const additionalPlaces = await Place.find({
      $and: [
        { id: { $nin: currentRoute.map(p => p.id) } },
        {
          $or: [
            { state: { $in: currentStates } },
            { category: { $nin: currentCategories } }
          ]
        },
        { isActive: { $ne: false } }
      ]
    }).sort({ rating: -1 }).limit(5);

    return this.applyConstraintFilters(additionalPlaces, constraints);
  }

  async calculateTotalDistance(route) {
    if (route.length < 2) return 0;

    let totalDistance = 0;
    for (let i = 0; i < route.length - 1; i++) {
      const distance = await this.distanceCalculator.calculateDistance(
        route[i].location,
        route[i + 1].location
      );
      totalDistance += distance;
    }

    return totalDistance;
  }

  // Continue with existing methods...
  async generateDetailedItinerary(route, constraints) {
    const startTime = constraints.startTime || '09:00';
    const itinerary = [];
    let currentTime = this.parseTime(startTime);
    let currentLocation = constraints.startLocation;

    for (let i = 0; i < route.length; i++) {
      const place = route[i];
      const isFirst = i === 0;
      const isLast = i === route.length - 1;

      let travelTime = 0;
      let travelDistance = 0;

      // Calculate travel time to this place
      if (currentLocation) {
        const travelInfo = await this.distanceCalculator.calculateDrivingDistance(
          currentLocation,
          place.location
        );
        travelTime = travelInfo.duration;
        travelDistance = travelInfo.distance;
      }

      // Add travel time to current time
      currentTime += travelTime;

      const itineraryItem = {
        order: i + 1,
        place: {
          id: place.id,
          name: place.name,
          category: place.category,
          location: place.location,
          description: place.description,
          entryFee: place.entryFee,
          amenities: place.amenities,
          tags: place.tags
        },
        timing: {
          arrivalTime: this.formatTime(currentTime),
          departureTime: this.formatTime(currentTime + place.averageVisitDuration),
          visitDuration: place.averageVisitDuration,
          bestTimeToVisit: place.bestTimeToVisit
        },
        travel: isFirst ? null : {
          from: currentLocation,
          distance: travelDistance,
          duration: travelTime,
          mode: 'driving'
        },
        recommendations: {
          tips: await this.getPlaceTips(place),
          nearby: await this.getNearbyAttractions(place),
          dining: await this.getNearbyDining(place)
        }
      };

      itinerary.push(itineraryItem);

      // Update current time and location
      currentTime += place.averageVisitDuration;
      currentLocation = place.location;
    }

    return itinerary;
  }

  async calculateTripMetrics(route, itinerary) {
    const totalPlaces = route.length;
    const totalVisitTime = route.reduce((sum, place) => sum + place.averageVisitDuration, 0);
    const totalTravelTime = itinerary.reduce((sum, item) => sum + (item.travel?.duration || 0), 0);
    const totalDistance = itinerary.reduce((sum, item) => sum + (item.travel?.distance || 0), 0);
    const totalCost = route.reduce((sum, place) => sum + (place.entryFee?.indian || 0), 0);
    const averageRating = route.reduce((sum, place) => sum + (place.rating || 0), 0) / totalPlaces;

    const categories = [...new Set(route.map(place => place.category))];
    const states = [...new Set(route.map(place => place.state))];

    return {
      summary: {
        totalPlaces,
        totalTime: totalVisitTime + totalTravelTime,
        totalVisitTime,
        totalTravelTime,
        totalDistance,
        totalCost,
        averageRating,
        categories: categories.length,
        states: states.length
      },
      breakdown: {
        byCategory: this.groupByCategory(route),
        byState: this.groupByState(route),
        timeDistribution: {
          visiting: totalVisitTime,
          traveling: totalTravelTime,
          efficiency: totalVisitTime / (totalVisitTime + totalTravelTime)
        }
      }
    };
  }

  async generateRecommendations(route) {
    return {
      packingList: this.generatePackingList(route),
      weatherTips: await this.getWeatherTips(route),
      culturalTips: this.getCulturalTips(route),
      budgetTips: this.getBudgetTips(route),
      safetyTips: this.getSafetyTips(route)
    };
  }

  async generateAlternatives(allPlaces, selectedRoute) {
    const selectedIds = selectedRoute.map(p => p.id);
    const alternativePlaces = allPlaces.filter(p => !selectedIds.includes(p.id));

    return {
      similarPlaces: this.findSimilarPlaces(selectedRoute, alternativePlaces),
      nearbyAlternatives: await this.findNearbyAlternatives(selectedRoute, alternativePlaces),
      categoryAlternatives: this.findCategoryAlternatives(selectedRoute, alternativePlaces)
    };
  }

  generateTripId() {
    return trip${Date.now()}${Math.random().toString(36).substr(2, 9)};
  }

  // Utility methods for time handling
  parseTime(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
  }

  formatTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return ${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')};
  }

  // Additional helper methods
  groupByCategory(places) {
    return places.reduce((acc, place) => {
      acc[place.category] = (acc[place.category] || 0) + 1;
      return acc;
    }, {});
  }

  groupByState(places) {
    return places.reduce((acc, place) => {
      acc[place.state] = (acc[place.state] || 0) + 1;
      return acc;
    }, {});
  }

  generatePackingList(route) {
    const items = new Set(['Camera', 'Water bottle', 'Sunscreen', 'Comfortable shoes']);

    route.forEach(place => {
      if (place.category === 'hill-station') {
        items.add('Warm clothing');
        items.add('Light jacket');
      }
      if (place.category === 'beach') {
        items.add('Swimwear');
        items.add('Beach towel');
      }
      if (place.category === 'temple') {
        items.add('Modest clothing');
        items.add('Socks for temple visits');
      }
    });

    return Array.from(items);
  }

  getCulturalTips(route) {
    const tips = [];
    const hasTemples = route.some(p => p.category === 'temple');
    const hasHeritage = route.some(p => p.category === 'heritage');

    if (hasTemples) {
      tips.push('Dress modestly when visiting temples');
      tips.push('Remove shoes before entering temple premises');
    }
    if (hasHeritage) {
      tips.push('Respect historical sites and follow photography rules');
    }

    tips.push('Learn basic local greetings');
    tips.push('Try local cuisine at each destination');

    return tips;
  }

  getBudgetTips(route) {
    const totalCost = route.reduce((sum, place) => sum + (place.entryFee?.indian || 0), 0);

    return [
      Total entry fees: ₹${totalCost},
      'Book accommodations in advance for better rates',
      'Use local transport for cost-effective travel',
      'Try street food for authentic and affordable meals',
      'Negotiate prices at local markets'
    ];
  }

  getSafetyTips(route) {
    return [
      'Keep emergency contacts handy',
      'Inform someone about your itinerary',
      'Carry a first aid kit',
      'Stay hydrated, especially in coastal areas',
      'Be cautious while trekking in hill stations',
      'Respect local customs and traditions'
    ];
  }

  async getPlaceTips(place) {
    const tips = [Visit during ${place.bestTimeToVisit.join(' or ')} for the best experience];

    if (place.averageVisitDuration > 180) {
      tips.push('Allow plenty of time to fully explore this place');
    }

    if (place.entryFee.indian === 0) {
      tips.push('Free entry - great for budget travelers!');
    }

    return tips;
  }

  async getWeatherTips(route) {
    // Mock weather tips based on locations and seasons
    const tips = ['Check weather forecast before departure'];

    const hasCoastal = route.some(p => p.category === 'beach');
    const hasHills = route.some(p => p.category === 'hill-station');

    if (hasCoastal) {
      tips.push('Coastal areas can be humid - pack light, breathable clothing');
    }
    if (hasHills) {
      tips.push('Hill stations can be cooler - carry warm clothing for evenings');
    }

    return tips;
  }

  async getNearbyAttractions(place) {
    // Find other places within 20km radius
    const nearby = await Place.find({
      id: { $ne: place.id },
      $or: [
        { city: place.city },
        {
          'location.latitude': {
            $gte: place.location.latitude - 0.18, // ~20km
            $lte: place.location.latitude + 0.18
          },
          'location.longitude': {
            $gte: place.location.longitude - 0.18,
            $lte: place.location.longitude + 0.18
          }
        }
      ]
    }).limit(3);

    return nearby.map(p => ({ id: p.id, name: p.name, category: p.category }));
  }

  async getNearbyDining(place) {
    // Mock nearby dining recommendations based on location
    const diningOptions = {
      'Chennai': ['Murugan Idli Shop', 'Saravana Bhavan', 'Hotel Pandian'],
      'Madurai': ['Arya Bhavan', 'Kumar Mess', 'Meenakshi Bhavan'],
      'Mysore': ['Hotel RRR', 'Vinayaka Mylari', 'Depth N Green'],
      'Ooty': ['Earl\'s Secret', 'Ascot Multi Cuisine', 'Nahar\'s Sidewalk Cafe']
    };

    return diningOptions[place.city] || ['Local restaurants', 'Street food stalls', 'Hotel dining'];
  }

  findSimilarPlaces(selectedRoute, alternativePlaces, limit = 5) {
    const selectedCategories = selectedRoute.map(p => p.category);
    return alternativePlaces
      .filter(place => selectedCategories.includes(place.category))
      .sort((a, b) => b.rating - a.rating)
      .slice(0, limit);
  }

  async findNearbyAlternatives(selectedRoute, alternativePlaces) {
    // Implementation for finding nearby alternative places
    return alternativePlaces.slice(0, 3); // Simplified for now
  }

  findCategoryAlternatives(selectedRoute, alternativePlaces) {
    const categories = [...new Set(selectedRoute.map(p => p.category))];
    const alternatives = {};

    categories.forEach(category => {
      alternatives[category] = alternativePlaces
        .filter(place => place.category === category)
        .sort((a, b) => b.rating - a.rating)
        .slice(0, 3);
    });

    return alternatives;
  }

  calculateAverageDistance(distances) {
    let sum = 0;
    let count = 0;

    for (let i = 0; i < distances.length; i++) {
      for (let j = 0; j < distances[i].length; j++) {
        if (i !== j) {
          sum += distances[i][j];
          count++;
        }
      }
    }

    return count > 0 ? sum / count : 0;
  }

  getMaxDistance(distances) {
    let max = 0;
    for (let i = 0; i < distances.length; i++) {
      for (let j = 0; j < distances[i].length; j++) {
        if (i !== j && distances[i][j] > max) {
          max = distances[i][j];
        }
      }
    }
    return max;
  }

  getMinDistance(distances) {
    let min = Infinity;
    for (let i = 0; i < distances.length; i++) {
      for (let j = 0; j < distances[i].length; j++) {
        if (i !== j && distances[i][j] < min) {
          min = distances[i][j];
        }
      }
    }
    return min === Infinity ? 0 : min;
  }

  async generateTripSuggestions(criteria) {
    // AI-powered trip suggestions based on criteria
    let query = {};

    if (criteria.interests.length > 0) {
      query.category = { $in: criteria.interests };
    }

    const places = await Place.find(query)
      .sort({ rating: -1 })
      .limit(15);

    // Group suggestions by different themes
    const suggestions = {
      recommended: places.slice(0, 6),
      cultural: places.filter(p => ['temple', 'heritage', 'palace'].includes(p.category)).slice(0, 4),
      nature: places.filter(p => ['hill-station', 'beach', 'nature', 'wildlife'].includes(p.category)).slice(0, 4),
      quickTrip: places.filter(p => p.averageVisitDuration <= 120).slice(0, 4),
      weekend: places.filter(p => p.averageVisitDuration >= 180).slice(0, 3)
    };

    return suggestions;
  }

  async calculateImprovement(originalRoute, optimizedRoute) {
    if (!originalRoute.length || !optimizedRoute.length) return null;

    const originalMetrics = await this.calculateRouteMetrics(originalRoute);
    const optimizedMetrics = await this.calculateRouteMetrics(optimizedRoute);

    return {
      distanceReduction: originalMetrics.totalDistance - optimizedMetrics.totalDistance,
      timeReduction: originalMetrics.totalTime - optimizedMetrics.totalTime,
      efficiencyImprovement: optimizedMetrics.efficiency - originalMetrics.efficiency,
      percentageImprovement: {
        distance: ((originalMetrics.totalDistance - optimizedMetrics.totalDistance) / originalMetrics.totalDistance * 100).toFixed(2),
        time: ((originalMetrics.totalTime - optimizedMetrics.totalTime) / originalMetrics.totalTime * 100).toFixed(2)
      }
    };
  }

  async calculateRouteMetrics(route) {
    const routeMetrics = await this.distanceCalculator.calculateRouteMetrics(route);
    const totalVisitTime = route.reduce((sum, place) => sum + place.averageVisitDuration, 0);

    return {
      totalTime: routeMetrics.totalTime + totalVisitTime,
      totalDistance: routeMetrics.totalDistance,
      efficiency: route.length / ((routeMetrics.totalTime + totalVisitTime) / 60)
    };
  }
}

module.exports = new TripController();
---
// backend/routes/trips.js - Create this file if it doesn't exist
const express = require('express');
const router = express.Router();
const { Trip, TripTemplate } = require('../models/Trip');
const Place = require('../models/Place');

// GET /api/trips - Get all trips for a user
router.get('/', async (req, res) => {
  try {
    const { userId = 'anonymous', status, limit = 20 } = req.query;

    const filter = { userId };
    if (status) {
      filter.status = status;
    }

    const trips = await Trip.find(filter)
      .sort({ createdAt: -1 })
      .limit(parseInt(limit));

    res.json({
      success: true,
      trips,
      count: trips.length
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch trips',
      error: error.message
    });
  }
});

// GET /api/trips/:id - Get specific trip
router.get('/:id', async (req, res) => {
  try {
    const trip = await Trip.findById(req.params.id);

    if (!trip) {
      return res.status(404).json({
        success: false,
        message: 'Trip not found'
      });
    }

    res.json({
      success: true,
      trip
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch trip',
      error: error.message
    });
  }
});

// POST /api/trips/generate - Generate new optimized trip
router.post('/generate', async (req, res) => {
  try {
    const {
      userId = 'anonymous',
      preferences = {},
      places = [],
      name = 'My Trip',
      description = ''
    } = req.body;

    // Validate input
    if (!places || places.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'At least one place is required'
      });
    }

    // Create new trip
    const trip = new Trip({
      userId,
      name,
      description,
      places: places.map((place, index) => ({
        placeId: place.id || place._id,
        name: place.name,
        category: place.category,
        location: {
          latitude: place.location.latitude,
          longitude: place.location.longitude
        },
        visitDuration: place.averageVisitDuration || 120, // 2 hours default
        entryFee: place.entryFee?.indian || 0,
        order: index + 1
      })),
      preferences,
      status: 'planned'
    });

    // Calculate basic metrics
    trip.updateTripMetrics();

    await trip.save();

    res.status(201).json({
      success: true,
      message: 'Trip generated successfully',
      trip
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to generate trip',
      error: error.message
    });
  }
});

// POST /api/trips/optimize - Optimize existing trip or create optimized trip
router.post('/optimize', async (req, res) => {
  try {
    const {
      places = [],
      preferences = {},
      userId = 'anonymous',
      algorithm = 'greedy'
    } = req.body;

    if (!places || places.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Places array is required for optimization'
      });
    }

    // Simple greedy optimization (nearest neighbor)
    const optimizedPlaces = optimizePlacesOrder(places, preferences);

    // Calculate travel times and distances (simplified)
    const enhancedPlaces = await calculateTravelMetrics(optimizedPlaces);

    const optimizedTrip = {
      places: enhancedPlaces,
      metrics: {
        totalDistance: enhancedPlaces.reduce((sum, p) => sum + (p.travelDistanceToNext || 0), 0),
        totalTravelTime: enhancedPlaces.reduce((sum, p) => sum + (p.travelTimeToNext || 0), 0),
        totalVisitTime: enhancedPlaces.reduce((sum, p) => sum + p.visitDuration, 0),
        placesCount: enhancedPlaces.length
      },
      algorithm: algorithm,
      optimized: true
    };

    optimizedTrip.metrics.totalTime = optimizedTrip.metrics.totalTravelTime + optimizedTrip.metrics.totalVisitTime;
    optimizedTrip.metrics.efficiency = optimizedTrip.metrics.totalTime > 0 ? 
      (enhancedPlaces.length / (optimizedTrip.metrics.totalTime / 60)) : 0;

    res.json({
      success: true,
      message: 'Trip optimized successfully',
      optimizedTrip,
      originalOrder: places.map(p => p.name),
      optimizedOrder: enhancedPlaces.map(p => p.name),
      improvement: {
        message: 'Route optimized using greedy algorithm'
      }
    });
  } catch (error) {
    console.error('Optimization error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to optimize trip',
      error: error.message
    });
  }
});

// GET /api/trips/templates - Get trip templates
router.get('/templates', async (req, res) => {
  try {
    const { category, difficulty } = req.query;

    const filter = { isActive: true };
    if (category) filter.category = category;
    if (difficulty) filter.difficulty = difficulty;

    const templates = await TripTemplate.find(filter)
      .sort({ popularity: -1 })
      .limit(20);

    res.json({
      success: true,
      templates
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch templates',
      error: error.message
    });
  }
});

// PUT /api/trips/:id - Update trip
router.put('/:id', async (req, res) => {
  try {
    const trip = await Trip.findByIdAndUpdate(
      req.params.id, 
      req.body, 
      { new: true, runValidators: true }
    );

    if (!trip) {
      return res.status(404).json({
        success: false,
        message: 'Trip not found'
      });
    }

    res.json({
      success: true,
      message: 'Trip updated successfully',
      trip
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to update trip',
      error: error.message
    });
  }
});

// DELETE /api/trips/:id - Delete trip
router.delete('/:id', async (req, res) => {
  try {
    const trip = await Trip.findByIdAndDelete(req.params.id);

    if (!trip) {
      return res.status(404).json({
        success: false,
        message: 'Trip not found'
      });
    }

    res.json({
      success: true,
      message: 'Trip deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to delete trip',
      error: error.message
    });
  }
});

// Helper function for basic optimization
function optimizePlacesOrder(places, preferences = {}) {
  if (places.length <= 2) return places.map((p, i) => ({ ...p, order: i + 1 }));

  // Simple nearest neighbor algorithm
  const optimized = [];
  const remaining = [...places];

  // Start with the first place or user's preferred starting location
  let current = remaining.shift();
  current.order = 1;
  optimized.push(current);

  while (remaining.length > 0) {
    // Find nearest remaining place
    let nearestIndex = 0;
    let minDistance = calculateDistance(
      current.location.latitude, current.location.longitude,
      remaining[0].location.latitude, remaining[0].location.longitude
    );

    for (let i = 1; i < remaining.length; i++) {
      const distance = calculateDistance(
        current.location.latitude, current.location.longitude,
        remaining[i].location.latitude, remaining[i].location.longitude
      );

      if (distance < minDistance) {
        minDistance = distance;
        nearestIndex = i;
      }
    }

    current = remaining.splice(nearestIndex, 1)[0];
    current.order = optimized.length + 1;
    optimized.push(current);
  }

  return optimized;
}

// Helper function to calculate distance between two points
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Helper function to calculate travel metrics
async function calculateTravelMetrics(places) {
  const enhanced = [];

  for (let i = 0; i < places.length; i++) {
    const place = { ...places[i] };

    // Set default visit duration if not provided
    if (!place.visitDuration) {
      place.visitDuration = place.averageVisitDuration || 120; // 2 hours default
    }

    if (i < places.length - 1) {
      // Calculate distance and travel time to next place
      const nextPlace = places[i + 1];
      const distance = calculateDistance(
        place.location.latitude, place.location.longitude,
        nextPlace.location.latitude, nextPlace.location.longitude
      );

      place.travelDistanceToNext = Math.round(distance * 100) / 100; // Round to 2 decimal places
      place.travelTimeToNext = Math.round(distance * 2); // Rough estimate: 2 minutes per km
    } else {
      place.travelDistanceToNext = 0;
      place.travelTimeToNext = 0;
    }

    enhanced.push(place);
  }

  return enhanced;
}

module.exports = router;
--
// Update your server.js - Fix rate limiting configuration

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const connectDB = require('./config/database');

// Import routes
const placeRoutes = require('./routes/places');
const routeRoutes = require('./routes/routes');
const chatRoutes = require('./routes/chat');
const tripRoutes = require('./routes/trips');
const distanceRoutes = require('./routes/distance');

const app = express();
const PORT = process.env.PORT || 5000;

// Connect to MongoDB
connectDB();

// Security middleware
app.use(helmet());

// Enhanced rate limiting
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, 
  max: 100,
  message: {
    error: 'Too many requests from this IP, please try again later.',
    retryAfter: '15 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

const intensiveLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100, 
  message: {
    error: 'Too many optimization requests. Please try again later.',
    retryAfter: '15 minutes'
  }
});

// CORS configuration - MUST come before routes
const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};
app.use(cors(corsOptions));

// Body parsing middleware - MUST come before routes
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Request logging middleware
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  const ip = req.ip || req.connection.remoteAddress;
  console.log([${timestamp}] ${req.method} ${req.url} - IP: ${ip});
  next();
});

// Apply general rate limiting to all API routes (but allow more requests)
app.use('/api/', rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 200, // Increased from 100
  message: {
    error: 'Too many requests from this IP, please try again later.',
    retryAfter: '15 minutes'
  }
}));

// Apply intensive rate limiting only to specific optimization endpoints
app.use('/api/trips/generate', intensiveLimiter);
app.use('/api/trips/optimize', intensiveLimiter);
app.use('/api/trips/matrix', intensiveLimiter);
app.use('/api/routes/optimize', intensiveLimiter);
app.use('/api/routes/matrix', intensiveLimiter);

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const mongoose = require('mongoose');
    const dbStatus = mongoose.connection.readyState;

    let placeCount = 0;
    try {
      const Place = require('./models/Place');
      placeCount = await Place.countDocuments();
    } catch (dbError) {
      console.log('Database query failed:', dbError.message);
    }

    res.status(200).json({
      status: 'OK',
      success: true,
      database: dbStatus === 1 ? 'connected' : 'disconnected',
      placesInDatabase: placeCount,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      success: false, 
      message: error.message 
    });
  }
});

// Mount API routes
app.use('/api/places', placeRoutes);
app.use('/api/routes', routeRoutes);
app.use('/api/chat', chatRoutes);
app.use('/api/trips', tripRoutes);
app.use('/api/distance', distanceRoutes);

// API documentation endpoint
app.get('/api/docs', (req, res) => {
  res.status(200).json({
    title: 'TourWithAI Backend API Documentation',
    version: '2.0.0',
    description: 'AI-powered travel planning and route optimization API',
    baseUrl: ${req.protocol}://${req.get('host')}/api,
    endpoints: {
      places: {
        base: '/places',
        description: 'Tourist place data and search',
        methods: ['GET'],
        examples: [
          'GET /places - Get all places with filters',
          'GET /places/category/temple - Get temples',
          'GET /places/nearby?latitude=12.9716&longitude=77.5946 - Get nearby places'
        ]
      },
      trips: {
        base: '/trips',
        description: 'Advanced trip planning with AI optimization',
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        examples: [
          'GET /trips - Get all trips for user',
          'GET /trips/:id - Get specific trip',
          'POST /trips/generate - Generate new trip',
          'POST /trips/optimize - Optimize trip places',
          'GET /trips/templates - Get trip templates',
          'PUT /trips/:id - Update trip',
          'DELETE /trips/:id - Delete trip'
        ]
      },
      routes: {
        base: '/routes',
        description: 'Legacy route optimization',
        methods: ['GET', 'POST'],
        examples: [
          'POST /routes/optimize - Basic route optimization',
          'GET /routes/suggestions - Get route suggestions'
        ]
      },
      chat: {
        base: '/chat',
        description: 'AI chat assistant for travel planning',
        methods: ['POST'],
        examples: [
          'POST /chat - Chat with AI assistant'
        ]
      },
      distance: {
        base: '/distance',
        description: 'Distance and travel time calculations',
        methods: ['POST'],
        examples: [
          'POST /distance/matrix - Calculate distance matrix'
        ]
      }
    }
  });
});

// Test endpoint to verify trip optimization is working
app.get('/api/test/trips/optimize', async (req, res) => {
  res.json({
    success: true,
    message: 'Trip optimization endpoint is accessible',
    method: 'This is a GET test endpoint. Use POST /api/trips/optimize for actual optimization.',
    timestamp: new Date().toISOString()
  });
});

// Debug endpoint to list all places
app.get('/api/debug/places', async (req, res) => {
  try {
    const Place = require('./models/Place');
    const places = await Place.find({}).limit(5);
    const count = await Place.countDocuments();

    res.status(200).json({
      success: true,
      totalPlaces: count,
      samplePlaces: places.map(place => ({
        id: place.id || place._id,
        name: place.name,
        city: place.city,
        state: place.state,
        category: place.category
      })),
      message: Found ${count} places in database
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Failed to query places from database'
    });
  }
});

// 404 handler for unknown API endpoints
app.use('/api/*', (req, res) => {
  res.status(404).json({
    success: false,
    message: 'API endpoint not found',
    availableEndpoints: ['/places', '/routes', '/trips', '/chat', '/distance'],
    requestedEndpoint: req.originalUrl,
    suggestion: 'Check /api/docs for available endpoints'
  });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('Global error handler:', {
    error: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method
  });

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Validation Error',
      errors: Object.values(err.errors).map(e => e.message)
    });
  }

  res.status(err.status || 500).json({
    success: false,
    message: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
  });
});

// Start server
const server = app.listen(PORT, () => {
  console.log(🚀 TourWithAI Backend running on port ${PORT});
  console.log(📍 Environment: ${process.env.NODE_ENV || 'development'});
  console.log(🌐 CORS enabled for: ${process.env.FRONTEND_URL || 'http://localhost:3000'});
  console.log(📝 API Documentation: http://localhost:${PORT}/api/docs);
  console.log(🔍 Health Check: http://localhost:${PORT}/api/health);
  console.log(🧪 Test Endpoint: http://localhost:${PORT}/api/test/trips/optimize);
});

server.timeout = 120000;
module.exports = app;
---
import React, { useState, useEffect, useRef, useCallback, useMemo } from "react";
import * as d3 from "d3";
import { Loader, MapPin, Clock, IndianRupee, Star, Route, Settings, RefreshCw, Info } from "lucide-react";

const OptimizedGraphVisualization = ({ 
  optimizedRoute, 
  selectedPlaces, 
  visitedPlaces, 
  onPlaceVisited,
  isLoading,
  onOptimizeRoute,
  routeSettings,
  onRouteSettingsChange 
}) => {
  const svgRef = useRef();
  const [dimensions] = useState({ width: 900, height: 650 });
  const [simulation, setSimulation] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);
  const [showRouteInfo, setShowRouteInfo] = useState(false);

  // Category colors for different place types
  const categoryConfig = {
    temple: { color: "
#f59e0b", icon: "🛕" },
    palace: { color: "
#8b5cf6", icon: "🏰" },
    "hill-station": { color: "
#10b981", icon: "⛰️" },
    beach: { color: "
#06b6d4", icon: "🏖️" },
    heritage: { color: "
#f97316", icon: "🏛️" },
    nature: { color: "
#22c55e", icon: "🌿" },
    museum: { color: "
#ef4444", icon: "🏛️" },
    park: { color: "
#84cc16", icon: "🌳" },
    fort: { color: "
#a855f7", icon: "🏰" },
    waterfall: { color: "
#0ea5e9", icon: "💧" },
    default: { color: "
#6b7280", icon: "📍" }
  };

  const nodeSize = { radius: 25, fontSize: 14 };

  // Process the optimized route data to create nodes and links
  const processRouteData = useCallback(() => {
    if (!optimizedRoute || !optimizedRoute.route || optimizedRoute.route.length === 0) {
      return { nodes: [], links: [] };
    }

    console.log('🔄 Processing optimized route:', optimizedRoute);

    // Create nodes from the OPTIMIZED route (not original selection order)
    const nodes = optimizedRoute.route.map((place, index) => {
      // Ensure we have all required fields
      const processedPlace = {
        id: place.id || place._id,
        name: place.name,
        category: place.category || 'default',
        city: place.city,
        state: place.state,
        rating: place.rating || 0,
        location: place.location || { latitude: 0, longitude: 0 },
        averageVisitDuration: place.averageVisitDuration || place.visitDuration || 60,
        entryFee: place.entryFee || { indian: 0 },
        description: place.description || '',
        // Add optimization-specific data
        optimizationOrder: index + 1,
        isOptimized: true,
        // Initialize D3 position (will be updated by force simulation)
        x: dimensions.width / 2 + (Math.random() - 0.5) * 200,
        y: dimensions.height / 2 + (Math.random() - 0.5) * 200
      };

      console.log(📍 Node ${index + 1}: ${processedPlace.name} (ID: ${processedPlace.id}));
      return processedPlace;
    });

    // Create links based on the OPTIMIZED route order
    const links = [];
    for (let i = 0; i < nodes.length - 1; i++) {
      const sourceNode = nodes[i];
      const targetNode = nodes[i + 1];

      // Get travel info from itinerary if available
      const itineraryItem = optimizedRoute.itinerary?.[i];
      const travelTime = itineraryItem?.travelTimeToNext || 0;
      const travelDistance = itineraryItem?.travelDistanceToNext || 0;

      const link = {
        source: sourceNode.id,
        target: targetNode.id,
        order: i + 1,
        travelTime: travelTime,
        travelDistance: travelDistance,
        // D3 will replace source/target with node objects
      };

      console.log(🔗 Link ${i + 1}: ${sourceNode.name} → ${targetNode.name} (${travelTime}min, ${travelDistance}km));
      links.push(link);
    }

    console.log(✅ Created ${nodes.length} nodes and ${links.length} links from optimized route);
    return { nodes, links };
  }, [optimizedRoute, dimensions]);

  // D3 Force Simulation Setup
  useEffect(() => {
    if (!optimizedRoute || optimizedRoute.route.length === 0) {
      // Clear visualization if no optimized route
      const svg = d3.select(svgRef.current);
      svg.selectAll("*").remove();
      if (simulation) {
        simulation.stop();
        setSimulation(null);
      }
      return;
    }

    const { nodes, links } = processRouteData();

    if (nodes.length === 0) return;

    // Clear previous visualization
    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    console.log('🎨 Setting up D3 force simulation with', nodes.length, 'nodes');

    // Create force simulation
    const newSimulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links)
        .id(d => d.id)
        .distance(d => {
          // Dynamic distance based on travel time
          const baseDistance = 100;
          const travelTimeFactor = Math.min(d.travelTime / 30, 3); // Max 3x base distance
          return baseDistance + (travelTimeFactor * 50);
        })
        .strength(0.8)
      )
      .force("charge", d3.forceManyBody()
        .strength(-400)
        .distanceMax(300)
      )
      .force("center", d3.forceCenter(dimensions.width / 2, dimensions.height / 2))
      .force("collision", d3.forceCollide()
        .radius(nodeSize.radius + 15)
        .strength(0.7)
      )
      .alphaTarget(0)
      .alphaDecay(0.05);

    // Store simulation reference
    setSimulation(newSimulation);

    // Define drag behavior
    const dragStarted = (event, d) => {
      if (!event.active) newSimulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
      setHoveredNode(d);
    };

    const dragged = (event, d) => {
      d.fx = event.x;
      d.fy = event.y;
    };

    const dragEnded = (event, d) => {
      if (!event.active) newSimulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
      setHoveredNode(null);
    };

    // Create SVG elements
    const defs = svg.append("defs");

    // Arrow marker for route direction
    defs.append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", nodeSize.radius + 8)
      .attr("refY", 0)
      .attr("markerWidth", 8)
      .attr("markerHeight", 8)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "
#dc2626")
      .attr("stroke", "
#dc2626")
      .attr("stroke-width", 1);

    // Add gradient for links based on optimization efficiency
    const gradient = defs.append("linearGradient")
      .attr("id", "routeGradient")
      .attr("gradientUnits", "userSpaceOnUse");

    gradient.append("stop")
      .attr("offset", "0%")
      .attr("stop-color", "
#10b981")
      .attr("stop-opacity", 0.8);

    gradient.append("stop")
      .attr("offset", "100%")
      .attr("stop-color", "
#dc2626")
      .attr("stop-opacity", 0.8);

    // Create container groups
    const linksGroup = svg.append("g").attr("class", "links");
    const nodesGroup = svg.append("g").attr("class", "nodes");
    const labelsGroup = svg.append("g").attr("class", "labels");

    // Create links (route connections)
    const linkElements = linksGroup.selectAll(".route-link")
      .data(links)
      .enter().append("g")
      .attr("class", "route-link-group");

    // Main route line
    const linkLines = linkElements.append("line")
      .attr("class", "route-link")
      .attr("stroke", d => {
        // Color based on travel time - green for short, red for long
        const maxTime = Math.max(...links.map(l => l.travelTime));
        const intensity = maxTime > 0 ? d.travelTime / maxTime : 0;
        return d3.interpolateRgb("
#10b981", "
#dc2626")(intensity);
      })
      .attr("stroke-width", d => {
        // Width based on importance in route
        return Math.max(2, 6 - d.order);
      })
      .attr("stroke-dasharray", "8,4")
      .attr("marker-end", "url(#arrowhead)")
      .style("opacity", 0.8)
      .style("filter", "drop-shadow(1px 1px 2px rgba(0,0,0,0.3))");

    // Travel time labels on links
    const linkLabels = linkElements.append("text")
      .attr("class", "link-label")
      .attr("text-anchor", "middle")
      .attr("font-size", "10px")
      .attr("font-weight", "500")
      .attr("fill", "
#374151")
      .attr("stroke", "white")
      .attr("stroke-width", "2")
      .attr("paint-order", "stroke")
      .text(d => d.travelTime > 0 ? ${Math.round(d.travelTime)}min : '')
      .style("opacity", 0.7)
      .style("pointer-events", "none");

    // Create nodes (places)
    const nodeElements = nodesGroup.selectAll(".node-group")
      .data(nodes)
      .enter().append("g")
      .attr("class", "node-group")
      .style("cursor", "pointer")
      .call(d3.drag()
        .on("start", dragStarted)
        .on("drag", dragged)
        .on("end", dragEnded));

    // Node background circles (for better visibility)
    nodeElements.append("circle")
      .attr("class", "node-bg")
      .attr("r", nodeSize.radius + 3)
      .attr("fill", "white")
      .attr("stroke", "
#e5e7eb")
      .attr("stroke-width", 2)
      .style("opacity", 0.9);

    // Main node circles
    const nodeCircles = nodeElements.append("circle")
      .attr("class", "node-circle")
      .attr("r", nodeSize.radius)
      .attr("fill", d => {
        if (visitedPlaces && visitedPlaces.has(d.id)) {
          return "
#22c55e"; // Green for visited
        }
        const category = categoryConfig[d.category] || categoryConfig.default;
        return category.color;
      })
      .attr("stroke", "white")
      .attr("stroke-width", 3)
      .style("filter", "drop-shadow(2px 2px 4px rgba(0,0,0,0.25))")
      .style("transition", "all 0.3s ease");

    // Optimization order numbers
    const orderLabels = nodeElements.append("text")
      .attr("class", "order-label")
      .attr("text-anchor", "middle")
      .attr("dy", "0.35em")
      .attr("font-family", "Inter, system-ui, sans-serif")
      .attr("font-size", nodeSize.fontSize)
      .attr("font-weight", "700")
      .attr("fill", "white")
      .attr("stroke", "rgba(0,0,0,0.1)")
      .attr("stroke-width", "0.5")
      .text(d => d.optimizationOrder)
      .style("pointer-events", "none")
      .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)");

    // Place names below nodes
    const nameLabels = labelsGroup.selectAll(".name-label")
      .data(nodes)
      .enter().append("text")
      .attr("class", "name-label")
      .attr("text-anchor", "middle")
      .attr("dy", nodeSize.radius + 20)
      .attr("font-family", "Inter, system-ui, sans-serif")
      .attr("font-size", "12px")
      .attr("font-weight", "600")
      .attr("fill", "
#1f2937")
      .attr("stroke", "white")
      .attr("stroke-width", "3")
      .attr("paint-order", "stroke")
      .text(d => {
        const maxLength = 12;
        return d.name.length > maxLength ? 
          d.name.substring(0, maxLength) + "..." : 
          d.name;
      })
      .style("pointer-events", "none");

    // Mouse events for interactivity
    nodeElements
      .on("mouseenter", (event, d) => {
        setHoveredNode(d);
        // Highlight connected links
        linkLines.style("opacity", link => 
          link.source.id === d.id || link.target.id === d.id ? 1 : 0.3
        );
        nodeCircles.style("opacity", node => 
          node.id === d.id ? 1 : 0.6
        );
      })
      .on("mouseleave", () => {
        setHoveredNode(null);
        linkLines.style("opacity", 0.8);
        nodeCircles.style("opacity", 1);
      })
      .on("click", (event, d) => {
        if (onPlaceVisited) {
          const isVisited = visitedPlaces && visitedPlaces.has(d.id);
          onPlaceVisited(d.id, !isVisited);
        }
      });

    // Tooltips
    nodeElements.append("title")
      .text(d => {
        const isVisited = visitedPlaces && visitedPlaces.has(d.id);
        const category = categoryConfig[d.category] || categoryConfig.default;
        return [
          ${d.optimizationOrder}. ${d.name},
          ${category.icon} ${d.category},
          📍 ${d.city}, ${d.state},
          ⭐ ${d.rating}/5,
          ⏱️ ${Math.round(d.averageVisitDuration)}min visit,
          💰 ₹${d.entryFee?.indian || 0},
          ${isVisited ? '✅ Visited' : '📋 Not visited yet'},
          '',
          'Click to mark as visited/unvisited',
          'Drag to reposition'
        ].join('\n');
      });

    // Update positions on simulation tick
    newSimulation.on("tick", () => {
      // Update link positions
      linkLines
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      // Update link label positions (midpoint of link)
      linkLabels
        .attr("x", d => (d.source.x + d.target.x) / 2)
        .attr("y", d => (d.source.y + d.target.y) / 2 - 8);

      // Update node positions
      nodeElements.attr("transform", d => translate(${d.x},${d.y}));
      nameLabels.attr("transform", d => translate(${d.x},${d.y}));
    });

    // Cleanup function
    return () => {
      if (newSimulation) {
        newSimulation.stop();
      }
    };

  }, [optimizedRoute, visitedPlaces, processRouteData, dimensions, onPlaceVisited]);

  // Calculate route statistics
  const routeStats = useMemo(() => {
    if (!optimizedRoute) return null;

    const { route, itinerary, totalTime, totalDistance, efficiency } = optimizedRoute;
    const visitedCount = visitedPlaces ? visitedPlaces.size : 0;
    const totalCost = route?.reduce((sum, place) => sum + (place.entryFee?.indian || 0), 0) || 0;

    return {
      totalPlaces: route?.length || 0,
      visitedCount,
      totalTime: Math.round(totalTime || 0),
      totalDistance: Math.round((totalDistance || 0) * 100) / 100,
      totalCost,
      efficiency: Math.round(efficiency || 0),
      averageRating: route?.length > 0 ? 
        Math.round((route.reduce((sum, p) => sum + (p.rating || 0), 0) / route.length) * 10) / 10 : 0
    };
  }, [optimizedRoute, visitedPlaces]);

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center h-96 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
        <Loader size={48} className="animate-spin text-blue-500 mb-4" />
        <p className="text-lg font-semibold text-gray-700">Optimizing your route...</p>
        <p className="text-sm text-gray-500">Finding the best path through your selected places</p>
      </div>
    );
  }

  if (!optimizedRoute || !optimizedRoute.route || optimizedRoute.route.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-96 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
        <div className="text-6xl mb-4">🗺️</div>
        <h3 className="text-xl font-semibold text-gray-700 mb-2">No Optimized Route Yet</h3>
        <p className="text-gray-500 text-center mb-6 max-w-md">
          Select at least 2 places and click "Optimize Route" to see your personalized travel path with optimal connections.
        </p>
        {selectedPlaces && selectedPlaces.length >= 2 && (
          <button
            onClick={onOptimizeRoute}
            className="flex items-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            <Route size={20} />
            Optimize Route for {selectedPlaces.length} Places
          </button>
        )}
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Route Statistics Header */}
      {routeStats && (
        <div className="bg-white rounded-lg p-4 shadow-sm border">
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-lg font-semibold text-gray-900 flex items-center gap-2">
              <Route className="text-blue-600" size={20} />
              Optimized Route Visualization
            </h3>
            <button
              onClick={() => setShowRouteInfo(!showRouteInfo)}
              className="flex items-center gap-1 text-sm text-gray-500 hover:text-gray-700"
            >
              <Info size={16} />
              {showRouteInfo ? 'Hide' : 'Show'} Info
            </button>
          </div>

          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-4 text-sm">
            <div className="flex items-center gap-2">
              <MapPin size={16} className="text-blue-600" />
              <div>
                <div className="font-semibold">{routeStats.totalPlaces}</div>
                <div className="text-gray-500">Places</div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Clock size={16} className="text-green-600" />
              <div>
                <div className="font-semibold">{routeStats.totalTime}min</div>
                <div className="text-gray-500">Total Time</div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Route size={16} className="text-purple-600" />
              <div>
                <div className="font-semibold">{routeStats.totalDistance}km</div>
                <div className="text-gray-500">Distance</div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <IndianRupee size={16} className="text-orange-600" />
              <div>
                <div className="font-semibold">₹{routeStats.totalCost}</div>
                <div className="text-gray-500">Entry Fees</div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Star size={16} className="text-yellow-600" />
              <div>
                <div className="font-semibold">{routeStats.averageRating}/5</div>
                <div className="text-gray-500">Avg Rating</div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-green-500 rounded-full"></div>
              <div>
                <div className="font-semibold">{routeStats.visitedCount}</div>
                <div className="text-gray-500">Visited</div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-blue-500 rounded-full"></div>
              <div>
                <div className="font-semibold">{routeStats.efficiency}%</div>
                <div className="text-gray-500">Efficiency</div>
              </div>
            </div>
          </div>

          {showRouteInfo && optimizedRoute.itinerary && (
            <div className="mt-4 pt-4 border-t">
              <h4 className="font-semibold text-gray-900 mb-2">Route Sequence:</h4>
              <div className="flex flex-wrap gap-2">
                {optimizedRoute.itinerary.map((item, index) => (
                  <div
                    key={item.place.id}
                    className="flex items-center gap-1 px-3 py-1 bg-gray-100 rounded-full text-sm"
                  >
                    <span className="font-semibold text-blue-600">{index + 1}</span>
                    <span>{item.place.name}</span>
                    {item.travelTimeToNext > 0 && (
                      <span className="text-gray-500">
                        → {Math.round(item.travelTimeToNext)}min
                      </span>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Main Visualization */}
      <div className="bg-white rounded-lg shadow-sm border overflow-hidden">
        <div className="relative">
          <svg
            ref={svgRef}
            width={dimensions.width}
            height={dimensions.height}
            className="w-full bg-gradient-to-br from-blue-50 to-indigo-100"
            style={{ minHeight: '400px' }}
          />

          {/* Hovered Node Info Overlay */}
          {hoveredNode && (
            <div className="absolute top-4 left-4 bg-white rounded-lg shadow-lg p-3 border max-w-xs z-10">
              <div className="flex items-center gap-2 mb-2">
                <div 
                  className="w-4 h-4 rounded-full"
                  style={{ 
                    backgroundColor: visitedPlaces && visitedPlaces.has(hoveredNode.id) ? 
                      '
#22c55e' : 
                      (categoryConfig[hoveredNode.category] || categoryConfig.default).color 
                  }}
                />
                <span className="font-semibold text-sm">
                  #{hoveredNode.optimizationOrder} {hoveredNode.name}
                </span>
              </div>
              <div className="text-xs text-gray-600 space-y-1">
                <div>📍 {hoveredNode.city}, {hoveredNode.state}</div>
                <div>⭐ {hoveredNode.rating}/5 rating</div>
                <div>⏱️ {Math.round(hoveredNode.averageVisitDuration)} min visit</div>
                <div>💰 ₹{hoveredNode.entryFee?.indian || 0} entry fee</div>
                <div className="text-blue-600 font-medium">
                  {visitedPlaces && visitedPlaces.has(hoveredNode.id) ? '✅ Visited' : '📋 Click to mark visited'}
                </div>
              </div>
            </div>
          )}

          {/* Legend */}
          <div className="absolute bottom-4 right-4 bg-white rounded-lg shadow-lg p-3 border">
            <h4 className="font-semibold text-sm mb-2">Legend</h4>
            <div className="space-y-1 text-xs">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                <span>Visited Places</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-gray-400 rounded-full"></div>
                <span>Not Visited</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-0.5 bg-gradient-to-r from-green-500 to-red-500"></div>
                <span>Route Path</span>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-blue-600 font-semibold">1,2,3...</span>
                <span>Optimized Order</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Instructions */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <div className="flex items-start gap-3">
          <Info size={20} className="text-blue-600 mt-0.5 flex-shrink-0" />
          <div className="text-sm">
            <p className="font-semibold text-blue-900 mb-1">How to use this visualization:</p>
            <ul className="text-blue-800 space-y-1">
              <li>• <strong>Numbers on nodes</strong> show the optimized visit order from your algorithm</li>
              <li>• <strong>Colored arrows</strong> indicate the optimal travel path (green=short travel, red=longer travel)</li>
              <li>• <strong>Drag nodes</strong> to reposition them for better viewing</li>
              <li>• <strong>Click nodes</strong> to mark places as visited/unvisited</li>
              <li>• <strong>Hover nodes</strong> to see detailed information</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
};

export default OptimizedGraphVisualization;
---
import React, { useState } from 'react';
import { 
  Clock, 
  MapPin, 
  Navigation, 
  CheckCircle, 
  Circle,
  Star,
  IndianRupee,
  Users,
  Car,
  Info,
  Download,
  Share2,
  Calendar
} from 'lucide-react';
import { UTILS } from '../utils/constants';
import toast from 'react-hot-toast';

const ItineraryDisplay = ({ 
  itinerary, 
  optimizedRoute, 
  visitedPlaces, 
  onPlaceVisited, 
  routeSettings 
}) => {
  const [expandedPlace, setExpandedPlace] = useState(null);
  const [showTravelDetails, setShowTravelDetails] = useState(false);

  if (!itinerary || itinerary.length === 0) {
    return (
      <div className="itinerary-empty">
        <div className="empty-state">
          <Calendar className="empty-icon" />
          <h3>No Itinerary Yet</h3>
          <p>Select places and optimize your route to see your personalized itinerary.</p>
        </div>
      </div>
    );
  }

  const summary = {
    totalPlaces: itinerary.length,
    totalTime: itinerary.reduce((sum, item) => 
      sum + (item.visitDuration || 0) + (item.travelTimeToNext || 0), 0
    ),
    totalDistance: itinerary.reduce((sum, item) => 
      sum + (item.travelDistanceToNext || 0), 0
    ),
    visitedCount: itinerary.filter(item => 
      visitedPlaces.has(item.place.id)
    ).length,
    estimatedCost: itinerary.reduce((sum, item) => 
      sum + (item.place.entryFee?.indian || 0), 0
    )
  };

  const handlePlaceVisited = (placeId, isVisited) => {
    onPlaceVisited(placeId, isVisited);
    toast.success(
      isVisited ? 'Place marked as visited!' : 'Place unmarked as visited'
    );
  };

  const handleShareItinerary = async () => {
    const itineraryText = My South India Travel Itinerary:\n\n${
      itinerary.map((item, index) => 
        ${index + 1}. ${item.place.name} (${item.arrivalTime} - ${item.departureTime})
      ).join('\n')
    }\n\nGenerated by TourWithAI;

    try {
      if (navigator.share) {
        await navigator.share({
          title: 'My South India Itinerary',
          text: itineraryText
        });
      } else {
        await navigator.clipboard.writeText(itineraryText);
        toast.success('Itinerary copied to clipboard!');
      }
    } catch (error) {
      console.error('Share failed:', error);
      toast.error('Failed to share itinerary');
    }
  };

  const handleDownloadItinerary = () => {
    const itineraryData = {
      title: 'My South India Travel Itinerary',
      generatedAt: new Date().toISOString(),
      settings: routeSettings,
      summary,
      places: itinerary.map(item => ({
        name: item.place.name,
        city: item.place.city,
        state: item.place.state,
        arrivalTime: item.arrivalTime,
        departureTime: item.departureTime,
        visitDuration: item.visitDuration,
        entryFee: item.place.entryFee,
        category: item.place.category,
        rating: item.place.rating,
        description: item.place.description,
        address: item.place.address,
        amenities: item.place.amenities
      }))
    };

    const dataStr = JSON.stringify(itineraryData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = TourWithAI-Itinerary-${new Date().toISOString().split('T')[0]}.json;
    link.click();
    URL.revokeObjectURL(url);
    toast.success('Itinerary downloaded!');
  };

  return (
    <div className="itinerary-container">
      <div className="itinerary-header">
        <div className="itinerary-title">
          <Calendar className="title-icon" />
          <h3>Your Itinerary</h3>
        </div>

        <div className="itinerary-actions">
          <button 
            onClick={handleShareItinerary}
            className="action-btn"
            title="Share Itinerary"
          >
            <Share2 size={16} />
          </button>
          <button 
            onClick={handleDownloadItinerary}
            className="action-btn"
            title="Download Itinerary"
          >
            <Download size={16} />
          </button>
        </div>
      </div>

      <div className="itinerary-summary">
        <div className="summary-cards">
          <div className="summary-card">
            <MapPin className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">{summary.totalPlaces}</span>
              <span className="summary-label">Places</span>
            </div>
          </div>

          <div className="summary-card">
            <Clock className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">{UTILS.formatDuration(summary.totalTime)}</span>
              <span className="summary-label">Total Time</span>
            </div>
          </div>

          <div className="summary-card">
            <Navigation className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">{UTILS.formatDistance(summary.totalDistance)}</span>
              <span className="summary-label">Distance</span>
            </div>
          </div>

          <div className="summary-card">
            <IndianRupee className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">₹{summary.estimatedCost}</span>
              <span className="summary-label">Entry Fees</span>
            </div>
          </div>
        </div>

        <div className="progress-section">
          <div className="progress-header">
            <span>Progress: {summary.visitedCount}/{summary.totalPlaces} places visited</span>
            <span className="progress-percentage">
              {Math.round((summary.visitedCount / summary.totalPlaces) * 100)}%
            </span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: ${(summary.visitedCount / summary.totalPlaces) * 100}% 
              }}
            />
          </div>
        </div>
      </div>

      <div className="itinerary-list">
        {itinerary.map((item, index) => {
          const isVisited = visitedPlaces.has(item.place.id);
          const isExpanded = expandedPlace === item.place.id;
          const isLast = index === itinerary.length - 1;

          return (
            <div key={item.place.id} className={itinerary-item ${isVisited ? 'visited' : ''}}>
              <div className="timeline-connector">
                <div className={timeline-dot ${isVisited ? 'completed' : ''}}>
                  {isVisited ? (
                    <CheckCircle className="timeline-icon completed" />
                  ) : (
                    <Circle className="timeline-icon" />
                  )}
                </div>
                {!isLast && <div className="timeline-line" />}
              </div>

              <div className="itinerary-content">
                <div className="place-header">
                  <div className="place-main-info">
                    <div className="place-number">{index + 1}</div>
                    <div className="place-details">
                      <h4 className="place-name">{item.place.name}</h4>
                      <p className="place-location">
                        {item.place.city}, {item.place.state}
                      </p>
                    </div>
                  </div>

                  <div className="place-actions">
                    <button
                      onClick={() => handlePlaceVisited(item.place.id, !isVisited)}
                      className={visited-btn ${isVisited ? 'visited' : ''}}
                      title={isVisited ? 'Mark as not visited' : 'Mark as visited'}
                    >
                      {isVisited ? (
                        <CheckCircle className="visited-icon" />
                      ) : (
                        <Circle className="visited-icon" />
                      )}
                    </button>

                    <button
                      onClick={() => setExpandedPlace(isExpanded ? null : item.place.id)}
                      className="expand-btn"
                      title={isExpanded ? 'Show less' : 'Show more'}
                    >
                      <Info className={expand-icon ${isExpanded ? 'expanded' : ''}} />
                    </button>
                  </div>
                </div>

                <div className="timing-info">
                  <div className="timing-item">
                    <Clock className="timing-icon" />
                    <span>{item.arrivalTime} - {item.departureTime}</span>
                    <span className="duration">({UTILS.formatDuration(item.visitDuration)})</span>
                  </div>

                  {item.place.rating && (
                    <div className="rating">
                      <Star className="star-icon filled" />
                      <span>{item.place.rating}</span>
                    </div>
                  )}
                </div>

                {isExpanded && (
                  <div className="expanded-details">
                    <div className="place-description">
                      <p>{item.place.description}</p>
                    </div>

                    <div className="place-meta">
                      <div className="meta-grid">
                        <div className="meta-item">
                          <span className="meta-label">Category:</span>
                          <span className="meta-value">{item.place.category}</span>
                        </div>

                        {item.place.entryFee && (
                          <div className="meta-item">
                            <span className="meta-label">Entry Fee:</span>
                            <span className="meta-value">
                              ₹{item.place.entryFee.indian} 
                              {item.place.entryFee.foreign > 0 && 
                                 / ₹${item.place.entryFee.foreign} (Foreign)
                              }
                            </span>
                          </div>
                        )}

                        {item.place.kidFriendly && (
                          <div className="meta-item">
                            <span className="meta-label">Kid Friendly:</span>
                            <span className="meta-value">Yes</span>
                          </div>
                        )}

                        {item.place.wheelchairAccessible && (
                          <div className="meta-item">
                            <span className="meta-label">Wheelchair Access:</span>
                            <span className="meta-value">Yes</span>
                          </div>
                        )}
                      </div>

                      {item.place.amenities && item.place.amenities.length > 0 && (
                        <div className="amenities">
                          <span className="amenities-label">Amenities:</span>
                          <div className="amenities-list">
                            {item.place.amenities.map((amenity, idx) => (
                              <span key={idx} className="amenity-tag">
                                {amenity}
                              </span>
                            ))}
                          </div>
                        </div>
                      )}

                      {item.place.bestTimeToVisit && item.place.bestTimeToVisit.length > 0 && (
                        <div className="best-time">
                          <span className="best-time-label">Best time to visit:</span>
                          <span className="best-time-value">
                            {item.place.bestTimeToVisit.join(', ')}
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {!isLast && item.travelTimeToNext > 0 && (
                  <div className="travel-info">
                    <div className="travel-header">
                      <Car className="travel-icon" />
                      <span>Travel to next destination</span>
                    </div>

                    <div className="travel-details">
                      <div className="travel-time">
                        <Clock className="detail-icon" />
                        <span>{UTILS.formatDuration(item.travelTimeToNext)}</span>
                      </div>

                      {item.travelDistanceToNext > 0 && (
                        <div className="travel-distance">
                          <Navigation className="detail-icon" />
                          <span>{UTILS.formatDistance(item.travelDistanceToNext)}</span>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>

      <div className="itinerary-settings">
        <h4>Route Settings</h4>
        <div className="settings-grid">
          <div className="setting-item">
            <span className="setting-label">Start Time:</span>
            <span className="setting-value">{routeSettings?.startTime || '09:00'}</span>
          </div>

          <div className="setting-item">
            <span className="setting-label">Available Time:</span>
            <span className="setting-value">
              {UTILS.formatDuration(routeSettings?.totalTimeAvailable || 480)}
            </span>
          </div>

          <div className="setting-item">
            <span className="setting-label">Optimization:</span>
            <span className="setting-value">
              {routeSettings?.optimizationLevel === 'optimal' ? 'Optimal (DP)' : 'Fast (Greedy)'}
            </span>
          </div>
        </div>
      </div>

      <div className="itinerary-tips">
        <h4>💡 Travel Tips</h4>
        <ul className="tips-list">
          <li>Check opening hours before visiting temples and palaces</li>
          <li>Carry water and snacks for longer journeys</li>
          <li>Keep extra time buffer for traffic in city areas</li>
          <li>Download offline maps for areas with poor connectivity</li>
          <li>Respect local customs and dress codes at religious sites</li>
        </ul>
      </div>

      <div className="emergency-info">
        <h4>🆘 Emergency Contacts</h4>
        <div className="emergency-grid">
          <div className="emergency-item">
            <span className="emergency-label">Police:</span>
            <span className="emergency-number">100</span>
          </div>
          <div className="emergency-item">
            <span className="emergency-label">Ambulance:</span>
            <span className="emergency-number">108</span>
          </div>
          <div className="emergency-item">
            <span className="emergency-label">Fire:</span>
            <span className="emergency-number">101</span>
          </div>
          <div className="emergency-item">
            <span className="emergency-label">Tourist Helpline:</span>
            <span className="emergency-number">1363</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ItineraryDisplay;
--
import React, { useState, useMemo, useEffect } from 'react';
import { 
  Search, 
  Filter, 
  MapPin, 
  Star, 
  Clock, 
  IndianRupee,
  Users,
  Accessibility,
  CarIcon,
  X,
  ChevronDown,
  CheckCircle2
} from 'lucide-react';
import { PLACE_CATEGORIES, SOUTH_INDIAN_STATES, UTILS } from '../utils/constants';
import toast from 'react-hot-toast';

const LocationSelector = ({
  places: placesData,  // Renamed to avoid confusion
  selectedPlaces,
  onPlaceSelect,
  onOptimizeRoute,
  onClearSelection,
  isLoading,
  error
}) => {
  // Extract places array from API response - FIXED VERSION
  const places = useMemo(() => {
    // If placesData is already an array, use it directly
    if (Array.isArray(placesData)) {
      return placesData;
    }

    // If it's an API response object, prioritize the 'data' property for filtered results
    if (placesData && typeof placesData === 'object') {
      // First check for 'data' property (filtered results from API)
      if (Array.isArray(placesData.data)) {
        console.log('Using filtered data from API response:', placesData.data.length, 'places');
        return placesData.data;
      }

      // Fallback to 'allPlaces' only if 'data' is not available
      if (Array.isArray(placesData.allPlaces)) {
        console.log('Using allPlaces as fallback:', placesData.allPlaces.length, 'places');
        return placesData.allPlaces;
      }
    }

    // Default to empty array
    console.log('No valid places data found, returning empty array');
    return [];
  }, [placesData]);

  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [selectedState, setSelectedState] = useState('all');
  const [sortBy, setSortBy] = useState('rating');
  const [showFilters, setShowFilters] = useState(false);
  const [priceFilter, setPriceFilter] = useState('all');
  const [kidFriendlyOnly, setKidFriendlyOnly] = useState(false);
  const [wheelchairAccessibleOnly, setWheelchairAccessibleOnly] = useState(false);

  // Add debug logging
  useEffect(() => {
    console.log('LocationSelector - placesData:', placesData);
    console.log('LocationSelector - extracted places:', places);
    console.log('LocationSelector - places length:', places.length);

    // Log the structure of the API response for debugging
    if (placesData && typeof placesData === 'object' && !Array.isArray(placesData)) {
      console.log('API Response structure:', {
        hasData: Array.isArray(placesData.data),
        dataCount: placesData.data?.length,
        hasAllPlaces: Array.isArray(placesData.allPlaces),
        allPlacesCount: placesData.allPlaces?.length,
        filters: placesData.filters,
        success: placesData.success
      });
    }
  }, [placesData, places]);

  const filteredPlaces = useMemo(() => {
    let filtered = [...places];

    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase();
      filtered = filtered.filter(place =>
        place.name.toLowerCase().includes(searchLower) ||
        place.description.toLowerCase().includes(searchLower) ||
        place.city.toLowerCase().includes(searchLower) ||
        place.tags?.some(tag => tag.toLowerCase().includes(searchLower))
      );
    }

    if (selectedCategory !== 'all') {
      filtered = filtered.filter(place => place.category === selectedCategory);
    }

    if (selectedState !== 'all') {
      filtered = filtered.filter(place => place.state === selectedState);
    }

    if (priceFilter !== 'all') {
      filtered = filtered.filter(place => {
        const fee = place.entryFee?.indian || 0;
        switch (priceFilter) {
          case 'free': return fee === 0;
          case 'low': return fee > 0 && fee <= 50;
          case 'medium': return fee > 50 && fee <= 200;
          case 'high': return fee > 200;
          default: return true;
        }
      });
    }

    if (kidFriendlyOnly) {
      filtered = filtered.filter(place => place.kidFriendly);
    }

    if (wheelchairAccessibleOnly) {
      filtered = filtered.filter(place => place.wheelchairAccessible);
    }

    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'rating':
          return (b.rating || 0) - (a.rating || 0);
        case 'name':
          return a.name.localeCompare(b.name);
        case 'duration':
          return a.averageVisitDuration - b.averageVisitDuration;
        case 'price':
          return (a.entryFee?.indian || 0) - (b.entryFee?.indian || 0);
        default:
          return 0;
      }
    });

    return filtered;
  }, [
    places, 
    searchTerm, 
    selectedCategory, 
    selectedState, 
    sortBy, 
    priceFilter,
    kidFriendlyOnly,
    wheelchairAccessibleOnly
  ]);

  const handlePlaceToggle = (place) => {
    const isSelected = selectedPlaces.some(p => p.id === place.id);
    onPlaceSelect(place, !isSelected);

    toast.success(
      isSelected ? 
        ${place.name} removed from selection : 
        ${place.name} added to selection
    );
  };

  const clearAllFilters = () => {
    setSearchTerm('');
    setSelectedCategory('all');
    setSelectedState('all');
    setSortBy('rating');
    setPriceFilter('all');
    setKidFriendlyOnly(false);
    setWheelchairAccessibleOnly(false);
    setShowFilters(false);
  };

  const getActiveFilterCount = () => {
    let count = 0;
    if (selectedCategory !== 'all') count++;
    if (selectedState !== 'all') count++;
    if (priceFilter !== 'all') count++;
    if (kidFriendlyOnly) count++;
    if (wheelchairAccessibleOnly) count++;
    return count;
  };

  // Show API filter info when available
  const getApiFilterInfo = () => {
    if (placesData && placesData.filters) {
      const filterInfo = [];
      if (placesData.filters.category) {
        filterInfo.push(Category: ${placesData.filters.category});
      }
      if (placesData.filters.state) {
        filterInfo.push(State: ${placesData.filters.state});
      }
      return filterInfo.length > 0 ? filterInfo.join(', ') : null;
    }
    return null;
  };

  if (error) {
    return (
      <div className="location-selector error">
        <div className="error-message">
          <p>❌ {error}</p>
          <button onClick={() => window.location.reload()} className="retry-btn">
            Retry
          </button>
        </div>
      </div>
    );
  }

  const apiFilterInfo = getApiFilterInfo();

  return (
    <div className="location-selector">
      <div className="selector-header">
        <div className="header-title">
          <h3>Select Places</h3>
          <span className="places-count">
            {selectedPlaces.length} of {places.length} places
            {apiFilterInfo && (
              <span className="api-filter-info"> • API Filters: {apiFilterInfo}</span>
            )}
          </span>
        </div>

        {selectedPlaces.length > 0 && (
          <div className="selection-summary">
            <div className="selected-info">
              <CheckCircle2 className="selected-icon" />
              <span>{selectedPlaces.length} selected</span>
            </div>
            <button onClick={onClearSelection} className="clear-btn">
              Clear All
            </button>
          </div>
        )}
      </div>

      {/* Show API response info for debugging */}
      {placesData && typeof placesData === 'object' && !Array.isArray(placesData) && (
        <div className="api-debug-info" style={{ fontSize: '12px', color: '#666', marginBottom: '10px' }}>
          API Response: {placesData.success ? '✅' : '❌'} | 
          Data: {placesData.data?.length || 0} | 
          All: {placesData.allPlaces?.length || 0} | 
          Total: {placesData.totalCount || 0}
        </div>
      )}

      <div className="search-container">
        <div className="search-input-container">
          <Search className="search-icon" />
          <input
            type="text"
            placeholder="Search places, cities, or descriptions..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="search-input"
          />
          {searchTerm && (
            <button 
              onClick={() => setSearchTerm('')}
              className="clear-search"
            >
              <X size={16} />
            </button>
          )}
        </div>
      </div>

      <div className="filter-bar">
        <button 
          onClick={() => setShowFilters(!showFilters)}
          className={filter-toggle ${showFilters ? 'active' : ''}}
        >
          <Filter size={16} />
          <span>Filters</span>
          {getActiveFilterCount() > 0 && (
            <span className="filter-count">{getActiveFilterCount()}</span>
          )}
          <ChevronDown className={chevron ${showFilters ? 'rotated' : ''}} />
        </button>

        <select
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value)}
          className="sort-select"
        >
          <option value="rating">Sort by Rating</option>
          <option value="name">Sort by Name</option>
          <option value="duration">Sort by Duration</option>
          <option value="price">Sort by Price</option>
        </select>
      </div>

      {showFilters && (
        <div className="filters-panel">
          <div className="filters-grid">
            <div className="filter-group">
              <label>Category:</label>
              <select
                value={selectedCategory}
                onChange={(e) => setSelectedCategory(e.target.value)}
                className="filter-select"
              >
                <option value="all">All Categories</option>
                {Object.entries(PLACE_CATEGORIES).map(([key, category]) => (
                  <option key={key} value={key}>
                    {category.icon} {category.label}
                  </option>
                ))}
              </select>
            </div>

            <div className="filter-group">
              <label>State:</label>
              <select
                value={selectedState}
                onChange={(e) => setSelectedState(e.target.value)}
                className="filter-select"
              >
                <option value="all">All States</option>
                {Object.entries(SOUTH_INDIAN_STATES).map(([state, info]) => (
                  <option key={state} value={state}>
                    {info.code} - {state}
                  </option>
                ))}
              </select>
            </div>

            <div className="filter-group">
              <label>Entry Fee:</label>
              <select
                value={priceFilter}
                onChange={(e) => setPriceFilter(e.target.value)}
                className="filter-select"
              >
                <option value="all">All Prices</option>
                <option value="free">Free (₹0)</option>
                <option value="low">Low (₹1-50)</option>
                <option value="medium">Medium (₹51-200)</option>
                <option value="high">High (₹200+)</option>
              </select>
            </div>
          </div>

          <div className="filter-checkboxes">
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={kidFriendlyOnly}
                onChange={(e) => setKidFriendlyOnly(e.target.checked)}
              />
              <Users size={16} />
              <span>Kid Friendly Only</span>
            </label>

            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={wheelchairAccessibleOnly}
                onChange={(e) => setWheelchairAccessibleOnly(e.target.checked)}
              />
              <Accessibility size={16} />
              <span>Wheelchair Accessible Only</span>
            </label>
          </div>

          <div className="filter-actions">
            <button onClick={clearAllFilters} className="clear-filters-btn">
              Clear Filters
            </button>
          </div>
        </div>
      )}

      <div className="places-list">
        {isLoading ? (
          <div className="loading-places">
            <div className="loading-spinner"></div>
            <p>Loading places...</p>
          </div>
        ) : filteredPlaces.length === 0 && places.length > 0 ? (
          <div className="no-places">
            <div className="no-places-icon">🔍</div>
            <h4>No places found</h4>
            <p>Try adjusting your search or filters</p>
            {searchTerm || getActiveFilterCount() > 0 ? (
              <button onClick={clearAllFilters} className="reset-filters-btn">
                Reset Filters
              </button>
            ) : null}
          </div>
        ) : filteredPlaces.length === 0 && places.length === 0 ? (
          <div className="no-places">
            <div className="no-places-icon">🏛️</div>
            <h4>No places loaded</h4>
            <p>Please check your connection and try again</p>
            <button onClick={() => window.location.reload()} className="retry-btn">
              Retry
            </button>
          </div>
        ) : (
          filteredPlaces.map((place) => {
            const isSelected = selectedPlaces.some(p => p.id === place.id);
            const category = PLACE_CATEGORIES[place.category];

            return (
              <div
                key={place.id || place._id}
                className={place-card ${isSelected ? 'selected' : ''}}
                onClick={() => handlePlaceToggle(place)}
              >
                <div className="place-header">
                  <div className="place-title">
                    <div className="place-category" style={{ color: category?.color }}>
                      {category?.icon || '🏛️'}
                    </div>
                    <div className="place-info">
                      <h4>{place.name}</h4>
                      <p className="place-location">
                        <MapPin size={14} />
                        {place.city}, {place.state}
                      </p>
                    </div>
                  </div>

                  <div className={selection-indicator ${isSelected ? 'selected' : ''}}>
                    <CheckCircle2 size={20} />
                  </div>
                </div>

                <div className="place-meta">
                  <div className="meta-row">
                    {place.rating && (
                      <div className="meta-item">
                        <Star className="meta-icon" />
                        <span>{place.rating}</span>
                      </div>
                    )}

                    <div className="meta-item">
                      <Clock className="meta-icon" />
                      <span>{UTILS.formatDuration(place.averageVisitDuration)}</span>
                    </div>

                    <div className="meta-item">
                      <IndianRupee className="meta-icon" />
                      <span>
                        {place.entryFee?.indian === 0 ? 'Free' : ₹${place.entryFee?.indian || 0}}
                      </span>
                    </div>
                  </div>

                  <div className="accessibility-icons">
                    {place.kidFriendly && (
                      <div className="access-icon" title="Kid Friendly">
                        <Users size={14} />
                      </div>
                    )}
                    {place.wheelchairAccessible && (
                      <div className="access-icon" title="Wheelchair Accessible">
                        <Accessibility size={14} />
                      </div>
                    )}
                  </div>
                </div>

                <p className="place-description">
                  {place.description && place.description.length > 120
                    ? ${place.description.substring(0, 120)}...
                    : place.description || 'No description available'}
                </p>

                {place.tags && place.tags.length > 0 && (
                  <div className="place-tags">
                    {place.tags.slice(0, 3).map((tag, index) => (
                      <span key={index} className="tag">
                        {tag}
                      </span>
                    ))}
                    {place.tags.length > 3 && (
                      <span className="tag more">+{place.tags.length - 3}</span>
                    )}
                  </div>
                )}
              </div>
            );
          })
        )}
      </div>

      {selectedPlaces.length > 0 && (
        <div className="action-buttons">
          <div className="selection-info">
            <p>{selectedPlaces.length} places selected</p>
            <p className="estimated-time">
              Estimated time: {UTILS.formatDuration(
                selectedPlaces.reduce((sum, place) => sum + place.averageVisitDuration, 0)
              )}
            </p>
          </div>

          <button
            onClick={onOptimizeRoute}
            disabled={selectedPlaces.length < 2 || isLoading}
            className="optimize-btn"
          >
            <CarIcon size={18} />
            {isLoading ? 'Optimizing...' : 'Optimize Route'}
          </button>
        </div>
      )}
    </div>
  );
};

export default LocationSelector;
--
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import toast from 'react-hot-toast';
import { apiService } from '../services/api';
import ConnectionStatus from './ConnectionStatus';
import LocationSelector from './LocationSelector';
import ItineraryDisplay from './ItineraryDisplay';
import OptimizedGraphVisualization from './OptimizedGraphVisualization';
import { 
  Settings, 
  Zap, 
  Brain, 
  Clock, 
  MapPin, 
  Target,
  AlertCircle,
  CheckCircle,
  Loader
} from 'lucide-react';
import { STORAGE_KEYS, ROUTE_SETTINGS, PLACE_CATEGORIES } from '../utils/constants';

const TripPlannerPage = ({ isConnected, onRetry }) => {
  const [places, setPlaces] = useState([]);
  const [selectedPlaces, setSelectedPlaces] = useState([]);
  const [optimizedRoute, setOptimizedRoute] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [visitedPlaces, setVisitedPlaces] = useState(new Set());
  const [showSettings, setShowSettings] = useState(false);
  const [apiError, setApiError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  const [optimizationStatus, setOptimizationStatus] = useState(null);

  // Enhanced route settings with algorithm preferences
  const [routeSettings, setRouteSettings] = useState({
    startTime: ROUTE_SETTINGS.DEFAULT_START_TIME,
    totalTimeAvailable: ROUTE_SETTINGS.DEFAULT_DURATION,
    optimizationLevel: 'balanced', // 'fast', 'balanced', 'optimal'
    
    // Algorithm-specific preferences
    preferences: {
      optimizeFor: 'balanced', // 'time', 'distance', 'rating', 'cost', 'balanced'
      ratingWeight: 0.3,
      distanceWeight: 0.25,
      timeWeight: 0.2,
      costWeight: 0.15,
      accessibilityWeight: 0.1,
      prioritizeHighRated: false,
      minimizeTravel: false,
      maximizeDiversity: true,
      allowPartialRoute: true
    },

    // Enhanced constraints
    constraints: {
      startLocation: null,
      endLocation: null,
      maxDistancePerLeg: 150,
      maxTotalDistance: 500,
      budget: null,
      accessibility: {
        wheelchairAccess: false,
        kidFriendly: false,
        elderlyFriendly: false
      }
    }
  });

  // Load places on connection
  const loadAllPlaces = useCallback(async (showToast = true) => {
    setLoading(true);
    setError(null);
    setApiError(null);

    try {
      console.log('🔄 Loading places from API...');
      const response = await apiService.getAllPlaces();

      if (!response?.success || !response?.places) {
        throw new Error('Invalid API response structure');
      }

      const places = response.places;
      console.log(`✅ Loaded ${places.length} places from API`);

      // Validate and normalize places for algorithm compatibility
      const validPlaces = places.filter(place => {
        const hasValidLocation = place.location && 
          typeof place.location.latitude === 'number' && 
          typeof place.location.longitude === 'number' &&
          !isNaN(place.location.latitude) && 
          !isNaN(place.location.longitude);

        const hasRequiredData = place.name && place.id && place.averageVisitDuration;

        if (!hasValidLocation || !hasRequiredData) {
          console.warn(`⚠️ Skipping place ${place.name}: missing algorithm-required data`);
          return false;
        }

        return true;
      });

      console.log(`📊 ${validPlaces.length}/${places.length} places are algorithm-compatible`);

      setPlaces(validPlaces);
      setRetryCount(0);

      if (showToast) {
        toast.success(`Loaded ${validPlaces.length} algorithm-ready places!`);
      }

    } catch (error) {
      console.error('💥 Error loading places:', error);
      setError(error.message);
      setApiError(error);
      setRetryCount(prev => prev + 1);

      if (showToast) {
        toast.error(error.message);
      }
    } finally {
      setLoading(false);
    }
  }, []);

  // Enhanced localStorage handling
  useEffect(() => {
    try {
      const storedVisited = localStorage.getItem(STORAGE_KEYS.VISITED_PLACES);
      const storedSettings = localStorage.getItem(STORAGE_KEYS.ROUTE_SETTINGS);

      if (storedVisited) {
        const visitedArray = JSON.parse(storedVisited);
        if (Array.isArray(visitedArray)) {
          setVisitedPlaces(new Set(visitedArray));
        }
      }

      if (storedSettings) {
        const savedSettings = JSON.parse(storedSettings);
        setRouteSettings(prev => ({ ...prev, ...savedSettings }));
      }
    } catch (err) {
      console.error('Error loading from localStorage:', err);
      localStorage.removeItem(STORAGE_KEYS.VISITED_PLACES);
      localStorage.removeItem(STORAGE_KEYS.ROUTE_SETTINGS);
    }
  }, []);

  // Load places when connected
  useEffect(() => {
    if (isConnected) {
      loadAllPlaces();
    }
  }, [isConnected, loadAllPlaces]);

  // Place selection handler
  const handlePlaceSelect = useCallback((place, isSelected) => {
    setSelectedPlaces(prev => {
      let newSelection;
      if (isSelected) {
        newSelection = [...prev, place];
        console.log(`✅ Added ${place.name} to selection (${newSelection.length} total)`);
      } else {
        newSelection = prev.filter(p => p.id !== place.id);
        console.log(`❌ Removed ${place.name} from selection (${newSelection.length} total)`);
        if (newSelection.length < 2) {
          setOptimizedRoute(null);
          setOptimizationStatus(null);
        }
      }
      return newSelection;
    });
  }, []);

  // Clear selection
  const handleClearSelection = useCallback(() => {
    setSelectedPlaces([]);
    setOptimizedRoute(null);
    setOptimizationStatus(null);
    setVisitedPlaces(new Set());
    
    try {
      localStorage.removeItem(STORAGE_KEYS.VISITED_PLACES);
    } catch (err) {
      console.error('Error clearing localStorage:', err);
    }
    
    toast('Selection cleared', { icon: '🗑️' });
  }, []);

  // Place visited handler
  const handlePlaceVisited = useCallback((placeId, isVisited) => {
    setVisitedPlaces(prev => {
      const newSet = new Set(prev);
      if (isVisited) {
        newSet.add(placeId);
        toast.success('Place marked as visited!', { icon: '✅' });
      } else {
        newSet.delete(placeId);
        toast('Place unmarked', { icon: '↩️' });
      }

      try {
        localStorage.setItem(STORAGE_KEYS.VISITED_PLACES, JSON.stringify(Array.from(newSet)));
      } catch (err) {
        console.error('Error saving visited places:', err);
      }

      return newSet;
    });
  }, []);

  // MAIN ALGORITHM-BASED OPTIMIZATION METHOD
  const handleOptimizeRoute = useCallback(async () => {
    if (selectedPlaces.length < 2) {
      toast.error('Please select at least 2 places for algorithmic optimization.');
      return;
    }

    if (selectedPlaces.length > 20) {
      toast.error('Maximum 20 places allowed for optimization algorithms.');
      return;
    }

    setLoading(true);
    setError(null);
    setOptimizedRoute(null);
    setOptimizationStatus('initializing');

    console.log('🤖 STARTING PURE ALGORITHM-BASED OPTIMIZATION');
    console.log(`📍 Places to optimize: ${selectedPlaces.length}`);
    console.log(`⚙️ Algorithm level: ${routeSettings.optimizationLevel}`);
    console.log(`🎯 Optimization target: ${routeSettings.preferences.optimizeFor}`);

    try {
      // Prepare algorithm-specific payload
      const algorithmPayload = {
        places: selectedPlaces.map(place => ({
          id: place.id,
          name: place.name,
          category: place.category || 'attraction',
          description: place.description || '',
          location: {
            latitude: parseFloat(place.location.latitude),
            longitude: parseFloat(place.location.longitude)
          },
          averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
          rating: parseFloat(place.rating) || 3.5,
          city: place.city || 'Unknown',
          state: place.state || 'Unknown',
          entryFee: place.entryFee || { indian: 0, foreign: 0 },
          kidFriendly: place.kidFriendly !== false,
          wheelchairAccessible: place.wheelchairAccessible === true,
          openingHours: place.openingHours || null,
          priority: 0
        })),

        preferences: {
          optimizationLevel: routeSettings.optimizationLevel,
          ...routeSettings.preferences
        },

        constraints: {
          startTime: routeSettings.startTime,
          totalTimeAvailable: routeSettings.totalTimeAvailable,
          startDay: new Date().getDay(),
          ...routeSettings.constraints
        }
      };

      setOptimizationStatus('running');
      console.log('🚀 Calling backend optimization algorithm...');

      // Call the PURE algorithm-based optimization
      const result = await apiService.optimizeRouteWithAlgorithm(algorithmPayload);

      console.log('✅ Algorithm optimization completed:', result);

      if (!result.success || !result.route || result.route.length === 0) {
        throw new Error('Algorithm failed to generate a valid route');
      }

      // Set the algorithm result directly - NO frontend modifications
      setOptimizedRoute({
        route: result.route,
        itinerary: result.itinerary,
        totalTime: result.optimizationDetails?.totalTime || 0,
        totalDistance: result.optimizationDetails?.totalDistance || 0,
        totalTravelTime: result.optimizationDetails?.totalTravelTime || 0,
        efficiency: result.optimizationDetails?.efficiency || 0,
        algorithm: result.algorithm,
        metrics: result.metrics,
        placesVisited: result.optimizationDetails?.placesVisited || 0,
        placesSkipped: result.optimizationDetails?.placesSkipped || 0
      });

      setOptimizationStatus('completed');

      // Show success message with algorithm details
      const algorithmName = result.algorithm || 'Unknown Algorithm';
      const placesOptimized = result.route.length;
      const efficiency = result.optimizationDetails?.efficiency || 0;

      toast.success(
        `🧠 ${algorithmName} optimized ${placesOptimized} places with ${efficiency}% efficiency!`,
        { duration: 4000 }
      );

      // Show warnings if any places were skipped
      if (result.optimizationDetails?.placesSkipped > 0) {
        toast(
          `⚠️ Algorithm skipped ${result.optimizationDetails.placesSkipped} places due to constraints`,
          { icon: '⚠️', duration: 3000 }
        );
      }

    } catch (error) {
      console.error('💥 Algorithm optimization failed:', error);
      setError(error.message);
      setOptimizationStatus('failed');

      // Enhanced error handling for algorithm-specific issues
      if (error.message.includes('timeout')) {
        toast.error('Algorithm timeout - try fewer places or "fast" mode', { duration: 5000 });
      } else if (error.message.includes('no feasible route')) {
        toast.error('No feasible route found - try relaxing constraints', { duration: 5000 });
      } else if (error.message.includes('invalid')) {
        toast.error('Invalid data - check place locations', { duration: 5000 });
      } else {
        toast.error(`Algorithm error: ${error.message}`, { duration: 5000 });
      }

      // Suggest fallback options
      setTimeout(() => {
        if (selectedPlaces.length > 10) {
          toast('💡 Try with fewer places (≤10) for better algorithm performance', { 
            icon: '💡', 
            duration: 4000 
          });
        } else if (routeSettings.optimizationLevel === 'optimal') {
          toast('💡 Try "balanced" or "fast" optimization level', { 
            icon: '💡', 
            duration: 4000 
          });
        }
      }, 1000);
    } finally {
      setLoading(false);
    }
  }, [selectedPlaces, routeSettings]);

  // Route settings change handler
  const handleRouteSettingsChange = useCallback((newSettings) => {
    setRouteSettings(prev => {
      const updated = { ...prev, ...newSettings };
      
      try {
        localStorage.setItem(STORAGE_KEYS.ROUTE_SETTINGS, JSON.stringify(updated));
      } catch (err) {
        console.error('Error saving route settings:', err);
      }
      
      return updated;
    });
  }, []);

  // Enhanced retry functionality
  const handleRetry = useCallback(() => {
    setError(null);
    setApiError(null);
    setOptimizationStatus(null);
    loadAllPlaces(true);
  }, [loadAllPlaces]);

  // Auto-retry with exponential backoff
  useEffect(() => {
    if (apiError && retryCount < 3 && isConnected) {
      const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 10000);
      console.log(`Auto-retrying in ${retryDelay}ms (attempt ${retryCount + 1}/3)`);

      const timer = setTimeout(() => {
        console.log(`Auto-retry attempt ${retryCount + 1}`);
        loadAllPlaces(false);
      }, retryDelay);

      return () => clearTimeout(timer);
    }
  }, [apiError, retryCount, isConnected, loadAllPlaces]);

  // Connection check
  if (!isConnected) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-6">
        <div className="max-w-xl w-full">
          <ConnectionStatus isConnected={isConnected} onRetry={onRetry} />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto p-6 space-y-6">
        
        {/* Header with Algorithm Status */}
        <div className="bg-white rounded-lg shadow-sm border p-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h1 className="text-3xl font-bold text-gray-900 flex items-center gap-3">
                <Brain className="text-blue-600" size={32} />
                AI-Powered Trip Planner
              </h1>
              <p className="text-gray-600 mt-2">
                Advanced algorithms optimize your route for the best travel experience
              </p>
            </div>

            <button
              onClick={() => setShowSettings(!showSettings)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
            >
              <Settings size={20} />
              Algorithm Settings
            </button>
          </div>

          {/* Algorithm Status Indicator */}
          {optimizationStatus && (
            <div className="mb-4 p-3 rounded-lg bg-blue-50 border border-blue-200">
              <div className="flex items-center gap-3">
                {optimizationStatus === 'running' && <Loader className="animate-spin text-blue-600" size={20} />}
                {optimizationStatus === 'completed' && <CheckCircle className="text-green-600" size={20} />}
                {optimizationStatus === 'failed' && <AlertCircle className="text-red-600" size={20} />}
                
                <span className="font-medium">
                  {optimizationStatus === 'initializing' && 'Preparing algorithm...'}
                  {optimizationStatus === 'running' && 'Algorithm optimizing route...'}
                  {optimizationStatus === 'completed' && `Algorithm completed successfully!`}
                  {optimizationStatus === 'failed' && 'Algorithm optimization failed'}
                </span>
              </div>
            </div>
          )}

          {/* Algorithm Settings Panel */}
          {showSettings && (
            <div className="mt-4 p-4 bg-gray-50 rounded-lg border">
              <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                <Target className="text-blue-600" size={20} />
                Algorithm Configuration
              </h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                
                {/* Optimization Level */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Optimization Level
                  </label>
                  <select
                    value={routeSettings.optimizationLevel}
                    onChange={(e) => handleRouteSettingsChange({ optimizationLevel: e.target.value })}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  >
                    <option value="fast">Fast (Greedy Algorithm)</option>
                    <option value="balanced">Balanced (Genetic/ACO)</option>
                    <option value="optimal">Optimal (Multi-Algorithm)</option>
                  </select>
                </div>

                {/* Optimization Target */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Optimize For
                  </label>
                  <select
                    value={routeSettings.preferences.optimizeFor}
                    onChange={(e) => handleRouteSettingsChange({ 
                      preferences: { ...routeSettings.preferences, optimizeFor: e.target.value }
                    })}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  >
                    <option value="balanced">Balanced Experience</option>
                    <option value="time">Minimize Travel Time</option>
                    <option value="distance">Minimize Distance</option>
                    <option value="rating">Maximize Ratings</option>
                    <option value="cost">Minimize Costs</option>
                  </select>
                </div>

                {/* Total Time Available */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2 flex items-center gap-1">
                    <Clock size={16} />
                    Time Available (hours)
                  </label>
                  <input
                    type="number"
                    min="2"
                    max="24"
                    value={Math.round(routeSettings.totalTimeAvailable / 60)}
                    onChange={(e) => handleRouteSettingsChange({ 
                      totalTimeAvailable: parseInt(e.target.value) * 60 
                    })}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  />
                </div>

                {/* Algorithm Preferences */}
                <div className="md:col-span-2 lg:col-span-3">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Algorithm Preferences
                  </label>
                  <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={routeSettings.preferences.prioritizeHighRated}
                        onChange={(e) => handleRouteSettingsChange({
                          preferences: { ...routeSettings.preferences, prioritizeHighRated: e.target.checked }
                        })}
                      />
                      <span className="text-sm">Prioritize High-Rated</span>
                    </label>
                    
                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={routeSettings.preferences.minimizeTravel}
                        onChange={(e) => handleRouteSettingsChange({
                          preferences: { ...routeSettings.preferences, minimizeTravel: e.target.checked }
                        })}
                      />
                      <span className="text-sm">Minimize Travel</span>
                    </label>
                    
                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={routeSettings.preferences.maximizeDiversity}
                        onChange={(e) => handleRouteSettingsChange({
                          preferences: { ...routeSettings.preferences, maximizeDiversity: e.target.checked }
                        })}
                      />
                      <span className="text-sm">Maximize Diversity</span>
                    </label>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Main Content Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          
          {/* Place Selection Panel */}
          <div className="lg:col-span-1">
            <div className="bg-white rounded-lg shadow-sm border">
              <LocationSelector 
                places={places}
                selectedPlaces={selectedPlaces}
                onPlaceSelect={handlePlaceSelect}
                onClearSelection={handleClearSelection}
                onOptimizeRoute={handleOptimizeRoute}
                isLoading={loading}
                error={error}
              />
            </div>
          </div>

          {/* Visualization and Itinerary */}
          <div className="lg:col-span-2 space-y-6">
            
            {/* Route Visualization */}
            <div className="bg-white rounded-lg shadow-sm border">
              <OptimizedGraphVisualization
                optimizedRoute={optimizedRoute}
                selectedPlaces={selectedPlaces}
                visitedPlaces={visitedPlaces}
                onPlaceVisited={handlePlaceVisited}
                isLoading={loading && selectedPlaces.length >= 2}
                onOptimizeRoute={handleOptimizeRoute}
                routeSettings={routeSettings}
                onRouteSettingsChange={handleRouteSettingsChange}
              />
            </div>

            {/* Itinerary Display */}
            {optimizedRoute && optimizedRoute.itinerary && (
              <div className="bg-white rounded-lg shadow-sm border">
                <ItineraryDisplay 
                  itinerary={optimizedRoute.itinerary}
                  optimizedRoute={optimizedRoute}
                  visitedPlaces={visitedPlaces}
                  onPlaceVisited={handlePlaceVisited}
                  routeSettings={routeSettings}
                />
              </div>
            )}
          </div>
        </div>

        {/* Algorithm Information Panel */}
        {optimizedRoute && (
          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200 p-6">
            <h3 className="text-lg font-semibold text-blue-900 mb-3 flex items-center gap-2">
              <Brain className="text-blue-600" size={20} />
              Algorithm Optimization Results
            </h3>
            
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-blue-800">Algorithm Used</div>
                <div className="text-blue-600">{optimizedRoute.algorithm || 'Advanced Optimization'}</div>
              </div>
              
              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-green-800">Efficiency</div>
                <div className="text-green-600">{optimizedRoute.efficiency || 0}%</div>
              </div>
              
              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-purple-800">Places Optimized</div>
                <div className="text-purple-600">{optimizedRoute.placesVisited || 0}</div>
              </div>
              
              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-orange-800">Total Distance</div>
                <div className="text-orange-600">{optimizedRoute.totalDistance?.toFixed(1) || 0} km</div>
              </div>
            </div>
            
            <div className="mt-3 text-sm text-blue-700">
              <strong>Note:</strong> This route was generated using advanced optimization algorithms that considered 
              travel time, distances, ratings, costs, and your preferences to create the most efficient path.
            </div>
          </div>
        )}

        {/* Error Display */}
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4">
            <div className="flex items-start gap-3">
              <AlertCircle className="text-red-500 flex-shrink-0 mt-0.5" size={20} />
              <div>
                <h4 className="font-medium text-red-800">Algorithm Optimization Error</h4>
                <p className="text-red-700 mt-1">{error}</p>
                <div className="mt-3 flex gap-2">
                  <button 
                    onClick={handleRetry}
                    className="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                  >
                    Try Again
                  </button>
                  {selectedPlaces.length > 10 && (
                    <button 
                      onClick={() => {
                        const reducedPlaces = selectedPlaces.slice(0, 8);
                        setSelectedPlaces(reducedPlaces);
                        toast('Reduced to 8 places for better algorithm performance', { icon: '💡' });
                      }}
                      className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
                    >
                      Reduce Places
                    </button>
                  )}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default TripPlannerPage;
--
// frontend/src/services/api.js

class APIService {
  constructor() {
    this.baseURL = 'http://localhost:5000';
    this.timeout = 30000; // 30 seconds timeout
  }

  async makeRequest(endpoint, options = {}) {
    const url = ${this.baseURL}${endpoint};

    const defaultOptions = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      timeout: this.timeout,
    };

    const config = { ...defaultOptions, ...options };

    try {
      console.log(🌐 API Request: ${config.method} ${url});
      if (config.body) {
        console.log('📤 Request Body:', JSON.parse(config.body));
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);

      const response = await fetch(url, {
        ...config,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      console.log(📥 API Response: ${response.status} ${response.statusText});

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(HTTP ${response.status}: ${errorText});
      }

      const data = await response.json();
      console.log('📊 Response Data:', data);

      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new Error('Request timeout - please try again');
      }
      console.error(❌ API Error for ${url}:, error);
      throw error;
    }
  }

  async healthCheck() {
    try {
      return await this.makeRequest('/api/health');
    } catch (error) {
      console.error('Health check failed:', error);
      return { status: 'ERROR', message: error.message };
    }
  }

  async getAllPlaces() {
    try {
      return await this.makeRequest('/api/places');
    } catch (error) {
      console.error('Failed to fetch places:', error);
      throw error;
    }
  }

  async optimizeRoute(optimizationData) {
    try {
      console.log('🚀 Starting route optimization...');
      console.log('📋 Optimization data:', optimizationData);

      // Validate input data
      if (!optimizationData.places || !Array.isArray(optimizationData.places)) {
        throw new Error('Invalid places data provided');
      }

      if (optimizationData.places.length < 2) {
        throw new Error('At least 2 places are required for optimization');
      }

      // Ensure all places have required fields
      const invalidPlaces = optimizationData.places.filter(place => 
        !place.id || 
        !place.name || 
        !place.location ||
        typeof place.location.latitude !== 'number' ||
        typeof place.location.longitude !== 'number' ||
        !place.averageVisitDuration
      );

      if (invalidPlaces.length > 0) {
        console.error('Invalid places found:', invalidPlaces);
        throw new Error(${invalidPlaces.length} places have missing required data);
      }

      // Clean and prepare data for backend
      const cleanedData = {
        places: optimizationData.places.map(place => ({
          id: place.id,
          name: place.name,
          category: place.category || 'attraction',
          description: place.description || '',
          location: {
            latitude: parseFloat(place.location.latitude),
            longitude: parseFloat(place.location.longitude)
          },
          averageVisitDuration: parseInt(place.averageVisitDuration) || 60,
          rating: parseFloat(place.rating) || 3.0,
          city: place.city || 'Unknown',
          state: place.state || 'Unknown',
          entryFee: place.entryFee || { indian: 0 },
          kidFriendly: place.kidFriendly !== false,
          wheelchairAccessible: place.wheelchairAccessible === true
        })),
        constraints: {
          startTime: optimizationData.constraints?.startTime || '09:00',
          totalTimeAvailable: parseInt(optimizationData.constraints?.totalTimeAvailable) || 480,
          optimizationLevel: optimizationData.constraints?.optimizationLevel || 'balanced',
          maxDistancePerLeg: optimizationData.constraints?.maxDistancePerLeg || 100,
          budget: optimizationData.constraints?.budget || null,
          startLocation: optimizationData.constraints?.startLocation || null,
          timeConstraints: {
            maxDuration: parseInt(optimizationData.constraints?.totalTimeAvailable) || 480,
            startDay: new Date().getDay()
          }
        },
        preferences: {
          optimizeFor: optimizationData.preferences?.optimizeFor || 'balanced',
          allowPartialRoute: optimizationData.preferences?.allowPartialRoute !== false,
          prioritizeRating: optimizationData.preferences?.prioritizeRating === true,
          algorithm: this.selectOptimizationAlgorithm(optimizationData.places.length, optimizationData.constraints?.optimizationLevel)
        }
      };

      console.log('🧹 Cleaned optimization data:', cleanedData);

      const result = await this.makeRequest('/api/optimize-route', {
        method: 'POST',
        body: JSON.stringify(cleanedData),
      });

      console.log('✅ Optimization result:', result);

      // Validate the response
      if (!result) {
        throw new Error('Empty response from optimization service');
      }

      if (!result.success) {
        throw new Error(result.message || 'Optimization failed');
      }

      if (!result.data || !result.data.route || !Array.isArray(result.data.route)) {
        throw new Error('Invalid route data in response');
      }

      return result;

    } catch (error) {
      console.error('❌ Route optimization failed:', error);

      // Provide specific error messages based on error type
      if (error.message.includes('timeout')) {
        throw new Error('Optimization is taking too long. Try with fewer places or a simpler route.');
      } else if (error.message.includes('HTTP 500')) {
        throw new Error('Server error during optimization. Please try again in a moment.');
      } else if (error.message.includes('HTTP 404')) {
        throw new Error('Optimization service is not available. Please contact support.');
      } else if (error.message.includes('no feasible route')) {
        throw new Error('No feasible route found. Try increasing time limit or selecting places closer together.');
      }

      throw error;
    }
  }

  // Select the best optimization algorithm based on problem size and requirements
  selectOptimizationAlgorithm(placeCount, optimizationLevel) {
    if (placeCount <= 3) {
      return 'greedy'; // Simple greedy for small problems
    } else if (placeCount <= 8 && optimizationLevel === 'quality') {
      return 'genetic'; // Genetic algorithm for better quality
    } else if (placeCount <= 12 && optimizationLevel === 'optimal') {
      return 'dynamic-programming'; // DP for optimal solutions
    } else if (placeCount <= 20) {
      return 'ant-colony'; // ACO for larger problems
    } else {
      return 'greedy'; // Fallback to greedy for very large problems
    }
  }

  async getPlaceDetails(placeId) {
    try {
      return await this.makeRequest(/api/places/${placeId});
    } catch (error) {
      console.error('Failed to fetch place details:', error);
      throw error;
    }
  }

  async searchPlaces(query, filters = {}) {
    try {
      const params = new URLSearchParams();
      if (query) params.append('q', query);

      Object.keys(filters).forEach(key => {
        if (filters[key]) {
          params.append(key, filters[key]);
        }
      });

      const endpoint = /api/places/search${params.toString() ? ?${params.toString()} : ''};
      return await this.makeRequest(endpoint);
    } catch (error) {
      console.error('Failed to search places:', error);
      throw error;
    }
  }

  async getRouteBetweenPlaces(startPlace, endPlace) {
    try {
      const body = {
        start: {
          latitude: startPlace.location.latitude,
          longitude: startPlace.location.longitude,
          name: startPlace.name
        },
        end: {
          latitude: endPlace.location.latitude,
          longitude: endPlace.location.longitude,
          name: endPlace.name
        }
      };

      return await this.makeRequest('/api/directions', {
        method: 'POST',
        body: JSON.stringify(body),
      });
    } catch (error) {
      console.error('Failed to get route between places:', error);
      throw error;
    }
  }

  async validateRoute(route) {
    try {
      const body = {
        route: route.map(place => ({
          id: place.id,
          name: place.name,
          location: place.location,
          averageVisitDuration: place.averageVisitDuration
        }))
      };

      return await this.makeRequest('/api/validate-route', {
        method: 'POST',
        body: JSON.stringify(body),
      });
    } catch (error) {
      console.error('Failed to validate route:', error);
      throw error;
    }
  }

  // Utility method for retrying failed requests
  async retryRequest(requestFn, maxRetries = 3, delay = 1000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await requestFn();
      } catch (error) {
        console.error(Attempt ${attempt}/${maxRetries} failed:, error.message);

        if (attempt === maxRetries) {
          throw error;
        }

        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt - 1)));
      }
    }
  }

  // Test connectivity to backend
  async testConnection() {
    try {
      const start = Date.now();
      const result = await this.healthCheck();
      const duration = Date.now() - start;

      return {
        connected: result.status === 'OK',
        responseTime: duration,
        details: result
      };
    } catch (error) {
      return {
        connected: false,
        responseTime: null,
        error: error.message
      };
    }
  }

  // Get optimization statistics
  async getOptimizationStats() {
    try {
      return await this.makeRequest('/api/optimization/stats');
    } catch (error) {
      console.error('Failed to fetch optimization stats:', error);
      return null;
    }
  }

  // Clear optimization cache if needed
  async clearOptimizationCache() {
    try {
      return await this.makeRequest('/api/optimization/cache', {
        method: 'DELETE'
      });
    } catch (error) {
      console.error('Failed to clear optimization cache:', error);
      return null;
    }
  }
}

// Create and export singleton instance
export const apiService = new APIService();

// Export utility functions
export const apiUtils = {
  isNetworkError: (error) => {
    return error.message.includes('fetch') || 
           error.message.includes('network') || 
           error.message.includes('timeout');
  },

  isServerError: (error) => {
    return error.message.includes('HTTP 5') || 
           error.message.includes('server error');
  },

  getErrorType: (error) => {
    if (apiUtils.isNetworkError(error)) return 'network';
    if (apiUtils.isServerError(error)) return 'server';
    if (error.message.includes('timeout')) return 'timeout';
    if (error.message.includes('validation')) return 'validation';
    return 'unknown';
  },

  formatError: (error) => {
    const type = apiUtils.getErrorType(error);

    switch (type) {
      case 'network':
        return 'Unable to connect to the server. Please check your internet connection.';
      case 'server':
        return 'Server is experiencing issues. Please try again in a moment.';
      case 'timeout':
        return 'Request timed out. Please try again with fewer places or check your connection.';
      case 'validation':
        return 'Invalid data provided. Please check your selection and try again.';
      default:
        return error.message || 'An unexpected error occurred.';
    }
  }
};

export default apiService;
--
// frontend/src/services/routeOptimizer.js
import { ROUTE_SETTINGS, VALIDATION } from '../utils/constants';

class EnhancedRouteOptimizer {
  constructor() {
    this.distanceCache = new Map();
    this.travelTimeCache = new Map();
    this.debugMode = false;
  }

  // Enhanced Haversine distance calculation with caching
  calculateHaversineDistance(lat1, lon1, lat2, lon2) {
    const cacheKey = ${lat1},${lon1},${lat2},${lon2};

    if (this.distanceCache.has(cacheKey)) {
      return this.distanceCache.get(cacheKey);
    }

    try {
      const R = 6371; // Earth's radius in kilometers
      const dLat = this.toRad(lat2 - lat1);
      const dLon = this.toRad(lon2 - lon1);

      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *
                Math.sin(dLon/2) * Math.sin(dLon/2);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c;

      // Validate distance (should be reasonable)
      if (distance < 0 || distance > 20000) {
        throw new Error(Invalid distance calculated: ${distance}km);
      }

      this.distanceCache.set(cacheKey, distance);
      return distance;
    } catch (error) {
      console.error(Error calculating distance between (${lat1},${lon1}) and (${lat2},${lon2}):, error);
      return Infinity; // Return infinity to exclude this route
    }
  }

  toRad(deg) {
    if (typeof deg !== 'number' || !isFinite(deg)) {
      throw new Error(Invalid degree value: ${deg});
    }
    return deg * (Math.PI/180);
  }

  // Enhanced travel time estimation with multiple factors
  estimateTravelTime(distanceKm, options = {}) {
    try {
      const {
        trafficFactor = 1.3,
        timeOfDay = 12,
        roadType = 'city',
        weatherFactor = 1.0
      } = options;

      if (distanceKm === Infinity || distanceKm < 0) {
        return Infinity;
      }

      // Dynamic speed based on distance and road type
      let baseSpeed;
      if (distanceKm > 100) {
        baseSpeed = roadType === 'highway' ? 80 : 70; // Highway/Interstate
      } else if (distanceKm > 50) {
        baseSpeed = roadType === 'highway' ? 70 : 60; // Major roads
      } else if (distanceKm > 10) {
        baseSpeed = 45; // Suburban/arterial roads
      } else {
        baseSpeed = 25; // City streets/local roads
      }

      // Time-of-day traffic adjustment
      let timeTrafficFactor = 1.0;
      if ((timeOfDay >= 7 && timeOfDay <= 10) || (timeOfDay >= 17 && timeOfDay <= 19)) {
        timeTrafficFactor = 1.6; // Rush hour
      } else if (timeOfDay >= 11 && timeOfDay <= 16) {
        timeTrafficFactor = 1.2; // Moderate traffic
      }

      const adjustedSpeed = baseSpeed / (trafficFactor * timeTrafficFactor * weatherFactor);
      const travelTimeMinutes = (distanceKm / adjustedSpeed) * 60;

      // Add buffer time for parking, walking, etc.
      const bufferTime = Math.min(15, distanceKm * 2); // Max 15 minutes buffer

      return Math.ceil(travelTimeMinutes + bufferTime);
    } catch (error) {
      console.error(Error estimating travel time for ${distanceKm}km:, error);
      return Infinity;
    }
  }

  // Advanced Greedy Algorithm with Multiple Optimization Strategies
  optimizeRouteLocally(places, settings = {}) {
    try {
      const {
        startTime = ROUTE_SETTINGS.DEFAULT_START_TIME,
        totalTimeAvailable = ROUTE_SETTINGS.DEFAULT_DURATION,
        startDay = new Date().getDay(),
        strategy = 'hybrid', // 'nearest', 'time_priority', 'rating_priority', 'hybrid'
        allowPartialRoute = true,
        prioritizeOpenPlaces = true
      } = settings;

      // Validation
      const validation = this.validateRouteInput(places, settings);
      if (!validation.isValid) {
        throw new Error(Validation failed: ${validation.errors.join(', ')});
      }

      if (!places || places.length === 0) {
        return this.createEmptyRoute();
      }

      if (places.length === 1) {
        return this.createSinglePlaceItinerary(places[0], startTime, startDay);
      }

      // Pre-filter places based on opening hours and feasibility
      const feasiblePlaces = this.filterFeasiblePlaces(places, startTime, startDay, totalTimeAvailable);

      if (feasiblePlaces.length === 0) {
        return this.createEmptyRoute('No places are open or feasible within the given time constraints');
      }

      // Build comprehensive distance and time matrices
      const matrices = this.buildComprehensiveMatrices(feasiblePlaces, startTime);

      // Apply the selected optimization strategy
      let optimizedRoute;
      switch (strategy) {
        case 'nearest':
          optimizedRoute = this.greedyNearestNeighbor(feasiblePlaces, matrices, settings);
          break;
        case 'time_priority':
          optimizedRoute = this.greedyTimePriority(feasiblePlaces, matrices, settings);
          break;
        case 'rating_priority':
          optimizedRoute = this.greedyRatingPriority(feasiblePlaces, matrices, settings);
          break;
        default:
          optimizedRoute = this.greedyHybridApproach(feasiblePlaces, matrices, settings);
      }

      // Apply local optimization improvements
      optimizedRoute = this.applyLocalOptimizations(optimizedRoute, matrices, settings);

      return optimizedRoute;

    } catch (error) {
      console.error('Error in route optimization:', error);
      return this.createErrorRoute(error.message);
    }
  }

  // Filter places based on feasibility
  filterFeasiblePlaces(places, startTime, startDay, totalTimeAvailable) {
    const startTimeMinutes = this.timeToMinutes(startTime);
    const endTimeMinutes = startTimeMinutes + totalTimeAvailable;

    return places.filter(place => {
      try {
        // Check if place has valid location
        if (!place.location || 
            typeof place.location.latitude !== 'number' || 
            typeof place.location.longitude !== 'number' ||
            !isFinite(place.location.latitude) ||
            !isFinite(place.location.longitude)) {
          console.warn(Place ${place.name} has invalid location data);
          return false;
        }

        // Check if place has reasonable visit duration
        if (!place.averageVisitDuration || 
            place.averageVisitDuration <= 0 || 
            place.averageVisitDuration > totalTimeAvailable * 0.8) {
          console.warn(Place ${place.name} has invalid visit duration);
          return false;
        }

        // Check if place can be visited within the time window
        const earliestArrival = startTimeMinutes + 30; // Minimum 30 min travel time
        const latestArrival = endTimeMinutes - place.averageVisitDuration;

        if (earliestArrival >= latestArrival) {
          return false;
        }

        // Check opening hours for multiple time slots
        let canVisit = false;
        for (let timeSlot = earliestArrival; timeSlot <= latestArrival; timeSlot += 60) {
          if (this.isPlaceOpenAt(place, startDay, this.minutesToTime(timeSlot))) {
            canVisit = true;
            break;
          }
        }

        return canVisit;
      } catch (error) {
        console.error(Error filtering place ${place.name}:, error);
        return false;
      }
    });
  }

  // Build comprehensive matrices for distance and time
  buildComprehensiveMatrices(places, startTime) {
    const n = places.length;
    const distanceMatrix = Array(n).fill().map(() => Array(n).fill(Infinity));
    const timeMatrix = Array(n).fill().map(() => Array(n).fill(Infinity));
    const timeOfDay = this.timeToMinutes(startTime) / 60;

    try {
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i !== j) {
            const distance = this.calculateHaversineDistance(
              places[i].location.latitude,
              places[i].location.longitude,
              places[j].location.latitude,
              places[j].location.longitude
            );

            if (distance !== Infinity) {
              distanceMatrix[i][j] = distance;
              timeMatrix[i][j] = this.estimateTravelTime(distance, {
                timeOfDay: timeOfDay,
                trafficFactor: 1.3
              });
            }
          } else {
            distanceMatrix[i][j] = 0;
            timeMatrix[i][j] = 0;
          }
        }
      }

      return { distanceMatrix, timeMatrix };
    } catch (error) {
      console.error('Error building matrices:', error);
      throw new Error('Failed to build distance/time matrices');
    }
  }

  // Hybrid Greedy Approach (Most Powerful)
  greedyHybridApproach(places, matrices, settings) {
    const {
      startTime,
      totalTimeAvailable,
      startDay
    } = settings;

    const { distanceMatrix, timeMatrix } = matrices;
    const n = places.length;

    // Multi-criteria scoring system
    const calculatePlaceScore = (currentIdx, candidateIdx, currentTime, visitedSet) => {
      const place = places[candidateIdx];
      const travelTime = timeMatrix[currentIdx][candidateIdx];
      const arrivalTime = currentTime + travelTime;

      if (travelTime === Infinity) return -Infinity;
      if (visitedSet.has(candidateIdx)) return -Infinity;
      if (arrivalTime + place.averageVisitDuration > this.timeToMinutes(startTime) + totalTimeAvailable) {
        return -Infinity;
      }

      // Check opening hours
      if (!this.isPlaceOpenAt(place, startDay, this.minutesToTime(arrivalTime))) {
        return -Infinity;
      }

      // Multi-factor scoring
      const ratingScore = (place.rating || 3) / 5 * 100; // Normalize to 0-100
      const proximityScore = Math.max(0, 100 - travelTime); // Closer is better
      const timeEfficiencyScore = Math.max(0, 100 - (place.averageVisitDuration / 10)); // Shorter visits score higher
      const remainingTimeScore = Math.max(0, (totalTimeAvailable - (arrivalTime + place.averageVisitDuration - this.timeToMinutes(startTime))) / totalTimeAvailable * 100);

      // Weighted combination
      return (ratingScore * 0.3 + proximityScore * 0.25 + timeEfficiencyScore * 0.2 + remainingTimeScore * 0.25);
    };

    // Greedy selection with lookahead
    const visited = new Set();
    const route = [];
    let currentIdx = 0; // Start with first place
    let currentTime = this.timeToMinutes(startTime);

    // Add starting place
    visited.add(currentIdx);
    route.push(currentIdx);
    currentTime += places[currentIdx].averageVisitDuration;

    while (route.length < n && currentTime < this.timeToMinutes(startTime) + totalTimeAvailable) {
      let bestScore = -Infinity;
      let nextIdx = -1;

      // Evaluate all unvisited places
      for (let i = 0; i < n; i++) {
        if (!visited.has(i)) {
          const score = calculatePlaceScore(currentIdx, i, currentTime, visited);

          // Look ahead to see if we can visit more places after this one
          if (score > bestScore) {
            bestScore = score;
            nextIdx = i;
          }
        }
      }

      if (nextIdx === -1 || bestScore === -Infinity) break;

      // Add to route
      visited.add(nextIdx);
      route.push(nextIdx);
      currentTime += timeMatrix[currentIdx][nextIdx] + places[nextIdx].averageVisitDuration;
      currentIdx = nextIdx;
    }

    return this.buildRouteResult(route, places, matrices, startTime, settings);
  }

  // Greedy Nearest Neighbor with time constraints
  greedyNearestNeighbor(places, matrices, settings) {
    const { timeMatrix } = matrices;
    const { startTime, totalTimeAvailable, startDay } = settings;
    const n = places.length;

    const visited = new Array(n).fill(false);
    const route = [];
    let currentIdx = 0;
    let currentTime = this.timeToMinutes(startTime);

    visited[currentIdx] = true;
    route.push(currentIdx);
    currentTime += places[currentIdx].averageVisitDuration;

    while (route.length < n) {
      let nearestIdx = -1;
      let minTime = Infinity;

      for (let i = 0; i < n; i++) {
        if (!visited[i]) {
          const travelTime = timeMatrix[currentIdx][i];
          const arrivalTime = currentTime + travelTime;
          const place = places[i];

          if (travelTime < minTime && 
              arrivalTime + place.averageVisitDuration <= this.timeToMinutes(startTime) + totalTimeAvailable &&
              this.isPlaceOpenAt(place, startDay, this.minutesToTime(arrivalTime))) {
            minTime = travelTime;
            nearestIdx = i;
          }
        }
      }

      if (nearestIdx === -1) break;

      visited[nearestIdx] = true;
      route.push(nearestIdx);
      currentTime += timeMatrix[currentIdx][nearestIdx] + places[nearestIdx].averageVisitDuration;
      currentIdx = nearestIdx;
    }

    return this.buildRouteResult(route, places, matrices, startTime, settings);
  }

  // Build final route result with comprehensive information
  buildRouteResult(route, places, matrices, startTime, settings) {
    try {
      const { distanceMatrix, timeMatrix } = matrices;
      const itinerary = [];
      let currentTime = this.timeToMinutes(startTime);
      let totalTravelTime = 0;
      let totalDistance = 0;

      for (let i = 0; i < route.length; i++) {
        const placeIdx = route[i];
        const place = places[placeIdx];

        const arrivalTime = this.minutesToTime(currentTime);
        const departureTime = this.minutesToTime(currentTime + place.averageVisitDuration);

        let travelTimeToNext = 0;
        let travelDistanceToNext = 0;

        if (i < route.length - 1) {
          const nextIdx = route[i + 1];
          travelTimeToNext = timeMatrix[placeIdx][nextIdx];
          travelDistanceToNext = distanceMatrix[placeIdx][nextIdx];
          totalTravelTime += travelTimeToNext;
          totalDistance += travelDistanceToNext;
        }

        itinerary.push({
          place: { ...place },
          arrivalTime,
          departureTime,
          visitDuration: place.averageVisitDuration,
          travelTimeToNext: Math.round(travelTimeToNext),
          travelDistanceToNext: Math.round(travelDistanceToNext * 100) / 100,
          isOpen: this.isPlaceOpenAt(place, settings.startDay, arrivalTime),
          order: i + 1
        });

        currentTime += place.averageVisitDuration + travelTimeToNext;
      }

      const totalTime = totalTravelTime + route.reduce((sum, i) => sum + places[i].averageVisitDuration, 0);
      const efficiency = route.length / places.length;

      return {
        route: route.map(i => ({ ...places[i] })),
        totalTime: Math.round(totalTime),
        totalDistance: Math.round(totalDistance * 100) / 100,
        totalTravelTime: Math.round(totalTravelTime),
        itinerary,
        feasible: true,
        efficiency: Math.round(efficiency * 100),
        placesVisited: route.length,
        placesSkipped: places.length - route.length,
        estimatedCost: this.calculateRouteCost(route.map(i => places[i])),
        warnings: this.generateRouteWarnings(itinerary, settings)
      };
    } catch (error) {
      console.error('Error building route result:', error);
      throw new Error('Failed to build route result');
    }
  }

  // Apply local optimizations (2-opt, time window adjustments)
  applyLocalOptimizations(routeResult, matrices, settings) {
    try {
      // 2-opt improvement for better route ordering
      const { route } = routeResult;
      if (route.length <= 3) return routeResult; // Too small for optimization

      const { timeMatrix } = matrices;
      let improved = true;
      let currentRoute = [...route];

      while (improved) {
        improved = false;

        for (let i = 1; i < currentRoute.length - 1; i++) {
          for (let j = i + 1; j < currentRoute.length; j++) {
            // Try swapping segments
            const newRoute = [...currentRoute];
            const segment = newRoute.splice(i, j - i + 1).reverse();
            newRoute.splice(i, 0, ...segment);

            // Check if this improves the route
            if (this.calculateRouteTotalTime(newRoute, timeMatrix) < 
                this.calculateRouteTotalTime(currentRoute, timeMatrix)) {
              currentRoute = newRoute;
              improved = true;
              break;
            }
          }
          if (improved) break;
        }
      }

      // Rebuild with optimized route if different
      if (JSON.stringify(currentRoute) !== JSON.stringify(route)) {
        const routeIndices = currentRoute.map((place, idx) => 
          route.findIndex(r => r.id === place.id)
        );
        return this.buildRouteResult(routeIndices, route, matrices, settings.startTime, settings);
      }

      return routeResult;
    } catch (error) {
      console.error('Error in local optimization:', error);
      return routeResult; // Return original if optimization fails
    }
  }

  // Calculate total time for a route
  calculateRouteTotalTime(route, timeMatrix) {
    let totalTime = 0;
    for (let i = 0; i < route.length - 1; i++) {
      totalTime += timeMatrix[i][i + 1] + route[i].averageVisitDuration;
    }
    if (route.length > 0) {
      totalTime += route[route.length - 1].averageVisitDuration;
    }
    return totalTime;
  }

  // Enhanced place opening hours check
  isPlaceOpenAt(place, day, time) {
    try {
      if (!place.openingHours) return true; // Assume open if no schedule

      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const dayName = dayNames[day] || dayNames[new Date().getDay()];
      const schedule = place.openingHours[dayName];

      if (!schedule) return true; // No schedule for this day
      if (schedule.closed === true) return false;

      if (!schedule.open || !schedule.close) return true; // Malformed schedule, assume open

      const openTime = this.timeToMinutes(schedule.open);
      const closeTime = this.timeToMinutes(schedule.close);
      const currentTimeMin = this.timeToMinutes(time);

      // Handle overnight schedules (e.g., 22:00 - 02:00)
      if (closeTime < openTime) {
        return currentTimeMin >= openTime || currentTimeMin <= closeTime;
      }

      // Add buffer time for visit duration
      const bufferTime = 30; // 30 minutes buffer before closing
      return currentTimeMin >= openTime && currentTimeMin <= (closeTime - bufferTime);
    } catch (error) {
      console.error(Error checking opening hours for ${place.name}:, error);
      return true; // Default to open if error occurs
    }
  }

  // Generate route warnings
  generateRouteWarnings(itinerary, settings) {
    const warnings = [];

    try {
      itinerary.forEach((item, index) => {
        // Check for very long travel times
        if (item.travelTimeToNext > 120) {
          warnings.push(Long travel time (${Math.round(item.travelTimeToNext)}min) from ${item.place.name} to next destination);
        }

        // Check for places that might be closed
        if (!item.isOpen) {
          warnings.push(${item.place.name} might be closed at ${item.arrivalTime});
        }

        // Check for very short visit times
        if (item.visitDuration < 30) {
          warnings.push(Very short visit time (${item.visitDuration}min) at ${item.place.name});
        }

        // Check for late arrivals
        const arrivalHour = parseInt(item.arrivalTime.split(':')[0]);
        if (arrivalHour >= 18) {
          warnings.push(Late arrival (${item.arrivalTime}) at ${item.place.name} - consider starting earlier);
        }
      });
    } catch (error) {
      console.error('Error generating warnings:', error);
    }

    return warnings;
  }

  // Calculate route cost
  calculateRouteCost(route) {
    try {
      return route.reduce((total, place) => {
        const fee = place.entryFee?.indian || place.entryFee?.amount || 0;
        return total + (typeof fee === 'number' ? fee : 0);
      }, 0);
    } catch (error) {
      console.error('Error calculating route cost:', error);
      return 0;
    }
  }

  // Create single place itinerary with enhanced validation
  createSinglePlaceItinerary(place, startTime, startDay) {
    try {
      const isOpen = this.isPlaceOpenAt(place, startDay, startTime);
      const warnings = [];

      if (!isOpen) {
        warnings.push(${place.name} might be closed at ${startTime});
      }

      return {
        route: [{ ...place }],
        totalTime: place.averageVisitDuration || 60,
        totalDistance: 0,
        totalTravelTime: 0,
        itinerary: [{
          place: { ...place },
          arrivalTime: startTime,
          departureTime: this.minutesToTime(this.timeToMinutes(startTime) + (place.averageVisitDuration || 60)),
          visitDuration: place.averageVisitDuration || 60,
          travelTimeToNext: 0,
          travelDistanceToNext: 0,
          isOpen,
          order: 1
        }],
        feasible: true,
        efficiency: 100,
        placesVisited: 1,
        placesSkipped: 0,
        estimatedCost: this.calculateRouteCost([place]),
        warnings
      };
    } catch (error) {
      console.error('Error creating single place itinerary:', error);
      return this.createErrorRoute('Failed to create single place itinerary');
    }
  }

  // Create empty route
  createEmptyRoute(reason = 'No places provided') {
    return {
      route: [],
      totalTime: 0,
      totalDistance: 0,
      totalTravelTime: 0,
      itinerary: [],
      feasible: false,
      efficiency: 0,
      placesVisited: 0,
      placesSkipped: 0,
      estimatedCost: 0,
      warnings: [reason]
    };
  }

  // Create error route
  createErrorRoute(errorMessage) {
    return {
      route: [],
      totalTime: 0,
      totalDistance: 0,
      totalTravelTime: 0,
      itinerary: [],
      feasible: false,
      efficiency: 0,
      placesVisited: 0,
      placesSkipped: 0,
      estimatedCost: 0,
      warnings: [Error: ${errorMessage}],
      error: true
    };
  }

  // Enhanced validation
  validateRouteInput(places, settings) {
    const errors = [];

    try {
      // Validate places
      if (!places || !Array.isArray(places)) {
        errors.push('Places must be an array');
      } else if (places.length === 0) {
        errors.push('At least one place is required');
      } else if (places.length > (VALIDATION?.MAX_PLACES_FOR_ROUTE || 20)) {
        errors.push(Maximum ${VALIDATION?.MAX_PLACES_FOR_ROUTE || 20} places allowed);
      } else {
        // Validate individual places
        places.forEach((place, index) => {
          if (!place.location || 
              typeof place.location.latitude !== 'number' || 
              typeof place.location.longitude !== 'number') {
            errors.push(Place ${index + 1} has invalid location data);
          }

          if (!place.averageVisitDuration || 
              typeof place.averageVisitDuration !== 'number' ||
              place.averageVisitDuration <= 0) {
            errors.push(Place ${index + 1} (${place.name || 'Unknown'}) has invalid visit duration);
          }
        });
      }

      // Validate settings
      if (settings) {
        if (settings.totalTimeAvailable) {
          const minTime = VALIDATION?.MIN_TIME_AVAILABLE || 60;
          const maxTime = VALIDATION?.MAX_TIME_AVAILABLE || 1440;

          if (settings.totalTimeAvailable < minTime) {
            errors.push(Minimum ${minTime} minutes required);
          }
          if (settings.totalTimeAvailable > maxTime) {
            errors.push(Maximum ${maxTime} minutes allowed);
          }
        }

        if (settings.startTime && !this.isValidTimeFormat(settings.startTime)) {
          errors.push('Start time must be in HH:MM format');
        }

        if (settings.startDay !== undefined && 
            (settings.startDay < 0 || settings.startDay > 6)) {
          errors.push('Start day must be between 0 (Sunday) and 6 (Saturday)');
        }
      }
    } catch (error) {
      errors.push(Validation error: ${error.message});
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // Validate time format
  isValidTimeFormat(time) {
    const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
    return timeRegex.test(time);
  }

  // Time utility functions with error handling
  timeToMinutes(timeStr) {
    try {
      if (typeof timeStr !== 'string') {
        throw new Error(Invalid time format: ${timeStr});
      }

      const [hours, minutes] = timeStr.split(':').map(Number);

      if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        throw new Error(Invalid time values: ${timeStr});
      }

      return hours * 60 + minutes;
    } catch (error) {
      console.error(Error converting time to minutes: ${timeStr}, error);
      return 0; // Default to midnight
    }
  }

  minutesToTime(minutes) {
    try {
      if (typeof minutes !== 'number' || !isFinite(minutes)) {
        throw new Error(Invalid minutes value: ${minutes});
      }

      const hours = Math.floor(Math.abs(minutes) / 60) % 24;
      const mins = Math.abs(minutes) % 60;
      return ${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')};
    } catch (error) {
      console.error(Error converting minutes to time: ${minutes}, error);
      return '00:00';
    }
  }

  // Clear all caches
  clearCache() {
    this.distanceCache.clear();
    this.travelTimeCache.clear();
  }

  // Get comprehensive cache statistics
  getCacheStats() {
    return {
      distanceCache: {
        size: this.distanceCache.size,
        memory: JSON.stringify([...this.distanceCache.entries()]).length
      },
      travelTimeCache: {
        size: this.travelTimeCache.size,
        memory: JSON.stringify([...this.travelTimeCache.entries()]).length
      }
    };
  }

  // Enable/disable debug mode
  setDebugMode(enabled) {
    this.debugMode = enabled;
  }
}

// Export singleton instance
export const routeOptimizer = new EnhancedRouteOptimizer();

// Enhanced utility functions
export const routeUtils = {
  formatDuration: (minutes) => {
    if (!minutes || minutes < 0) return '0m';
    if (minutes < 60) return ${Math.round(minutes)}m;
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    return mins > 0 ? ${hours}h ${mins}m : ${hours}h;
  },

  formatDistance: (km) => {
    if (!km || km < 0) return '0m';
    if (km < 1) return ${Math.round(km * 1000)}m;
    return ${km.toFixed(1)}km;
  },

  calculateRouteEfficiency: (selectedPlaces, optimizedRoute) => {
    if (!selectedPlaces || !optimizedRoute || !optimizedRoute.route) return 0;
    return Math.round((optimizedRoute.route.length / selectedPlaces.length) * 100);
  },

  estimateRouteCost: (route) => {
    if (!route || !route.length) return 0;
    return route.reduce((total, place) => {
      const fee = place.entryFee?.indian || place.entryFee?.amount || 0;
      return total + (typeof fee === 'number' ? fee : 0);
    }, 0);
  },

  getRouteCategories: (route) => {
    if (!route || !route.length) return [];
    const categories = new Set(route.map(place => place.category).filter(Boolean));
    return Array.from(categories);
  },

  isRouteKidFriendly: (route) => {
    if (!route || !route.length) return false;
    return route.every(place => place.kidFriendly !== false);
  },

  isRouteWheelchairAccessible: (route) => {
    if (!route || !route.length) return false;
    return route.every(place => place.wheelchairAccessible === true);
  },

  calculateRouteRating: (route) => {
    if (!route || !route.length) return 0;
    const totalRating = route.reduce((sum, place) => sum + (place.rating || 0), 0);
    return Math.round((totalRating / route.length) * 10) / 10;
  },

  getRouteDifficulty: (routeResult) => {
    if (!routeResult || !routeResult.totalTime) return 'Unknown';

    const { totalTime, totalDistance, placesVisited } = routeResult;

    if (totalTime <= 240 && totalDistance <= 20 && placesVisited <= 4) {
      return 'Easy';
    } else if (totalTime <= 480 && totalDistance <= 50 && placesVisited <= 8) {
      return 'Moderate';
    } else {
      return 'Challenging';
    }
  },

  validateRouteForExecution: (routeResult) => {
    const issues = [];

    if (!routeResult || !routeResult.itinerary) {
      issues.push('Invalid route data');
      return { valid: false, issues };
    }

    routeResult.itinerary.forEach((item, index) => {
      // Check for unreasonable travel times
      if (item.travelTimeToNext > 180) {
        issues.push(Very long travel time (${Math.round(item.travelTimeToNext)}min) between stops ${index + 1} and ${index + 2});
      }

      // Check for places that are closed
      if (!item.isOpen) {
        issues.push(${item.place.name} appears to be closed at arrival time ${item.arrivalTime});
      }

      // Check for overlapping time slots
      const nextItem = routeResult.itinerary[index + 1];
      if (nextItem) {
        const currentEnd = routeOptimizer.timeToMinutes(item.departureTime);
        const nextStart = routeOptimizer.timeToMinutes(nextItem.arrivalTime);

        if (currentEnd > nextStart) {
          issues.push(Time overlap between ${item.place.name} and ${nextItem.place.name});
        }
      }
    });

    return {
      valid: issues.length === 0,
      issues
    };
  },

  optimizeForUserPreferences: (places, preferences = {}) => {
    const {
      maxTravelTime = 60,
      preferredCategories = [],
      avoidCategories = [],
      maxWalkingDistance = 2,
      budgetLimit = null,
      accessibilityRequired = false,
      kidFriendlyOnly = false
    } = preferences;

    let filteredPlaces = [...places];

    // Filter by categories
    if (preferredCategories.length > 0) {
      filteredPlaces = filteredPlaces.filter(place => 
        preferredCategories.includes(place.category)
      );
    }

    if (avoidCategories.length > 0) {
      filteredPlaces = filteredPlaces.filter(place => 
        !avoidCategories.includes(place.category)
      );
    }

    // Filter by accessibility
    if (accessibilityRequired) {
      filteredPlaces = filteredPlaces.filter(place => 
        place.wheelchairAccessible === true
      );
    }

    // Filter by kid-friendly requirement
    if (kidFriendlyOnly) {
      filteredPlaces = filteredPlaces.filter(place => 
        place.kidFriendly !== false
      );
    }

    // Filter by budget
    if (budgetLimit) {
      filteredPlaces = filteredPlaces.filter(place => {
        const fee = place.entryFee?.indian || place.entryFee?.amount || 0;
        return fee <= budgetLimit;
      });
    }

    // Sort by preference score
    filteredPlaces.sort((a, b) => {
      let scoreA = (a.rating || 0) * 20; // Base score from rating
      let scoreB = (b.rating || 0) * 20;

      // Bonus for preferred categories
      if (preferredCategories.includes(a.category)) scoreA += 10;
      if (preferredCategories.includes(b.category)) scoreB += 10;

      // Bonus for shorter visit duration (more places can be visited)
      scoreA += Math.max(0, (300 - (a.averageVisitDuration || 120)) / 10);
      scoreB += Math.max(0, (300 - (b.averageVisitDuration || 120)) / 10);

      return scoreB - scoreA;
    });

    return filteredPlaces;
  }
};

export default routeOptimizer;
--
import React, { useState, useEffect } from 'react';
import { Loader } from 'lucide-react';
import { apiService } from './services/api';
import Navigation from './components/Navigation';
import HomePage from './components/HomePage';
import DashboardPage from './components/DashboardPage';
import TripPlannerPage from './components/TripPlannerPage';
import ChatBot from './components/ChatBot';
import { Toaster } from 'react-hot-toast';

const App = () => {
  const [currentPage, setCurrentPage] = useState('home');
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionChecked, setConnectionChecked] = useState(false);

  const checkConnection = async () => {
    try {
      const healthCheckResponse = await apiService.healthCheck();
      if (healthCheckResponse?.status === 'OK' || healthCheckResponse?.success === true) {
        setIsConnected(true);
      } else {
        setIsConnected(false);
      }

    } catch (error) {
      console.error('Backend connection failed:', error);
      setIsConnected(false);
    } finally {
      setConnectionChecked(true);
    }
  };

  useEffect(() => {
    checkConnection();
    const interval = setInterval(checkConnection, 30000);
    return () => clearInterval(interval);
  }, []);

  const handleRetry = () => {
    setConnectionChecked(false);
    checkConnection();
  };

  const renderPage = () => {
    switch (currentPage) {
      case 'home':
        return <HomePage onPageChange={setCurrentPage} isConnected={isConnected} />;
      case 'dashboard':
        return <DashboardPage onPageChange={setCurrentPage} isConnected={isConnected} onRetry={handleRetry} />;
      case 'planner':
        return <TripPlannerPage isConnected={isConnected} onRetry={handleRetry} />;
      case 'chat':
        return <ChatBot onClose={() => setCurrentPage('home')} />;
      default:
        return <HomePage onPageChange={setCurrentPage} isConnected={isConnected} />;
    }
  };

  if (!connectionChecked) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <Loader className="animate-spin mx-auto mb-4" size={48} />
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Connecting to TourWithAI</h2>
          <p className="text-gray-600">Checking backend server connection...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <Toaster position="bottom-right" />
      <Navigation
        currentPage={currentPage}
        onPageChange={setCurrentPage}
        isMenuOpen={isMenuOpen}
        setIsMenuOpen={setIsMenuOpen}
      />
      {renderPage()}
    </div>
  );
};

export default App;
--
// backend/utils/seedDatabase.js
require('dotenv').config();
const connectDB = require('../config/database');
const Place = require('../models/Place');

// 20 Curated South Indian Tourist Places
const southIndianPlaces = [
  {
    id: 'meenakshi-temple-madurai',
    name: 'Meenakshi Amman Temple',
    description: 'A historic Hindu temple dedicated to Goddess Meenakshi, famous for its stunning Dravidian architecture with intricately carved towers and vibrant sculptures. One of the most important temples in Tamil Nadu.',
    location: {
      latitude: 9.9195,
      longitude: 78.1193
    },
    address: 'Madurai Main, Madurai, Tamil Nadu 625001',
    city: 'Madurai',
    state: 'Tamil Nadu',
    category: 'temple',
    openingHours: {
      monday: { open: '05:00', close: '22:00' },
      tuesday: { open: '05:00', close: '22:00' },
      wednesday: { open: '05:00', close: '22:00' },
      thursday: { open: '05:00', close: '22:00' },
      friday: { open: '05:00', close: '22:00' },
      saturday: { open: '05:00', close: '22:00' },
      sunday: { open: '05:00', close: '22:00' }
    },
    averageVisitDuration: 120,
    entryFee: {
      indian: 0,
      foreign: 50
    },
    amenities: ['Parking', 'Guided Tours', 'Photography', 'Shoe Storage', 'Temple Shop'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['hindu temple', 'architecture', 'cultural heritage', 'dravidian style', 'goddess meenakshi'],
    rating: 4.8,
    isActive: true
  },
  {
    id: 'mysore-palace-karnataka',
    name: 'Mysore Palace',
    description: 'The official residence of the Wadiyar dynasty and the kingdom of Mysore, known for its Indo-Saracenic architecture. The palace is illuminated on Sundays and during festivals, creating a magical spectacle.',
    location: {
      latitude: 12.3051,
      longitude: 76.6551
    },
    address: 'Sayyaji Rao Road, Mysuru, Karnataka 570001',
    city: 'Mysore',
    state: 'Karnataka',
    category: 'palace',
    openingHours: {
      monday: { open: '10:00', close: '17:30' },
      tuesday: { open: '10:00', close: '17:30' },
      wednesday: { open: '10:00', close: '17:30' },
      thursday: { open: '10:00', close: '17:30' },
      friday: { open: '10:00', close: '17:30' },
      saturday: { open: '10:00', close: '17:30' },
      sunday: { open: '10:00', close: '17:30' }
    },
    averageVisitDuration: 90,
    entryFee: {
      indian: 70,
      foreign: 200
    },
    amenities: ['Audio Guide', 'Museum', 'Gift Shop', 'Parking', 'Cafeteria'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['royal palace', 'indo-saracenic architecture', 'wadiyar dynasty', 'illumination'],
    rating: 4.6,
    isActive: true
  },
  {
    id: 'ooty-hill-station-tamilnadu',
    name: 'Ooty (Udhagamandalam)',
    description: 'The "Queen of Hill Stations" in the Nilgiri Mountains, famous for its tea gardens, botanical gardens, and toy train. A perfect hill retreat with pleasant climate year-round.',
    location: {
      latitude: 11.4064,
      longitude: 76.6932
    },
    address: 'Udhagamandalam, The Nilgiris, Tamil Nadu 643001',
    city: 'Ooty',
    state: 'Tamil Nadu',
    category: 'hill-station',
    openingHours: {
      monday: { open: '00:00', close: '23:59' },
      tuesday: { open: '00:00', close: '23:59' },
      wednesday: { open: '00:00', close: '23:59' },
      thursday: { open: '00:00', close: '23:59' },
      friday: { open: '00:00', close: '23:59' },
      saturday: { open: '00:00', close: '23:59' },
      sunday: { open: '00:00', close: '23:59' }
    },
    averageVisitDuration: 480, // Full day
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Hotels', 'Restaurants', 'Toy Train', 'Botanical Garden', 'Lake', 'Shopping'],
    bestTimeToVisit: ['morning', 'afternoon', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['hill station', 'tea gardens', 'nilgiri mountains', 'toy train', 'botanical garden'],
    rating: 4.4,
    isActive: true
  },
  {
    id: 'hampi-karnataka-heritage',
    name: 'Hampi',
    description: 'UNESCO World Heritage Site showcasing the ruins of Vijayanagara Empire. Ancient temples, royal complexes, and boulder landscapes create a unique historical experience.',
    location: {
      latitude: 15.3350,
      longitude: 76.4600
    },
    address: 'Hampi, Vijayanagara, Karnataka 583239',
    city: 'Hampi',
    state: 'Karnataka',
    category: 'heritage',
    openingHours: {
      monday: { open: '06:00', close: '18:00' },
      tuesday: { open: '06:00', close: '18:00' },
      wednesday: { open: '06:00', close: '18:00' },
      thursday: { open: '06:00', close: '18:00' },
      friday: { open: '06:00', close: '18:00' },
      saturday: { open: '06:00', close: '18:00' },
      sunday: { open: '06:00', close: '18:00' }
    },
    averageVisitDuration: 360, // 6 hours
    entryFee: {
      indian: 40,
      foreign: 600
    },
    amenities: ['Archaeological Museum', 'Guided Tours', 'Coracle Rides', 'Bicycle Rental', 'Local Guides'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['unesco world heritage', 'vijayanagara empire', 'ancient ruins', 'historical site'],
    rating: 4.7,
    isActive: true
  },
  {
    id: 'marina-beach-chennai',
    name: 'Marina Beach',
    description: 'World\'s second longest urban beach stretching 13km along the Bay of Bengal. Popular for evening walks, local food stalls, and cultural activities.',
    location: {
      latitude: 13.0487,
      longitude: 80.2785
    },
    address: 'Marina Beach, Chennai, Tamil Nadu 600006',
    city: 'Chennai',
    state: 'Tamil Nadu',
    category: 'beach',
    openingHours: {
      monday: { open: '05:00', close: '21:00' },
      tuesday: { open: '05:00', close: '21:00' },
      wednesday: { open: '05:00', close: '21:00' },
      thursday: { open: '05:00', close: '21:00' },
      friday: { open: '05:00', close: '21:00' },
      saturday: { open: '05:00', close: '21:00' },
      sunday: { open: '05:00', close: '21:00' }
    },
    averageVisitDuration: 150,
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Food Stalls', 'Horse Riding', 'Parking', 'Rest Areas', 'Police Station'],
    bestTimeToVisit: ['evening', 'morning'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['urban beach', 'bay of bengal', 'evening walks', 'street food'],
    rating: 4.2,
    isActive: true
  },
  {
    id: 'backwaters-alleppey-kerala',
    name: 'Backwaters of Alleppey',
    description: 'Serene network of canals, rivers, and lakes lined with coconut trees. Famous for houseboat cruises offering a unique glimpse into Kerala\'s rural life.',
    location: {
      latitude: 9.4981,
      longitude: 76.3388
    },
    address: 'Alappuzha, Kerala 688001',
    city: 'Alleppey',
    state: 'Kerala',
    category: 'nature',
    openingHours: {
      monday: { open: '06:00', close: '18:00' },
      tuesday: { open: '06:00', close: '18:00' },
      wednesday: { open: '06:00', close: '18:00' },
      thursday: { open: '06:00', close: '18:00' },
      friday: { open: '06:00', close: '18:00' },
      saturday: { open: '06:00', close: '18:00' },
      sunday: { open: '06:00', close: '18:00' }
    },
    averageVisitDuration: 480, // 8 hours (full day cruise)
    entryFee: {
      indian: 500,
      foreign: 1000
    },
    amenities: ['Houseboat Cruises', 'Traditional Meals', 'Fishing', 'Bird Watching', 'Village Tours'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['backwaters', 'houseboat cruise', 'kerala canals', 'rural life'],
    rating: 4.5,
    isActive: true
  },
  {
    id: 'munnar-tea-gardens-kerala',
    name: 'Munnar Tea Gardens',
    description: 'Picturesque hill station known for endless tea plantations, misty hills, and pleasant climate. Home to the endangered Nilgiri Tahr and exotic flora.',
    location: {
      latitude: 10.0889,
      longitude: 77.0595
    },
    address: 'Munnar, Idukki, Kerala 685612',
    city: 'Munnar',
    state: 'Kerala',
    category: 'hill-station',
    openingHours: {
      monday: { open: '24:00', close: '24:00' },
      tuesday: { open: '24:00', close: '24:00' },
      wednesday: { open: '24:00', close: '24:00' },
      thursday: { open: '24:00', close: '24:00' },
      friday: { open: '24:00', close: '24:00' },
      saturday: { open: '24:00', close: '24:00' },
      sunday: { open: '24:00', close: '24:00' }
    },
    averageVisitDuration: 360,
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Tea Museum', 'Trekking Trails', 'Wildlife Sanctuary', 'Resorts', 'Spice Gardens'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['tea plantations', 'hill station', 'western ghats', 'nilgiri tahr'],
    rating: 4.6,
    isActive: true
  },
  {
    id: 'charminar-hyderabad-telangana',
    name: 'Charminar',
    description: 'Iconic 16th-century mosque and monument in Hyderabad\'s old city. Symbol of Hyderabad with four grand arches and minarets, surrounded by bustling bazaars.',
    location: {
      latitude: 17.3616,
      longitude: 78.4747
    },
    address: 'Charminar Road, Char Kaman, Ghansi Bazaar, Hyderabad, Telangana 500002',
    city: 'Hyderabad',
    state: 'Telangana',
    category: 'heritage',
    openingHours: {
      monday: { open: '09:30', close: '17:30' },
      tuesday: { open: '09:30', close: '17:30' },
      wednesday: { open: '09:30', close: '17:30' },
      thursday: { open: '09:30', close: '17:30' },
      friday: { open: '14:00', close: '17:30' },
      saturday: { open: '09:30', close: '17:30' },
      sunday: { open: '09:30', close: '17:30' }
    },
    averageVisitDuration: 90,
    entryFee: {
      indian: 25,
      foreign: 300
    },
    amenities: ['Laad Bazaar', 'Photography', 'Local Shopping', 'Street Food', 'Guided Tours'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['qutb shahi architecture', 'hyderabad symbol', 'heritage monument', 'bazaars'],
    rating: 4.3,
    isActive: true
  },
  {
    id: 'golconda-fort-hyderabad',
    name: 'Golconda Fort',
    description: 'Magnificent medieval fortress known for its acoustic architecture and diamond trade history. Offers panoramic views of Hyderabad city.',
    location: {
      latitude: 17.3833,
      longitude: 78.4011
    },
    address: 'Ibrahim Bagh, Hyderabad, Telangana 500008',
    city: 'Hyderabad',
    state: 'Telangana',
    category: 'fort',
    openingHours: {
      monday: { open: '09:00', close: '17:30' },
      tuesday: { open: '09:00', close: '17:30' },
      wednesday: { open: '09:00', close: '17:30' },
      thursday: { open: '09:00', close: '17:30' },
      friday: { open: '09:00', close: '17:30' },
      saturday: { open: '09:00', close: '17:30' },
      sunday: { open: '09:00', close: '17:30' }
    },
    averageVisitDuration: 180,
    entryFee: {
      indian: 25,
      foreign: 300
    },
    amenities: ['Sound and Light Show', 'Archaeological Museum', 'Parking', 'Guided Tours', 'Photography'],
    bestTimeToVisit: ['morning', 'afternoon', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['medieval fort', 'qutb shahi dynasty', 'acoustic architecture', 'diamond trade'],
    rating: 4.4,
    isActive: true
  },
  {
    id: 'rameshwaram-temple-tamilnadu',
    name: 'Ramanathaswamy Temple',
    description: 'One of the twelve Jyotirlinga temples dedicated to Lord Shiva, located on Rameswaram island. Famous for its magnificent corridors and sacred significance.',
    location: {
      latitude: 9.2881,
      longitude: 79.3129
    },
    address: 'Rameswaram, Tamil Nadu 623526',
    city: 'Rameswaram',
    state: 'Tamil Nadu',
    category: 'temple',
    openingHours: {
      monday: { open: '05:00', close: '13:00' },
      tuesday: { open: '05:00', close: '13:00' },
      wednesday: { open: '05:00', close: '13:00' },
      thursday: { open: '05:00', close: '13:00' },
      friday: { open: '05:00', close: '13:00' },
      saturday: { open: '05:00', close: '13:00' },
      sunday: { open: '05:00', close: '13:00' }
    },
    averageVisitDuration: 120,
    entryFee: {
      indian: 0,
      foreign: 50
    },
    amenities: ['Sacred Tanks', 'Pilgrimage Facilities', 'Temple Shop', 'Parking', 'Shoe Storage'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['jyotirlinga', 'lord shiva', 'pilgrimage site', 'sacred corridors'],
    rating: 4.7,
    isActive: true
  },
  {
    id: 'mahabalipuram-shore-temple',
    name: 'Shore Temple, Mahabalipuram',
    description: 'UNESCO World Heritage site featuring ancient rock-cut temples and sculptures from the 7th century. Exemplifies Pallava architecture facing the Bay of Bengal.',
    location: {
      latitude: 12.6269,
      longitude: 80.1992
    },
    address: 'Mahabalipuram, Chengalpattu, Tamil Nadu 603104',
    city: 'Mahabalipuram',
    state: 'Tamil Nadu',
    category: 'heritage',
    openingHours: {
      monday: { open: '06:00', close: '18:00' },
      tuesday: { open: '06:00', close: '18:00' },
      wednesday: { open: '06:00', close: '18:00' },
      thursday: { open: '06:00', close: '18:00' },
      friday: { open: '06:00', close: '18:00' },
      saturday: { open: '06:00', close: '18:00' },
      sunday: { open: '06:00', close: '18:00' }
    },
    averageVisitDuration: 180,
    entryFee: {
      indian: 30,
      foreign: 500
    },
    amenities: ['Archaeological Museum', 'Beach Access', 'Photography', 'Guided Tours', 'Parking'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['unesco world heritage', 'pallava architecture', 'rock-cut temples', 'shore temple'],
    rating: 4.5,
    isActive: true
  },
  {
    id: 'coorg-coffee-plantations-karnataka',
    name: 'Coorg (Kodagu)',
    description: 'Scotland of India, famous for coffee plantations, mist-covered hills, and unique Coorgi culture. Perfect destination for nature lovers and adventure enthusiasts.',
    location: {
      latitude: 12.3375,
      longitude: 75.8069
    },
    address: 'Madikeri, Kodagu, Karnataka 571201',
    city: 'Coorg',
    state: 'Karnataka',
    category: 'hill-station',
    openingHours: {
      monday: { open: '06:00', close: '18:00' },
      tuesday: { open: '06:00', close: '18:00' },
      wednesday: { open: '06:00', close: '18:00' },
      thursday: { open: '06:00', close: '18:00' },
      friday: { open: '06:00', close: '18:00' },
      saturday: { open: '06:00', close: '18:00' },
      sunday: { open: '06:00', close: '18:00' }
    },
    averageVisitDuration: 480, // Full day
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Coffee Estate Tours', 'Trekking', 'Waterfalls', 'Wildlife Sanctuary', 'Homestays'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['coffee plantations', 'western ghats', 'coorgi culture', 'hill station'],
    rating: 4.5,
    isActive: true
  },
  {
    id: 'kanyakumari-southern-tip',
    name: 'Kanyakumari',
    description: 'Southernmost tip of mainland India where Arabian Sea, Indian Ocean, and Bay of Bengal meet. Famous for spectacular sunrise and sunset views.',
    location: {
      latitude: 8.0883,
      longitude: 77.5385
    },
    address: 'Kanyakumari, Tamil Nadu 629702',
    city: 'Kanyakumari',
    state: 'Tamil Nadu',
    category: 'beach',
    openingHours: {
      monday: { open: '04:00', close: '20:00' },
      tuesday: { open: '04:00', close: '20:00' },
      wednesday: { open: '04:00', close: '20:00' },
      thursday: { open: '04:00', close: '20:00' },
      friday: { open: '04:00', close: '20:00' },
      saturday: { open: '04:00', close: '20:00' },
      sunday: { open: '04:00', close: '20:00' }
    },
    averageVisitDuration: 240,
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Vivekananda Rock Memorial', 'Thiruvalluvar Statue', 'Ferry Services', 'Sunset Point', 'Beach'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['southernmost point', 'confluence of seas', 'sunrise sunset', 'vivekananda memorial'],
    rating: 4.3,
    isActive: true
  },
  {
    id: 'bandipur-wildlife-sanctuary',
    name: 'Bandipur National Park',
    description: 'Premier wildlife sanctuary in Karnataka, part of the Nilgiri Biosphere Reserve. Home to tigers, elephants, and diverse wildlife in deciduous forests.',
    location: {
      latitude: 11.7401,
      longitude: 76.5026
    },
    address: 'Bandipur, Chamarajanagar, Karnataka 571126',
    city: 'Bandipur',
    state: 'Karnataka',
    category: 'wildlife',
    openingHours: {
      monday: { open: '06:30', close: '09:00' },
      tuesday: { open: '06:30', close: '09:00' },
      wednesday: { open: '06:30', close: '09:00' },
      thursday: { open: '06:30', close: '09:00' },
      friday: { open: '06:30', close: '09:00' },
      saturday: { open: '06:30', close: '09:00' },
      sunday: { open: '06:30', close: '09:00' }
    },
    averageVisitDuration: 180,
    entryFee: {
      indian: 80,
      foreign: 300
    },
    amenities: ['Safari Rides', 'Wildlife Photography', 'Nature Walks', 'Forest Guest House', 'Interpretation Center'],
    bestTimeToVisit: ['morning'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['wildlife sanctuary', 'tiger reserve', 'nilgiri biosphere', 'safari'],
    rating: 4.4,
    isActive: true
  },
  {
    id: 'tirumala-tirupati-temple',
    name: 'Tirumala Venkateswara Temple',
    description: 'One of the richest and most visited temples in the world, dedicated to Lord Venkateswara. Located on the seven hills of Tirumala.',
    location: {
      latitude: 13.6288,
      longitude: 79.4192
    },
    address: 'Tirumala, Tirupati, Andhra Pradesh 517504',
    city: 'Tirupati',
    state: 'Andhra Pradesh',
    category: 'temple',
    openingHours: {
      monday: { open: '02:30', close: '02:00' },
      tuesday: { open: '02:30', close: '02:00' },
      wednesday: { open: '02:30', close: '02:00' },
      thursday: { open: '02:30', close: '02:00' },
      friday: { open: '02:30', close: '02:00' },
      saturday: { open: '02:30', close: '02:00' },
      sunday: { open: '02:30', close: '02:00' }
    },
    averageVisitDuration: 300, // 5 hours including waiting
    entryFee: {
      indian: 0,
      foreign: 300
    },
    amenities: ['TTD Services', 'Accommodation', 'Prasadam', 'Darshan Booking', 'Hair Donation'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['lord venkateswara', 'seven hills', 'richest temple', 'pilgrimage'],
    rating: 4.6,
    isActive: true
  },
  {
    id: 'wayanad-kerala-hills',
    name: 'Wayanad',
    description: 'Pristine hill station in Kerala known for spice plantations, wildlife sanctuaries, and ancient caves. Perfect blend of adventure and tranquility.',
    location: {
      latitude: 11.6854,
      longitude: 76.1320
    },
    address: 'Wayanad, Kerala 673121',
    city: 'Wayanad',
    state: 'Kerala',
    category: 'hill-station',
    openingHours: {
      monday: { open: '06:00', close: '18:00' },
      tuesday: { open: '06:00', close: '18:00' },
      wednesday: { open: '06:00', close: '18:00' },
      thursday: { open: '06:00', close: '18:00' },
      friday: { open: '06:00', close: '18:00' },
      saturday: { open: '06:00', close: '18:00' },
      sunday: { open: '06:00', close: '18:00' }
    },
    averageVisitDuration: 480, // Full day
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Spice Gardens', 'Wildlife Sanctuary', 'Trekking Trails', 'Waterfalls', 'Cave Exploration'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['spice plantations', 'western ghats', 'wildlife sanctuary', 'edakkal caves'],
    rating: 4.5,
    isActive: true
  },
  {
    id: 'pondicherry-french-quarter',
    name: 'French Quarter, Pondicherry',
    description: 'Former French colonial settlement with distinctive European architecture, tree-lined streets, and vibrant cafes. Unique blend of Indian and French cultures.',
    location: {
      latitude: 11.9416,
      longitude: 79.8083
    },
    address: 'French Quarter, Puducherry 605001',
    city: 'Pondicherry',
    state: 'Puducherry',
    category: 'heritage',
    openingHours: {
      monday: { open: '06:00', close: '22:00' },
      tuesday: { open: '06:00', close: '22:00' },
      wednesday: { open: '06:00', close: '22:00' },
      thursday: { open: '06:00', close: '22:00' },
      friday: { open: '06:00', close: '22:00' },
      saturday: { open: '06:00', close: '22:00' },
      sunday: { open: '06:00', close: '22:00' }
    },
    averageVisitDuration: 240,
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['French Cafes', 'Heritage Walks', 'Aurobindo Ashram', 'Beach Promenade', 'Museums'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['french colonial', 'heritage architecture', 'cultural fusion', 'aurobindo ashram'],
    rating: 4.2,
    isActive: true
  },
  {
    id: 'brihadeshwara-temple-thanjavur',
    name: 'Brihadeeshwarar Temple',
    description: 'UNESCO World Heritage Site and architectural masterpiece of Chola dynasty. One of the largest temples in India with a towering vimana.',
    location: {
      latitude: 10.7829,
      longitude: 79.1378
    },
    address: 'Thanjavur, Tamil Nadu 613007',
    city: 'Thanjavur',
    state: 'Tamil Nadu',
    category: 'temple',
    openingHours: {
      monday: { open: '06:00', close: '12:30' },
      tuesday: { open: '06:00', close: '12:30' },
      wednesday: { open: '06:00', close: '12:30' },
      thursday: { open: '06:00', close: '12:30' },
      friday: { open: '06:00', close: '12:30' },
      saturday: { open: '06:00', close: '12:30' },
      sunday: { open: '06:00', close: '12:30' }
    },
    averageVisitDuration: 120,
    entryFee: {
      indian: 30,
      foreign: 500
    },
    amenities: ['Archaeological Survey', 'Museum', 'Photography', 'Guided Tours', 'Cultural Programs'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['unesco world heritage', 'chola architecture', 'big temple', 'lord shiva'],
    rating: 4.7,
    isActive: true
  },
  {
    id: 'belur-halebidu-temples',
    name: 'Belur and Halebidu Temples',
    description: 'Exquisite Hoysala architecture temples from 12th century. Intricate stone carvings depicting Hindu mythology and celestial dancers.',
    location: {
      latitude: 13.1622,
      longitude: 75.8651
    },
    address: 'Belur, Hassan, Karnataka 573115',
    city: 'Belur',
    state: 'Karnataka',
    category: 'temple',
    openingHours: {
      monday: { open: '06:00', close: '18:00' },
      tuesday: { open: '06:00', close: '18:00' },
      wednesday: { open: '06:00', close: '18:00' },
      thursday: { open: '06:00', close: '18:00' },
      friday: { open: '06:00', close: '18:00' },
      saturday: { open: '06:00', close: '18:00' },
      sunday: { open: '06:00', close: '18:00' }
    },
    averageVisitDuration: 240,
    entryFee: {
      indian: 25,
      foreign: 300
    },
    amenities: ['Archaeological Museum', 'Guided Tours', 'Photography', 'Parking', 'Local Handicrafts'],
    bestTimeToVisit: ['morning', 'afternoon'],
    kidFriendly: true,
    wheelchairAccessible: false,
    tags: ['hoysala architecture', 'stone carvings', 'chennakeshava temple', 'hoysaleswara temple'],
    rating: 4.6,
    isActive: true
  },
  {
    id: 'gokarna-karnataka-beaches',
    name: 'Gokarna Beaches',
    description: 'Sacred town with pristine beaches and ancient temples. Popular pilgrimage site offering both spiritual and beach experiences.',
    location: {
      latitude: 14.5426,
      longitude: 74.3188
    },
    address: 'Gokarna, Uttara Kannada, Karnataka 581326',
    city: 'Gokarna',
    state: 'Karnataka',
    category: 'beach',
    openingHours: {
      monday: { open: '05:00', close: '20:00' },
      tuesday: { open: '05:00', close: '20:00' },
      wednesday: { open: '05:00', close: '20:00' },
      thursday: { open: '05:00', close: '20:00' },
      friday: { open: '05:00', close: '20:00' },
      saturday: { open: '05:00', close: '20:00' },
      sunday: { open: '05:00', close: '20:00' }
    },
    averageVisitDuration: 300,
    entryFee: {
      indian: 0,
      foreign: 0
    },
    amenities: ['Beach Shacks', 'Water Sports', 'Temple Complex', 'Trekking', 'Backpacker Hostels'],
    bestTimeToVisit: ['morning', 'evening'],
    kidFriendly: true,
    wheelchairAccessible: true,
    tags: ['pristine beaches', 'pilgrimage site', 'mahabaleshwar temple', 'arabian sea'],
    rating: 4.4,
    isActive: true
  }
];

async function seedPlaces() {
  try {
    // Clear existing places
    console.log('🔄 Clearing existing places...');
    await Place.deleteMany({});

    // Insert new places
    console.log('📍 Inserting South Indian places...');
    const insertedPlaces = await Place.insertMany(southIndianPlaces);

    console.log(✅ Successfully inserted ${insertedPlaces.length} places:);

    // Display summary by state and category
    const summary = {};
    const categoryCount = {};

    insertedPlaces.forEach(place => {
      // Count by state
      if (!summary[place.state]) summary[place.state] = 0;
      summary[place.state]++;

      // Count by category
      if (!categoryCount[place.category]) categoryCount[place.category] = 0;
      categoryCount[place.category]++;

      console.log(  • ${place.name} (${place.city}, ${place.state}) - ${place.category});
    });

    console.log('\n📊 Summary by State:');
    Object.entries(summary).forEach(([state, count]) => {
      console.log(  ${state}: ${count} places);
    });

    console.log('\n📊 Summary by Category:');
    Object.entries(categoryCount).forEach(([category, count]) => {
      console.log(  ${category}: ${count} places);
    });

    // Create indexes for better performance
    console.log('\n🔍 Creating database indexes...');
    await Place.createIndexes();
    console.log('✅ Indexes created successfully');

    return insertedPlaces;

  } catch (error) {
    console.error('❌ Error seeding places:', error);
    throw error;
  }
}

async function validatePlaces() {
  try {
    console.log('\n🔍 Validating inserted places...');

    const places = await Place.find({});
    const validationResults = {
      total: places.length,
      errors: [],
      warnings: []
    };

    places.forEach(place => {
      // Validate required fields
      if (!place.location || !place.location.latitude || !place.location.longitude) {
        validationResults.errors.push(${place.name}: Missing or invalid location);
      }

      if (!place.averageVisitDuration || place.averageVisitDuration < 30) {
        validationResults.warnings.push(${place.name}: Very short visit duration (${place.averageVisitDuration}min));
      }

      if (!place.entryFee || (place.entryFee.indian === undefined || place.entryFee.foreign === undefined)) {
        validationResults.warnings.push(${place.name}: Missing entry fee information);
      }

      if (!place.rating || place.rating < 1 || place.rating > 5) {
        validationResults.errors.push(${place.name}: Invalid rating (${place.rating}));
      }

      // Validate coordinates are within South India bounds
      if (place.location && place.location.latitude && place.location.longitude) {
        const lat = place.location.latitude;
        const lng = place.location.longitude;

        if (lat < 8 || lat > 20 || lng < 68 || lng > 84) {
          validationResults.warnings.push(${place.name}: Coordinates may be outside South India bounds);
        }
      }
    });

    console.log(📊 Validation Results:);
    console.log(  Total places: ${validationResults.total});
    console.log(  Errors: ${validationResults.errors.length});
    console.log(  Warnings: ${validationResults.warnings.length});

    if (validationResults.errors.length > 0) {
      console.log('\n❌ Errors found:');
      validationResults.errors.forEach(error => console.log(  • ${error}));
    }

    if (validationResults.warnings.length > 0) {
      console.log('\n⚠️ Warnings:');
      validationResults.warnings.forEach(warning => console.log(  • ${warning}));
    }

    if (validationResults.errors.length === 0) {
      console.log('✅ All places validated successfully!');
    }

    return validationResults;

  } catch (error) {
    console.error('❌ Error validating places:', error);
    throw error;
  }
}

async function generateStatistics() {
  try {
    console.log('\n📈 Generating statistics...');

    const [
      totalPlaces,
      byState,
      byCategory,
      avgRating,
      freeEntryPlaces,
      avgVisitDuration,
      accessiblePlaces,
      kidFriendlyPlaces
    ] = await Promise.all([
      Place.countDocuments(),
      Place.aggregate([
        { $group: { _id: '$state', count: { $sum: 1 }, places: { $push: '$name' } } },
        { $sort: { count: -1 } }
      ]),
      Place.aggregate([
        { $group: { _id: '$category', count: { $sum: 1 }, avgRating: { $avg: '$rating' } } },
        { $sort: { count: -1 } }
      ]),
      Place.aggregate([
        { $group: { _id: null, avgRating: { $avg: '$rating' } } }
      ]),
      Place.countDocuments({ 'entryFee.indian': 0 }),
      Place.aggregate([
        { $group: { _id: null, avgDuration: { $avg: '$averageVisitDuration' } } }
      ]),
      Place.countDocuments({ wheelchairAccessible: true }),
      Place.countDocuments({ kidFriendly: true })
    ]);

    const stats = {
      overview: {
        totalPlaces,
        averageRating: Number(avgRating[0]?.avgRating?.toFixed(2)) || 0,
        freeEntryPlaces,
        averageVisitDuration: Math.round(avgVisitDuration[0]?.avgDuration || 0),
        accessiblePlaces,
        kidFriendlyPlaces
      },
      byState,
      byCategory
    };

    console.log(📊 Database Statistics:);
    console.log(  Total Places: ${stats.overview.totalPlaces});
    console.log(  Average Rating: ${stats.overview.averageRating}/5);
    console.log(  Free Entry Places: ${stats.overview.freeEntryPlaces});
    console.log(  Average Visit Duration: ${stats.overview.averageVisitDuration} minutes);
    console.log(  Wheelchair Accessible: ${stats.overview.accessiblePlaces});
    console.log(  Kid Friendly: ${stats.overview.kidFriendlyPlaces});

    console.log(\n📍 Distribution by State:);
    stats.byState.forEach(state => {
      console.log(  ${state._id}: ${state.count} places);
    });

    console.log(\n🏛️ Distribution by Category:);
    stats.byCategory.forEach(category => {
      console.log(  ${category._id}: ${category.count} places (avg rating: ${category.avgRating.toFixed(1)}));
    });

    return stats;

  } catch (error) {
    console.error('❌ Error generating statistics:', error);
    throw error;
  }
}

// Main seeding function
async function seedDatabase() {
  try {
    console.log('🚀 Starting South Indian Places Database Seeding...\n');

    await connectDB();
    const places = await seedPlaces();
    await validatePlaces();
    await generateStatistics();

    console.log('\n✅ Database seeding completed successfully!');
    console.log(📍 ${places.length} South Indian tourist places are now available in your database.);
    console.log('\n🎯 Next Steps:');
    console.log('  1. Start your backend server: npm run dev');
    console.log('  2. Test the places API: GET /api/places');
    console.log('  3. Try route optimization with your favorite places!');
    process.exit(0);
  } catch (error) {
    console.error('❌ Database seeding failed:', error);
    process.exit(1);
  } 
}

// Export functions for use in other modules
module.exports = {
  seedDatabase,
  seedPlaces,
  validatePlaces,
  generateStatistics,
  southIndianPlaces
};

// Run seeding if this file is executed directly
if (require.main === module) {
  seedDatabase();
}
--
// backend/utils/pathOptimizer.js
const axios = require('axios');

class PathOptimizer {
  constructor() {
    this.distanceCache = new Map();
    this.googleMapsApiKey = process.env.GOOGLE_MAPS_API_KEY;
    this.rateLimitDelay = 50; // Delay between API calls to avoid rate limits
    this.maxCacheSize = 10000;
  }

  // Enhanced Haversine distance calculation with better precision
  calculateHaversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in kilometers
    const dLat = this.toRad(lat2 - lat1);
    const dLon = this.toRad(lon2 - lon1);

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *
              Math.sin(dLon/2) * Math.sin(dLon/2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    const distance = R * c;

    return Math.max(distance, 0.1); // Minimum distance to avoid division by zero
  }

  toRad(deg) {
    return deg * (Math.PI/180);
  }

  // Enhanced Google Maps distance with better error handling and caching
  async getGoogleMapsDistance(origin, destination) {
    // Input validation
    if (!origin?.latitude || !origin?.longitude || !destination?.latitude || !destination?.longitude) {
      throw new Error('Invalid coordinates provided');
    }

    const cacheKey = ${origin.latitude.toFixed(6)},${origin.longitude.toFixed(6)}-${destination.latitude.toFixed(6)},${destination.longitude.toFixed(6)};

    if (this.distanceCache.has(cacheKey)) {
      return this.distanceCache.get(cacheKey);
    }

    // Clean cache if it gets too large
    if (this.distanceCache.size > this.maxCacheSize) {
      const keys = Array.from(this.distanceCache.keys());
      const keysToDelete = keys.slice(0, this.maxCacheSize / 2);
      keysToDelete.forEach(key => this.distanceCache.delete(key));
    }

    try {
      // Add delay to respect rate limits
      await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay));

      if (!this.googleMapsApiKey) {
        return this.getFallbackDistance(origin, destination);
      }

      const response = await axios.get('https://maps.googleapis.com/maps/api/distancematrix/json', {
        params: {
          origins: ${origin.latitude},${origin.longitude},
          destinations: ${destination.latitude},${destination.longitude},
          mode: 'driving',
          units: 'metric',
          avoid: 'tolls',
          departure_time: 'now',
          traffic_model: 'best_guess',
          key: this.googleMapsApiKey
        },
        timeout: 10000 // 10 second timeout
      });

      if (response.data?.rows?.[0]?.elements?.[0]?.status === 'OK') {
        const element = response.data.rows[0].elements[0];
        const result = {
          distance: Math.max(element.distance.value / 1000, 0.1), // Convert to km, minimum 0.1km
          duration: Math.max(element.duration.value / 60, 1), // Convert to minutes, minimum 1 minute
          durationInTraffic: element.duration_in_traffic ? element.duration_in_traffic.value / 60 : element.duration.value / 60,
          distanceText: element.distance.text,
          durationText: element.duration.text
        };

        this.distanceCache.set(cacheKey, result);
        return result;
      } else {
        return this.getFallbackDistance(origin, destination);
      }
    } catch (error) {
      console.warn(Google Maps API error for ${cacheKey}:, error.message);
      return this.getFallbackDistance(origin, destination);
    }
  }

  // Enhanced fallback distance calculation
  getFallbackDistance(origin, destination) {
    const distance = this.calculateHaversineDistance(
      origin.latitude, origin.longitude,
      destination.latitude, destination.longitude
    );

    // More realistic travel time estimation based on distance and terrain
    let duration;
    if (distance < 5) {
      duration = distance * 2.5; // City driving: ~24 km/h average
    } else if (distance < 20) {
      duration = distance * 2.0; // Suburban: ~30 km/h average
    } else if (distance < 100) {
      duration = distance * 1.5; // Highway: ~40 km/h average
    } else {
      duration = distance * 1.2; // Long distance: ~50 km/h average
    }

    // Add buffer time for stops, traffic, etc.
    duration *= 1.3;

    const result = {
      distance,
      duration: Math.max(duration, 1),
      durationInTraffic: duration * 1.2,
      distanceText: ${distance.toFixed(1)} km,
      durationText: ${Math.round(duration)} mins,
      isFallback: true
    };

    this.distanceCache.set(
      ${origin.latitude.toFixed(6)},${origin.longitude.toFixed(6)}-${destination.latitude.toFixed(6)},${destination.longitude.toFixed(6)},
      result
    );

    return result;
  }

  // Enhanced opening hours checker with better time parsing
  isPlaceOpen(place, dayOfWeek, timeString) {
    try {
      if (!place?.openingHours) return true; // Assume open if no schedule

      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const dayName = dayNames[dayOfWeek] || dayNames[new Date().getDay()];
      const schedule = place.openingHours[dayName];

      if (!schedule || schedule.closed === true) return false;
      if (schedule.allDay === true) return true;

      const currentTimeMinutes = this.timeToMinutes(timeString);

      // Handle multiple opening periods (e.g., lunch break)
      if (Array.isArray(schedule.periods)) {
        return schedule.periods.some(period => {
          const openTime = this.timeToMinutes(period.open);
          const closeTime = this.timeToMinutes(period.close);
          return this.isTimeInRange(currentTimeMinutes, openTime, closeTime);
        });
      }

      // Handle single period
      if (schedule.open && schedule.close) {
        const openTime = this.timeToMinutes(schedule.open);
        const closeTime = this.timeToMinutes(schedule.close);
        return this.isTimeInRange(currentTimeMinutes, openTime, closeTime);
      }

      return true; // Default to open if schedule format is unclear
    } catch (error) {
      console.warn('Error checking opening hours:', error);
      return true; // Default to open on error
    }
  }

  // Check if time is within range, handling overnight hours
  isTimeInRange(currentTime, openTime, closeTime) {
    if (closeTime > openTime) {
      // Same day (e.g., 09:00 - 17:00)
      return currentTime >= openTime && currentTime <= closeTime;
    } else {
      // Overnight (e.g., 22:00 - 02:00)
      return currentTime >= openTime || currentTime <= closeTime;
    }
  }

  // Enhanced time utilities with better validation
  timeToMinutes(timeStr) {
    try {
      if (!timeStr || typeof timeStr !== 'string') return 0;

      const parts = timeStr.trim().split(':');
      if (parts.length !== 2) return 0;

      const hours = parseInt(parts[0], 10);
      const minutes = parseInt(parts[1], 10);

      if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        return 0;
      }

      return hours * 60 + minutes;
    } catch (error) {
      console.warn('Error parsing time:', timeStr, error);
      return 0;
    }
  }

  minutesToTime(totalMinutes) {
    const minutes = Math.max(0, Math.round(totalMinutes));
    const hours = Math.floor(minutes / 60) % 24;
    const mins = minutes % 60;
    return ${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')};
  }

  // Build optimized adjacency matrix with parallel processing
  async buildAdjacencyMatrix(places) {
    if (!places || places.length === 0) {
      throw new Error('Places array is required and cannot be empty');
    }

    const n = places.length;
    const matrix = Array(n).fill().map(() => Array(n).fill(0));
    const distances = Array(n).fill().map(() => Array(n).fill(null));

    // Create batches to avoid overwhelming the API
    const batchSize = 5;
    const promises = [];

    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) {
          matrix[i][j] = 0;
          distances[i][j] = { distance: 0, duration: 0, durationInTraffic: 0 };
          continue;
        }

        // Add to batch with delay
        const promise = new Promise(async (resolve) => {
          await new Promise(r => setTimeout(r, Math.floor(Math.random() * 100))); // Random delay
          try {
            const travelInfo = await this.getGoogleMapsDistance(
              places[i].location,
              places[j].location
            );

            matrix[i][j] = travelInfo.durationInTraffic || travelInfo.duration;
            distances[i][j] = travelInfo;
            resolve();
          } catch (error) {
            console.warn(Error getting distance between ${places[i].name} and ${places[j].name}:, error);
            // Fallback to Haversine
            const fallback = this.getFallbackDistance(places[i].location, places[j].location);
            matrix[i][j] = fallback.duration;
            distances[i][j] = fallback;
            resolve();
          }
        });

        promises.push(promise);

        // Process in batches to avoid overwhelming the API
        if (promises.length >= batchSize) {
          await Promise.allSettled(promises.splice(0, batchSize));
          await new Promise(resolve => setTimeout(resolve, 200)); // Batch delay
        }
      }
    }

    // Process remaining promises
    if (promises.length > 0) {
      await Promise.allSettled(promises);
    }

    return { matrix, distances };
  }

  // POWERFUL GREEDY ALGORITHM - Enhanced with multiple optimization strategies
  async optimizeRoute(places, timeConstraints = {}) {
    try {
      const {
        startTime = '09:00',
        endTime = '18:00',
        totalTimeAvailable = 480,
        startDay = new Date().getDay(),
        priorityWeight = 0.3, // Weight for place priority/rating
        timeWeight = 0.4,     // Weight for travel time
        openingWeight = 0.3   // Weight for opening hours compatibility
      } = timeConstraints;

      // Input validation
      if (!places || !Array.isArray(places) || places.length === 0) {
        throw new Error('Valid places array is required');
      }

      // Single place handling
      if (places.length === 1) {
        return this.createSinglePlaceRoute(places[0], startTime, startDay);
      }

      console.log(Optimizing route for ${places.length} places);

      // Build adjacency matrix with enhanced distance calculations
      const { matrix, distances } = await this.buildAdjacencyMatrix(places);
      const n = places.length;

      // MULTI-START GREEDY APPROACH - Try starting from different places
      const startingCandidates = this.selectStartingCandidates(places, startTime, startDay);
      let bestRoute = null;
      let bestScore = -Infinity;

      for (const startIndex of startingCandidates) {
        const route = await this.greedyRouteFromStart(
          places, matrix, distances, startIndex, 
          { startTime, endTime, totalTimeAvailable, startDay, priorityWeight, timeWeight, openingWeight }
        );

        if (route && route.score > bestScore) {
          bestScore = route.score;
          bestRoute = route;
        }
      }

      // If no feasible route found, try with relaxed constraints
      if (!bestRoute || bestRoute.route.length === 0) {
        console.log('No feasible route found, trying with relaxed constraints');
        bestRoute = await this.greedyRouteFromStart(
          places, matrix, distances, 0,
          { 
            startTime, 
            endTime, 
            totalTimeAvailable: totalTimeAvailable * 1.5, // Increase time budget
            startDay, 
            priorityWeight, 
            timeWeight, 
            openingWeight,
            relaxed: true 
          }
        );
      }

      if (!bestRoute) {
        throw new Error('Unable to generate any route');
      }

      // Apply local optimization improvements
      const optimizedRoute = this.applyLocalOptimizations(bestRoute, matrix, distances, timeConstraints);

      return optimizedRoute;

    } catch (error) {
      console.error('Error in route optimization:', error);
      throw error;
    }
  }

  // Select best starting candidates based on opening hours and ratings
  selectStartingCandidates(places, startTime, startDay) {
    const candidates = places
      .map((place, index) => ({
        index,
        place,
        rating: place.rating || 0,
        isOpen: this.isPlaceOpen(place, startDay, startTime),
        priority: place.priority || 0,
        visitDuration: place.averageVisitDuration || 60
      }))
      .filter(candidate => candidate.isOpen) // Only consider open places
      .sort((a, b) => {
        // Sort by composite score: rating + priority - visit duration (prefer shorter visits for starting)
        const scoreA = a.rating + a.priority - (a.visitDuration / 60);
        const scoreB = b.rating + b.priority - (b.visitDuration / 60);
        return scoreB - scoreA;
      })
      .slice(0, Math.min(5, places.length)) // Try top 5 candidates
      .map(candidate => candidate.index);

    // If no open places, start with highest rated
    if (candidates.length === 0) {
      const fallback = places
        .map((place, index) => ({ index, rating: place.rating || 0 }))
        .sort((a, b) => b.rating - a.rating)
        .slice(0, 3)
        .map(item => item.index);

      return fallback.length > 0 ? fallback : [0];
    }

    return candidates;
  }

  // Enhanced greedy algorithm from a specific starting point
  async greedyRouteFromStart(places, matrix, distances, startIndex, constraints) {
    const {
      startTime,
      endTime,
      totalTimeAvailable,
      startDay,
      priorityWeight,
      timeWeight,
      openingWeight,
      relaxed = false
    } = constraints;

    const n = places.length;
    const visited = new Array(n).fill(false);
    const route = [];
    let currentIndex = startIndex;
    let currentTime = this.timeToMinutes(startTime);
    const endTimeMinutes = this.timeToMinutes(endTime);
    let totalTravelTime = 0;
    let totalDistance = 0;
    let totalScore = 0;

    // Add starting place
    visited[currentIndex] = true;
    route.push(currentIndex);
    const startPlace = places[currentIndex];

    // Check if starting place is actually open
    if (!this.isPlaceOpen(startPlace, startDay, startTime) && !relaxed) {
      // Find next available time
      const nextOpenTime = this.findNextOpenTime(startPlace, startDay, startTime);
      if (nextOpenTime && this.timeToMinutes(nextOpenTime) < endTimeMinutes) {
        currentTime = this.timeToMinutes(nextOpenTime);
      }
    }

    currentTime += startPlace.averageVisitDuration || 60;
    totalScore += (startPlace.rating || 0) + (startPlace.priority || 0);

    // Greedy selection with enhanced scoring
    while (route.length < n && currentTime < endTimeMinutes) {
      let nextIndex = -1;
      let bestScore = -Infinity;

      for (let i = 0; i < n; i++) {
        if (visited[i]) continue;

        const candidate = places[i];
        const travelTime = matrix[currentIndex][i];
        const arrivalTime = currentTime + travelTime;
        const departureTime = arrivalTime + (candidate.averageVisitDuration || 60);

        // Hard constraints (unless relaxed mode)
        if (!relaxed) {
          // Check time constraints
          if (departureTime > endTimeMinutes) continue;
          if ((arrivalTime - this.timeToMinutes(startTime)) > totalTimeAvailable) continue;

          // Check if place will be open
          if (!this.isPlaceOpen(candidate, startDay, this.minutesToTime(arrivalTime))) {
            // Try to find next opening time
            const nextOpen = this.findNextOpenTime(candidate, startDay, this.minutesToTime(arrivalTime));
            if (!nextOpen || this.timeToMinutes(nextOpen) > endTimeMinutes) continue;
          }
        } else {
          // Soft constraints in relaxed mode
          if (departureTime > endTimeMinutes * 1.2) continue; // Allow 20% overtime
        }

        // Calculate composite score
        const placeScore = (candidate.rating || 0) + (candidate.priority || 0);
        const timeScore = Math.max(0, 100 - travelTime); // Prefer shorter travel times
        const openingScore = this.isPlaceOpen(candidate, startDay, this.minutesToTime(arrivalTime)) ? 100 : 0;

        const compositeScore = 
          (placeScore * priorityWeight) + 
          (timeScore * timeWeight) + 
          (openingScore * openingWeight);

        // Bonus for popular places and penalty for very long visits
        const popularityBonus = Math.min((candidate.rating || 0) * 10, 50);
        const durationPenalty = Math.max(0, ((candidate.averageVisitDuration || 60) - 120) * 0.1);

        const finalScore = compositeScore + popularityBonus - durationPenalty;

        if (finalScore > bestScore) {
          bestScore = finalScore;
          nextIndex = i;
        }
      }

      if (nextIndex === -1) break; // No more feasible places

      // Add selected place to route
      visited[nextIndex] = true;
      route.push(nextIndex);

      const travelTime = matrix[currentIndex][nextIndex];
      const travelDistance = distances[currentIndex][nextIndex]?.distance || 0;

      totalTravelTime += travelTime;
      totalDistance += travelDistance;
      totalScore += (places[nextIndex].rating || 0) + (places[nextIndex].priority || 0);

      currentTime += travelTime + (places[nextIndex].averageVisitDuration || 60);
      currentIndex = nextIndex;

      // Early termination if we're running out of time
      if (currentTime > endTimeMinutes * 0.9) break; // Stop at 90% of end time
    }

    // Build detailed itinerary
    const itinerary = await this.buildDetailedItinerary(route, places, distances, startTime, startDay);
    const totalTime = totalTravelTime + route.reduce((sum, i) => sum + (places[i].averageVisitDuration || 60), 0);

    return {
      route: route.map(i => places[i]),
      routeIndices: route,
      totalTime,
      totalDistance,
      totalTravelTime,
      totalScore,
      score: totalScore - (totalTravelTime * 0.1), // Penalize excessive travel time
      itinerary,
      feasible: route.length > 0,
      efficiency: (route.length / places.length) * 100
    };
  }

  // Find next opening time for a place
  findNextOpenTime(place, startDay, currentTime) {
    try {
      if (!place?.openingHours) return currentTime;

      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

      // Check next few days
      for (let dayOffset = 0; dayOffset < 3; dayOffset++) {
        const checkDay = (startDay + dayOffset) % 7;
        const dayName = dayNames[checkDay];
        const schedule = place.openingHours[dayName];

        if (!schedule || schedule.closed) continue;
        if (schedule.allDay) return currentTime;

        const openTime = schedule.open;
        if (dayOffset === 0 && this.timeToMinutes(openTime) > this.timeToMinutes(currentTime)) {
          return openTime;
        } else if (dayOffset > 0) {
          return openTime; // Next day opening
        }
      }

      return null;
    } catch (error) {
      return currentTime;
    }
  }

  // Apply local optimizations (2-opt, insertion heuristics)
  applyLocalOptimizations(route, matrix, distances, constraints) {
    if (!route || route.routeIndices.length < 3) return route;

    // 2-opt improvement
    let improved = true;
    let currentRoute = [...route.routeIndices];

    while (improved) {
      improved = false;

      for (let i = 1; i < currentRoute.length - 2; i++) {
        for (let j = i + 1; j < currentRoute.length; j++) {
          if (j - i === 1) continue; // Skip adjacent pairs

          const currentDistance = 
            matrix[currentRoute[i - 1]][currentRoute[i]] +
            matrix[currentRoute[j]][currentRoute[j + 1] || currentRoute[0]];

          const newDistance = 
            matrix[currentRoute[i - 1]][currentRoute[j]] +
            matrix[currentRoute[i]][currentRoute[j + 1] || currentRoute[0]];

          if (newDistance < currentDistance) {
            // Reverse the sub-route
            const newRoute = [
              ...currentRoute.slice(0, i),
              ...currentRoute.slice(i, j + 1).reverse(),
              ...currentRoute.slice(j + 1)
            ];

            currentRoute = newRoute;
            improved = true;
            break;
          }
        }
        if (improved) break;
      }
    }

    // Rebuild route with optimized order
    if (JSON.stringify(currentRoute) !== JSON.stringify(route.routeIndices)) {
      console.log('Applied local optimization improvements');
      route.routeIndices = currentRoute;
      route.route = currentRoute.map(i => route.route[route.routeIndices.indexOf(i)]);
    }

    return route;
  }

  // Create single place route
  createSinglePlaceRoute(place, startTime, startDay) {
    const visitDuration = place.averageVisitDuration || 60;
    return {
      route: [place],
      routeIndices: [0],
      totalTime: visitDuration,
      totalDistance: 0,
      totalTravelTime: 0,
      itinerary: [{
        place,
        arrivalTime: startTime,
        departureTime: this.minutesToTime(this.timeToMinutes(startTime) + visitDuration),
        visitDuration,
        travelTimeToNext: 0,
        travelDistanceToNext: 0,
        isOpen: this.isPlaceOpen(place, startDay, startTime)
      }],
      feasible: true,
      efficiency: 100
    };
  }

  // Enhanced itinerary builder with opening hours validation
  async buildDetailedItinerary(routeIndices, places, distances, startTime, startDay) {
    const itinerary = [];
    let currentTime = this.timeToMinutes(startTime);

    for (let i = 0; i < routeIndices.length; i++) {
      const placeIndex = routeIndices[i];
      const place = places[placeIndex];

      // Check and adjust arrival time if place is closed
      const arrivalTimeStr = this.minutesToTime(currentTime);
      let adjustedArrivalTime = currentTime;

      if (!this.isPlaceOpen(place, startDay, arrivalTimeStr)) {
        const nextOpenTime = this.findNextOpenTime(place, startDay, arrivalTimeStr);
        if (nextOpenTime && this.timeToMinutes(nextOpenTime) > currentTime) {
          adjustedArrivalTime = this.timeToMinutes(nextOpenTime);
          currentTime = adjustedArrivalTime;
        }
      }

      const visitDuration = place.averageVisitDuration || 60;
      const departureTime = currentTime + visitDuration;

      let travelTimeToNext = 0;
      let travelDistanceToNext = 0;

      if (i < routeIndices.length - 1) {
        const nextPlaceIndex = routeIndices[i + 1];
        travelTimeToNext = distances[placeIndex]?.[nextPlaceIndex]?.duration || 0;
        travelDistanceToNext = distances[placeIndex]?.[nextPlaceIndex]?.distance || 0;
      }

      itinerary.push({
        place,
        arrivalTime: this.minutesToTime(currentTime),
        departureTime: this.minutesToTime(departureTime),
        visitDuration,
        travelTimeToNext: Math.round(travelTimeToNext),
        travelDistanceToNext: Math.round(travelDistanceToNext * 100) / 100,
        isOpen: this.isPlaceOpen(place, startDay, this.minutesToTime(currentTime)),
        waitingTime: adjustedArrivalTime - (currentTime - (i === 0 ? 0 : visitDuration))
      });

      currentTime = departureTime + travelTimeToNext;
    }

    return itinerary;
  }

  // Clear cache and reset
  clearCache() {
    this.distanceCache.clear();
  }

  // Get cache statistics
  getCacheStats() {
    return {
      size: this.distanceCache.size,
      memory: JSON.stringify([...this.distanceCache.entries()]).length
    };
  }
}

module.exports = PathOptimizer;
--
// backend/utils/optimizationAlgorithms.js
const DistanceCalculator = require('./distanceCalculator');

class OptimizationAlgorithms {
  constructor() {
    this.distanceCalculator = new DistanceCalculator();
    this.cache = new Map();
    this.maxCacheSize = 2000;
  }

  /**
   * Advanced Greedy Algorithm with Multiple Criteria
   * Selects best place at each step considering multiple factors
   */
  async advancedGreedyOptimization(places, constraints) {
    const {
      startLocation,
      timeConstraints = { maxDuration: 480 },
      budget = Infinity,
      strategy = 'balanced',
      weights = {
        rating: 0.3,
        distance: 0.25,
        time: 0.2,
        cost: 0.15,
        popularity: 0.1
      }
    } = constraints;

    if (places.length === 0) {
      return { route: [], totalTime: 0, totalDistance: 0, efficiency: 0 };
    }

    const selectedPlaces = [];
    const remainingPlaces = [...places];
    let totalTime = 0;
    let totalCost = 0;
    let totalDistance = 0;
    let currentLocation = startLocation;

    // Pre-calculate all pairwise distances for efficiency
    const distanceMatrix = await this.buildDistanceMatrix(places, startLocation);

    while (selectedPlaces.length < places.length && remainingPlaces.length > 0) {
      let bestPlace = null;
      let bestScore = -Infinity;
      let bestIndex = -1;

      for (let i = 0; i < remainingPlaces.length; i++) {
        const candidate = remainingPlaces[i];

        // Check hard constraints first
        const constraintCheck = await this.checkConstraints(
          candidate, 
          totalTime, 
          totalCost, 
          constraints
        );

        if (!constraintCheck.feasible) continue;

        // Calculate multi-criteria score
        const scores = await this.calculateMultiCriteriaScore(
          candidate,
          currentLocation,
          selectedPlaces,
          constraints,
          distanceMatrix,
          weights
        );

        if (scores.totalScore > bestScore) {
          bestScore = scores.totalScore;
          bestPlace = candidate;
          bestIndex = i;
        }
      }

      if (!bestPlace) break; // No feasible place found

      // Add best place to route
      selectedPlaces.push(bestPlace);
      remainingPlaces.splice(bestIndex, 1);

      // Update totals
      totalTime += bestPlace.averageVisitDuration;
      totalCost += bestPlace.entryFee?.indian || 0;

      if (currentLocation) {
        const travelDistance = await this.getTravelDistance(currentLocation, bestPlace.location);
        const travelTime = await this.getTravelTime(currentLocation, bestPlace.location);
        totalDistance += travelDistance;
        totalTime += travelTime;
      }

      currentLocation = bestPlace.location;
    }

    return {
      route: selectedPlaces,
      totalTime,
      totalDistance,
      totalCost,
      efficiency: this.calculateEfficiency(selectedPlaces, totalTime),
      algorithm: 'advanced-greedy',
      constraintsSatisfied: this.validateFinalRoute(selectedPlaces, constraints)
    };
  }

  /**
   * Genetic Algorithm for larger problem sets
   * Uses evolutionary approach to find optimal solutions
   */
  async geneticAlgorithmOptimization(places, constraints) {
    const {
      populationSize = 50,
      generations = 100,
      mutationRate = 0.1,
      crossoverRate = 0.8,
      eliteSize = 10
    } = constraints.geneticParams || {};

    if (places.length < 4) {
      // Fall back to greedy for small problems
      return this.advancedGreedyOptimization(places, constraints);
    }

    // Initialize population
    let population = await this.initializePopulation(places, populationSize, constraints);

    for (let generation = 0; generation < generations; generation++) {
      // Evaluate fitness for each individual
      const fitnessScores = await Promise.all(
        population.map(individual => this.evaluateFitness(individual, constraints))
      );

      // Selection: keep elite individuals
      const sortedIndividuals = population
        .map((individual, index) => ({ individual, fitness: fitnessScores[index] }))
        .sort((a, b) => b.fitness - a.fitness);

      const newPopulation = sortedIndividuals
        .slice(0, eliteSize)
        .map(item => [...item.individual]);

      // Crossover and mutation to fill rest of population
      while (newPopulation.length < populationSize) {
        const parent1 = this.tournamentSelection(sortedIndividuals);
        const parent2 = this.tournamentSelection(sortedIndividuals);

        let offspring = Math.random() < crossoverRate ?
          this.crossover(parent1, parent2) : [...parent1];

        if (Math.random() < mutationRate) {
          offspring = this.mutate(offspring);
        }

        newPopulation.push(offspring);
      }

      population = newPopulation;

      // Early termination if no improvement
      if (generation > 20 && generation % 10 === 0) {
        const currentBest = Math.max(...fitnessScores);
        const previousBest = this.previousBestFitness || 0;

        if (Math.abs(currentBest - previousBest) < 0.001) {
          break; // Converged
        }

        this.previousBestFitness = currentBest;
      }
    }

    // Return best solution
    const finalFitnessScores = await Promise.all(
      population.map(individual => this.evaluateFitness(individual, constraints))
    );

    const bestIndex = finalFitnessScores.indexOf(Math.max(...finalFitnessScores));
    const bestRoute = population[bestIndex];

    const metrics = await this.calculateRouteMetrics(bestRoute, constraints);

    return {
      route: bestRoute,
      ...metrics,
      algorithm: 'genetic',
      generations: generation
    };
  }

  /**
   * Dynamic Programming TSP solver for optimal solutions
   * Uses Held-Karp algorithm for small to medium problems
   */
  async dynamicProgrammingTSP(places, constraints) {
    if (places.length > 12) {
      throw new Error('Dynamic programming TSP limited to 12 places for performance');
    }

    const n = places.length;
    if (n === 0) return { route: [], totalDistance: 0 };

    // Build distance matrix
    const distances = await this.buildCompleteDistanceMatrix(places, constraints.startLocation);

    // DP table: dp[mask][i] = minimum cost to visit all places in mask ending at i
    const dp = Array(1 << n).fill(null).map(() => Array(n).fill(Infinity));
    const parent = Array(1 << n).fill(null).map(() => Array(n).fill(-1));

    // Base case: starting from place 0
    dp[1][0] = 0;

    // Fill DP table
    for (let mask = 1; mask < (1 << n); mask++) {
      for (let u = 0; u < n; u++) {
        if (!(mask & (1 << u))) continue;
        if (dp[mask][u] === Infinity) continue;

        for (let v = 0; v < n; v++) {
          if (mask & (1 << v)) continue;

          const newMask = mask | (1 << v);
          const newCost = dp[mask][u] + distances[u][v];

          if (newCost < dp[newMask][v]) {
            dp[newMask][v] = newCost;
            parent[newMask][v] = u;
          }
        }
      }
    }

    // Find optimal ending place
    const finalMask = (1 << n) - 1;
    let minCost = Infinity;
    let lastPlace = -1;

    for (let i = 0; i < n; i++) {
      if (dp[finalMask][i] < minCost) {
        minCost = dp[finalMask][i];
        lastPlace = i;
      }
    }

    // Reconstruct path
    const path = [];
    let currentMask = finalMask;
    let currentPlace = lastPlace;

    while (currentPlace !== -1) {
      path.unshift(currentPlace);
      const prevPlace = parent[currentMask][currentPlace];
      currentMask ^= (1 << currentPlace);
      currentPlace = prevPlace;
    }

    const optimalRoute = path.map(index => places[index]);
    const metrics = await this.calculateRouteMetrics(optimalRoute, constraints);

    return {
      route: optimalRoute,
      ...metrics,
      algorithm: 'dynamic-programming-tsp',
      optimal: true
    };
  }

  /**
   * Ant Colony Optimization for complex routing problems
   */
  async antColonyOptimization(places, constraints) {
    const {
      antCount = 20,
      iterations = 100,
      alpha = 1.0, // pheromone importance
      beta = 2.0,  // heuristic importance
      evaporation = 0.5,
      pheromoneDeposit = 1.0
    } = constraints.acoParams || {};

    if (places.length < 3) {
      return this.advancedGreedyOptimization(places, constraints);
    }

    const n = places.length;

    // Initialize pheromone matrix
    const pheromones = Array(n).fill(null).map(() => Array(n).fill(1.0));

    // Build heuristic matrix (1/distance)
    const heuristics = await this.buildHeuristicMatrix(places, constraints);

    let bestRoute = null;
    let bestDistance = Infinity;

    for (let iteration = 0; iteration < iterations; iteration++) {
      const routes = [];

      // Each ant constructs a route
      for (let ant = 0; ant < antCount; ant++) {
        const route = await this.constructAntRoute(
          places, 
          pheromones, 
          heuristics, 
          alpha, 
          beta,
          constraints
        );

        if (route && route.length > 0) {
          const distance = await this.calculateTotalRouteDistance(route);
          routes.push({ route, distance });

          if (distance < bestDistance) {
            bestDistance = distance;
            bestRoute = [...route];
          }
        }
      }

      // Update pheromones
      this.updatePheromones(pheromones, routes, evaporation, pheromoneDeposit);
    }

    const metrics = await this.calculateRouteMetrics(bestRoute, constraints);

    return {
      route: bestRoute,
      ...metrics,
      algorithm: 'ant-colony',
      iterations
    };
  }

  /**
   * Simulated Annealing for escaping local optima
   */
  async simulatedAnnealingOptimization(places, constraints) {
    if (places.length === 0) return { route: [], totalDistance: 0 };

    const {
      initialTemperature = 10000,
      coolingRate = 0.95,
      minTemperature = 1,
      maxIterationsPerTemp = 100
    } = constraints.saParams || {};

    // Start with greedy solution
    let currentRoute = (await this.advancedGreedyOptimization(places, constraints)).route;
    let currentCost = await this.calculateTotalRouteDistance(currentRoute);

    let bestRoute = [...currentRoute];
    let bestCost = currentCost;

    let temperature = initialTemperature;

    while (temperature > minTemperature) {
      for (let i = 0; i < maxIterationsPerTemp; i++) {
        // Generate neighbor solution
        const neighborRoute = this.generateNeighborSolution(currentRoute);
        const neighborCost = await this.calculateTotalRouteDistance(neighborRoute);

        // Calculate acceptance probability
        const delta = neighborCost - currentCost;
        const acceptanceProbability = delta < 0 ? 1 : Math.exp(-delta / temperature);

        // Accept or reject the neighbor
        if (Math.random() < acceptanceProbability) {
          currentRoute = neighborRoute;
          currentCost = neighborCost;

          // Update best if improved
          if (currentCost < bestCost) {
            bestRoute = [...currentRoute];
            bestCost = currentCost;
          }
        }
      }

      temperature *= coolingRate;
    }

    const metrics = await this.calculateRouteMetrics(bestRoute, constraints);

    return {
      route: bestRoute,
      ...metrics,
      algorithm: 'simulated-annealing',
      finalTemperature: temperature
    };
  }

  /**
   * Multi-Objective Optimization using NSGA-II
   * Optimizes for multiple criteria simultaneously
   */
  async multiObjectiveOptimization(places, constraints) {
    const {
      populationSize = 100,
      generations = 50,
      objectives = ['distance', 'time', 'cost', 'rating']
    } = constraints.moParams || {};

    // Initialize population
    let population = await this.initializePopulation(places, populationSize, constraints);

    for (let generation = 0; generation < generations; generation++) {
      // Evaluate all objectives for each individual
      const objectiveValues = await Promise.all(
        population.map(individual => this.evaluateMultipleObjectives(individual, objectives, constraints))
      );

      // Non-dominated sorting
      const fronts = this.nonDominatedSort(population, objectiveValues);

      // Create new population
      const newPopulation = [];
      let frontIndex = 0;

      while (newPopulation.length + fronts[frontIndex].length <= populationSize) {
        newPopulation.push(...fronts[frontIndex]);
        frontIndex++;
      }

      // Fill remaining slots using crowding distance
      if (newPopulation.length < populationSize) {
        const remainingSlots = populationSize - newPopulation.length;
        const lastFront = fronts[frontIndex];
        const crowdingDistances = this.calculateCrowdingDistance(lastFront, objectiveValues);

        const sortedByDistance = lastFront
          .map((individual, index) => ({ individual, distance: crowdingDistances[index] }))
          .sort((a, b) => b.distance - a.distance);

        newPopulation.push(...sortedByDistance.slice(0, remainingSlots).map(item => item.individual));
      }

      population = newPopulation;

      // Generate offspring through crossover and mutation
      if (generation < generations - 1) {
        const offspring = [];

        for (let i = 0; i < populationSize; i += 2) {
          const parent1 = this.tournamentSelection(population);
          const parent2 = this.tournamentSelection(population);

          const [child1, child2] = this.crossover(parent1, parent2);

          offspring.push(this.mutate(child1));
          offspring.push(this.mutate(child2));
        }

        population = [...population, ...offspring].slice(0, populationSize);
      }
    }

    // Return Pareto front solutions
    const finalObjectives = await Promise.all(
      population.map(individual => this.evaluateMultipleObjectives(individual, objectives, constraints))
    );

    const paretoFront = this.extractParetoFront(population, finalObjectives);

    // Select best compromise solution
    const bestCompromise = this.selectBestCompromise(paretoFront, objectives);
    const metrics = await this.calculateRouteMetrics(bestCompromise, constraints);

    return {
      route: bestCompromise,
      ...metrics,
      paretoFront: paretoFront.map(route => ({
        route,
        objectives: this.evaluateMultipleObjectives(route, objectives, constraints)
      })),
      algorithm: 'multi-objective-nsga2'
    };
  }

  /**
   * Helper Methods
   */

  async checkConstraints(place, currentTime, currentCost, constraints) {
    const {
      timeConstraints = {},
      budget = Infinity,
      accessibility = {}
    } = constraints;

    // Time constraint
    if (timeConstraints.maxDuration && 
        currentTime + place.averageVisitDuration > timeConstraints.maxDuration) {
      return { feasible: false, reason: 'time_exceeded' };
    }

    // Budget constraint
    if (currentCost + (place.entryFee?.indian || 0) > budget) {
      return { feasible: false, reason: 'budget_exceeded' };
    }

    // Accessibility constraints
    if (accessibility.wheelchairAccess && !place.wheelchairAccessible) {
      return { feasible: false, reason: 'accessibility_required' };
    }

    if (accessibility.kidFriendly && place.kidFriendly === false) {
      return { feasible: false, reason: 'not_kid_friendly' };
    }

    return { feasible: true };
  }

  async calculateMultiCriteriaScore(candidate, currentLocation, selectedPlaces, constraints, distanceMatrix, weights) {
    const scores = {
      rating: this.normalizeRating(candidate.rating || 0),
      distance: currentLocation ? await this.calculateDistanceScore(candidate, currentLocation) : 0.5,
      time: this.calculateTimeScore(candidate, constraints.timeConstraints),
      cost: this.calculateCostScore(candidate, constraints.budget),
      popularity: this.calculatePopularityScore(candidate),
      diversity: this.calculateDiversityScore(candidate, selectedPlaces)
    };

    // Apply weights and calculate total score
    const totalScore = Object.keys(weights).reduce((total, criterion) => {
      return total + (scores[criterion] || 0) * (weights[criterion] || 0);
    }, 0);

    return { ...scores, totalScore };
  }

  normalizeRating(rating) {
    return (rating - 1) / 4; // Normalize 1-5 scale to 0-1
  }

  async calculateDistanceScore(place, currentLocation) {
    const distance = await this.getTravelDistance(currentLocation, place.location);
    return Math.max(0, 1 - distance / 100); // Penalize distances > 100km
  }

  calculateTimeScore(place, timeConstraints) {
    if (!timeConstraints || !timeConstraints.preferredDuration) return 0.5;

    const duration = place.averageVisitDuration;
    const preferred = timeConstraints.preferredDuration;
    const difference = Math.abs(duration - preferred) / preferred;

    return Math.max(0, 1 - difference);
  }

  calculateCostScore(place, budget) {
    if (!budget || budget === Infinity) return 1;

    const cost = place.entryFee?.indian || 0;
    return Math.max(0, 1 - cost / (budget * 0.5));
  }

  calculatePopularityScore(place) {
    const reviewCount = place.reviewCount || 0;
    return Math.min(1, Math.log(reviewCount + 1) / Math.log(1000)); // Normalize to 0-1
  }

  calculateDiversityScore(candidate, selectedPlaces) {
    if (selectedPlaces.length === 0) return 1;

    const candidateCategory = candidate.category;
    const existingCategories = selectedPlaces.map(p => p.category);
    const uniqueCategories = new Set(existingCategories);

    // Bonus for new category
    if (!uniqueCategories.has(candidateCategory)) {
      return 1;
    }

    // Penalty for overrepresented category
    const categoryCount = existingCategories.filter(cat => cat === candidateCategory).length;
    return Math.max(0, 1 - categoryCount * 0.2);
  }

  calculateEfficiency(places, totalTime) {
    return totalTime > 0 ? places.length / (totalTime / 60) : 0;
  }

  async getTravelDistance(from, to) {
    const result = await this.distanceCalculator.calculateDrivingDistance(from, to);
    return result.distance;
  }

  async getTravelTime(from, to) {
    const result = await this.distanceCalculator.calculateDrivingDistance(from, to);
    return result.duration;
  }

  async buildDistanceMatrix(places, startLocation) {
    const locations = startLocation ? [startLocation, ...places.map(p => p.location)] : places.map(p => p.location);
    return this.distanceCalculator.calculateDistanceMatrix(locations, locations);
  }

  async buildCompleteDistanceMatrix(places, startLocation) {
    const matrix = [];
    const allLocations = startLocation ? [startLocation, ...places.map(p => p.location)] : places.map(p => p.location);

    for (let i = 0; i < allLocations.length; i++) {
      matrix[i] = [];
      for (let j = 0; j < allLocations.length; j++) {
        if (i === j) {
          matrix[i][j] = 0;
        } else {
          const result = await this.distanceCalculator.calculateDrivingDistance(
            allLocations[i], 
            allLocations[j]
          );
          matrix[i][j] = result.distance;
        }
      }
    }

    return matrix;
  }

  async buildHeuristicMatrix(places, constraints) {
    const distances = await this.buildCompleteDistanceMatrix(places, constraints.startLocation);
    return distances.map(row => row.map(distance => distance > 0 ? 1 / distance : 0));
  }

  async initializePopulation(places, populationSize, constraints) {
    const population = [];

    // Add greedy solution as seed
    const greedySolution = await this.advancedGreedyOptimization(places, constraints);
    population.push(greedySolution.route);

    // Generate random permutations
    for (let i = 1; i < populationSize; i++) {
      const randomRoute = this.shuffleArray([...places]);
      population.push(randomRoute);
    }

    return population;
  }

  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  async evaluateFitness(individual, constraints) {
    const metrics = await this.calculateRouteMetrics(individual, constraints);

    // Multi-criteria fitness function
    const distanceScore = 1 / (1 + metrics.totalDistance);
    const timeScore = 1 / (1 + metrics.totalTime);
    const ratingScore = metrics.averageRating / 5;
    const costScore = constraints.budget ? 1 / (1 + metrics.totalCost / constraints.budget) : 1;

    return (distanceScore + timeScore + ratingScore + costScore) / 4;
  }

  tournamentSelection(individuals, tournamentSize = 3) {
    const tournament = [];
    for (let i = 0; i < tournamentSize; i++) {
      const randomIndex = Math.floor(Math.random() * individuals.length);
      tournament.push(individuals[randomIndex]);
    }

    tournament.sort((a, b) => b.fitness - a.fitness);
    return tournament[0].individual;
  }

  crossover(parent1, parent2) {
    // Order crossover (OX)
    const start = Math.floor(Math.random() * parent1.length);
    const end = Math.floor(Math.random() * parent1.length);
    const [crossStart, crossEnd] = [Math.min(start, end), Math.max(start, end)];

    const child = Array(parent1.length).fill(null);

    // Copy segment from parent1
    for (let i = crossStart; i <= crossEnd; i++) {
      child[i] = parent1[i];
    }

    // Fill remaining positions from parent2
    let parent2Index = 0;
    for (let i = 0; i < child.length; i++) {
      if (child[i] === null) {
        while (child.includes(parent2[parent2Index])) {
          parent2Index++;
        }
        child[i] = parent2[parent2Index];
        parent2Index++;
      }
    }

    return child;
  }

  mutate(individual, mutationRate = 0.1) {
    if (Math.random() > mutationRate) return individual;

    const mutated = [...individual];
    const mutationType = Math.random();

    if (mutationType < 0.5) {
      // Swap mutation
      const i = Math.floor(Math.random() * mutated.length);
      const j = Math.floor(Math.random() * mutated.length);
      [mutated[i], mutated[j]] = [mutated[j], mutated[i]];
    } else {
      // Reverse mutation
      const start = Math.floor(Math.random() * mutated.length);
      const end = Math.floor(Math.random() * mutated.length);
      const [reverseStart, reverseEnd] = [Math.min(start, end), Math.max(start, end)];

      const segment = mutated.slice(reverseStart, reverseEnd + 1).reverse();
      mutated.splice(reverseStart, reverseEnd - reverseStart + 1, ...segment);
    }

    return mutated;
  }

  generateNeighborSolution(route) {
    const neighbor = [...route];
    const operationType = Math.random();

    if (operationType < 0.4) {
      // 2-opt swap
      const i = Math.floor(Math.random() * neighbor.length);
      const j = Math.floor(Math.random() * neighbor.length);
      if (i !== j) {
        [neighbor[i], neighbor[j]] = [neighbor[j], neighbor[i]];
      }
    } else if (operationType < 0.7) {
      // Insert operation
      const from = Math.floor(Math.random() * neighbor.length);
      const to = Math.floor(Math.random() * neighbor.length);
      const element = neighbor.splice(from, 1)[0];
      neighbor.splice(to, 0, element);
    } else {
      // Reverse segment
      const start = Math.floor(Math.random() * neighbor.length);
      const length = Math.floor(Math.random() * (neighbor.length - start)) + 1;
      const segment = neighbor.splice(start, length).reverse();
      neighbor.splice(start, 0, ...segment);
    }

    return neighbor;
  }

  async calculateRouteMetrics(route, constraints) {
    if (!route || route.length === 0) {
      return {
        totalTime: 0,
        totalDistance: 0,
        totalCost: 0,
        averageRating: 0,
        efficiency: 0
      };
    }

    const routeMetrics = await this.distanceCalculator.calculateRouteMetrics(
      route, 
      constraints.startLocation
    );

    const totalVisitTime = route.reduce((sum, place) => sum + (place.averageVisitDuration || 60), 0);
    const totalCost = route.reduce((sum, place) => sum + (place.entryFee?.indian || 0), 0);
    const averageRating = route.reduce((sum, place) => sum + (place.rating || 0), 0) / route.length;

    return {
      totalTime: routeMetrics.totalTime + totalVisitTime,
      totalTravelTime: routeMetrics.totalTime,
      totalVisitTime,
      totalDistance: routeMetrics.totalDistance,
      totalCost,
      averageRating,
      efficiency: this.calculateEfficiency(route, routeMetrics.totalTime + totalVisitTime)
    };
  }

  async calculateTotalRouteDistance(route) {
    const metrics = await this.calculateRouteMetrics(route, {});
    return metrics.totalDistance;
  }

  validateFinalRoute(route, constraints) {
    // Implement constraint validation logic
    return {
      timeValid: true,
      budgetValid: true,
      accessibilityValid: true,
      overall: true
    };
  }

  // Clear cache periodically
  clearCache() {
    this.cache.clear();
    console.log('Optimization algorithms cache cleared');
  }
}

module.exports = OptimizationAlgorithms;
---
// backend/controllers/routeController.js
const Place = require('../models/Place');
const PathOptimizer = require('../utils/pathOptimizer');

// Enhanced route optimization with comprehensive error handling
const optimizeRoute = async (req, res) => {
  try {
    const { 
      placeIds, 
      startTime = '09:00',
      endTime = '18:00',
      totalTimeAvailable = 480, // 8 hours in minutes
      startDay = new Date().getDay(),
      optimizationLevel = 'fast', // 'fast', 'balanced', 'optimal'
      preferences = {}
    } = req.body;

    console.log(req.body);
    // Enhanced input validation
    const validation = validateOptimizeRouteInput({
      placeIds,
      startTime,
      endTime,
      totalTimeAvailable,
      startDay,
      optimizationLevel
    });

    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: 'Invalid input parameters',
        errors: validation.errors
      });
    }

    console.log(Optimizing route for ${placeIds.length} places with ${optimizationLevel} optimization);

    // Fetch places with enhanced error handling
    const places = await fetchValidPlaces(placeIds);

    if (places.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No valid places found for the provided IDs'
      });
    }

    // Log warning if some places not found
    if (places.length !== placeIds.length) {
      console.warn(Warning: ${placeIds.length - places.length} places not found or inactive);
    }

    // Initialize path optimizer
    const optimizer = new PathOptimizer();

    // Set optimization constraints with enhanced parameters
    const timeConstraints = {
      startTime,
      endTime,
      totalTimeAvailable,
      startDay,
      priorityWeight: preferences.priorityWeight || 0.3,
      timeWeight: preferences.timeWeight || 0.4,
      openingWeight: preferences.openingWeight || 0.3
    };

    // Execute optimization with timeout protection
    const optimizedRoute = await Promise.race([
      optimizer.optimizeRoute(places, timeConstraints),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Optimization timeout')), 30000) // 30 second timeout
      )
    ]);

    // Validate optimization result
    if (!optimizedRoute || !optimizedRoute.route || optimizedRoute.route.length === 0) {
      return res.status(422).json({
        success: false,
        message: 'Unable to create a feasible route with the given constraints',
        suggestion: 'Try increasing the available time or reducing the number of places'
      });
    }

    // Calculate comprehensive metrics
    const metrics = calculateRouteMetrics(optimizedRoute, places, timeConstraints);

    // Build response with detailed information
    const response = {
      success: true,
      data: {
        optimizedRoute: optimizedRoute.route,
        itinerary: optimizedRoute.itinerary,
        metrics,
        totalDistance: ${optimizedRoute.totalDistance?.toFixed(2)} km,
        totalTime: formatDuration(optimizedRoute.totalTime),
        totalTravelTime: formatDuration(optimizedRoute.totalTravelTime),
        feasible: optimizedRoute.feasible,
        efficiency: ${optimizedRoute.efficiency?.toFixed(1)}%,
        optimizationLevel,
        warnings: generateWarnings(optimizedRoute, places, timeConstraints)
      }
    };

    // Add cache statistics in development mode
    if (process.env.NODE_ENV === 'development') {
      response.data.cacheStats = optimizer.getCacheStats();
    }

    res.status(200).json(response);

  } catch (error) {
    console.error('Error optimizing route:', error);

    // Enhanced error handling with specific error types
    if (error.message === 'Optimization timeout') {
      return res.status(408).json({
        success: false,
        message: 'Route optimization took too long. Try with fewer places or simpler constraints.',
        errorType: 'TIMEOUT'
      });
    }

    if (error.message.includes('API quota exceeded')) {
      return res.status(429).json({
        success: false,
        message: 'Temporarily unable to calculate precise distances. Please try again later.',
        errorType: 'QUOTA_EXCEEDED'
      });
    }

    if (error.message.includes('Invalid coordinates')) {
      return res.status(400).json({
        success: false,
        message: 'Some places have invalid location data.',
        errorType: 'INVALID_COORDINATES'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error optimizing route',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error',
      errorType: 'INTERNAL_ERROR'
    });
  }
};

// Enhanced distance calculation with better error handling
const getDistanceBetweenPlaces = async (req, res) => {
  try {
    const { fromPlaceId, toPlaceId } = req.params;

    // Input validation
    if (!fromPlaceId || !toPlaceId) {
      return res.status(400).json({
        success: false,
        message: 'Both fromPlaceId and toPlaceId are required'
      });
    }

    if (fromPlaceId === toPlaceId) {
      return res.status(400).json({
        success: false,
        message: 'From and to places cannot be the same'
      });
    }

    // Fetch places with parallel queries
    const [fromPlace, toPlace] = await Promise.all([
      Place.findOne({
        $or: [{ _id: fromPlaceId }, { id: fromPlaceId }],
        isActive: true
      }),
      Place.findOne({
        $or: [{ _id: toPlaceId }, { id: toPlaceId }],
        isActive: true
      })
    ]);

    if (!fromPlace) {
      return res.status(404).json({
        success: false,
        message: 'Source place not found',
        errorType: 'FROM_PLACE_NOT_FOUND'
      });
    }

    if (!toPlace) {
      return res.status(404).json({
        success: false,
        message: 'Destination place not found',
        errorType: 'TO_PLACE_NOT_FOUND'
      });
    }

    // Validate coordinates
    if (!isValidCoordinates(fromPlace.location) || !isValidCoordinates(toPlace.location)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid coordinates in place data',
        errorType: 'INVALID_COORDINATES'
      });
    }

    const optimizer = new PathOptimizer();

    // Get travel information with timeout
    const travelInfo = await Promise.race([
      optimizer.getGoogleMapsDistance(fromPlace.location, toPlace.location),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Distance calculation timeout')), 10000)
      )
    ]);

    res.status(200).json({
      success: true,
      data: {
        from: {
          id: fromPlace.id || fromPlace._id,
          name: fromPlace.name,
          coordinates: fromPlace.location
        },
        to: {
          id: toPlace.id || toPlace._id,
          name: toPlace.name,
          coordinates: toPlace.location
        },
        distance: travelInfo.distanceText,
        duration: travelInfo.durationText,
        distanceKm: parseFloat(travelInfo.distance.toFixed(2)),
        durationMinutes: Math.round(travelInfo.duration),
        durationInTraffic: Math.round(travelInfo.durationInTraffic || travelInfo.duration),
        isFallback: travelInfo.isFallback || false
      }
    });

  } catch (error) {
    console.error('Error calculating distance:', error);

    if (error.message === 'Distance calculation timeout') {
      return res.status(408).json({
        success: false,
        message: 'Distance calculation took too long',
        errorType: 'TIMEOUT'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error calculating distance between places',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};

// Enhanced route suggestions with intelligent filtering
const getSuggestedRoutes = async (req, res) => {
  try {
    const { 
      timeAvailable = 480,
      interests = [],
      startLocation,
      maxPlaces = 8,
      budget,
      accessibility,
      startTime = '09:00',
      startDay = new Date().getDay()
    } = req.query;

    // Input validation
    const timeAvailableNum = parseInt(timeAvailable);
    const maxPlacesNum = parseInt(maxPlaces);

    if (timeAvailableNum < 60 || timeAvailableNum > 1440) {
      return res.status(400).json({
        success: false,
        message: 'Time available must be between 60 and 1440 minutes'
      });
    }

    if (maxPlacesNum < 1 || maxPlacesNum > 20) {
      return res.status(400).json({
        success: false,
        message: 'Max places must be between 1 and 20'
      });
    }

    // Build query with enhanced filtering
    let query = { isActive: true };

    // Filter by interests (categories)
    if (interests && interests.length > 0) {
      const interestArray = Array.isArray(interests) ? interests : interests.split(',');
      query.category = { $in: interestArray.map(i => i.toLowerCase()) };
    }

    // Filter by budget if provided
    if (budget) {
      const budgetNum = parseInt(budget);
      query.$or = [
        { 'entryFee.indian': { $lte: budgetNum } },
        { 'entryFee.indian': { $exists: false } },
        { 'entryFee.indian': 0 }
      ];
    }

    // Filter by accessibility requirements
    if (accessibility === 'wheelchair') {
      query.wheelchairAccessible = true;
    }

    // Get places with enhanced sorting
    let places = await Place.find(query)
      .sort({ 
        rating: -1, 
        reviewCount: -1,
        averageVisitDuration: 1 
      })
      .limit(50) // Get more places for better selection
      .select('-__v');

    if (places.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No places found matching your criteria'
      });
    }

    // Filter by location proximity if provided
    if (startLocation && typeof startLocation === 'string') {
      const coords = startLocation.split(',').map(Number);
      if (coords.length === 2 && !coords.some(isNaN)) {
        const [lat, lng] = coords;
        places = await Place.findNearby(lat, lng, 100); // 100km radius

        if (places.length === 0) {
          return res.status(404).json({
            success: false,
            message: 'No places found near the specified location'
          });
        }
      }
    }

    // Filter places that are open during the suggested time
    const openPlaces = places.filter(place => 
      !place.openingHours || 
      Object.values(place.openingHours).some(schedule => !schedule.closed)
    );

    const placesToUse = openPlaces.length > 0 ? openPlaces : places;

    // Create intelligent route suggestions
    const suggestions = [];
    const optimizer = new PathOptimizer();

    // Quick Explorer Route (3-4 hours, top-rated, short duration)
    if (timeAvailableNum >= 180) {
      const quickPlaces = placesToUse
        .filter(p => (p.averageVisitDuration || 60) <= 90)
        .sort((a, b) => (b.rating || 0) - (a.rating || 0))
        .slice(0, Math.min(6, maxPlacesNum));

      if (quickPlaces.length > 0) {
        try {
          const quickRoute = await optimizer.optimizeRoute(quickPlaces, {
            startTime,
            totalTimeAvailable: Math.min(timeAvailableNum * 0.7, 240),
            startDay
          });

          suggestions.push({
            type: 'Quick Explorer',
            description: 'Perfect for short trips - visit top-rated places with minimal time commitment',
            route: quickRoute.route,
            totalTime: formatDuration(quickRoute.totalTime),
            totalDistance: ${quickRoute.totalDistance?.toFixed(1)} km,
            placesCount: quickRoute.route.length,
            difficulty: 'Easy',
            estimatedCost: calculateRouteCost(quickRoute.route),
            highlights: getRouteHighlights(quickRoute.route)
          });
        } catch (error) {
          console.warn('Error creating quick route:', error);
        }
      }
    }

    // Balanced Discovery Route (4-6 hours, mixed attractions)
    if (timeAvailableNum >= 240) {
      const balancedPlaces = placesToUse
        .filter(p => (p.averageVisitDuration || 60) <= 150)
        .sort((a, b) => {
          const scoreA = (a.rating || 0) + (a.reviewCount || 0) / 100;
          const scoreB = (b.rating || 0) + (b.reviewCount || 0) / 100;
          return scoreB - scoreA;
        })
        .slice(0, Math.min(8, maxPlacesNum));

      if (balancedPlaces.length > 0) {
        try {
          const balancedRoute = await optimizer.optimizeRoute(balancedPlaces, {
            startTime,
            totalTimeAvailable: timeAvailableNum,
            startDay
          });

          suggestions.push({
            type: 'Balanced Discovery',
            description: 'Ideal mix of popular attractions with comfortable pacing',
            route: balancedRoute.route,
            totalTime: formatDuration(balancedRoute.totalTime),
            totalDistance: ${balancedRoute.totalDistance?.toFixed(1)} km,
            placesCount: balancedRoute.route.length,
            difficulty: 'Moderate',
            estimatedCost: calculateRouteCost(balancedRoute.route),
            highlights: getRouteHighlights(balancedRoute.route)
          });
        } catch (error) {
          console.warn('Error creating balanced route:', error);
        }
      }
    }

    // Comprehensive Adventure Route (6+ hours, maximum places)
    if (timeAvailableNum >= 360) {
      const comprehensivePlaces = placesToUse
        .sort((a, b) => {
          // Complex scoring: rating + popularity + category diversity
          const scoreA = (a.rating || 0) * 2 + Math.log(a.reviewCount || 1);
          const scoreB = (b.rating || 0) * 2 + Math.log(b.reviewCount || 1);
          return scoreB - scoreA;
        })
        .slice(0, Math.min(12, maxPlacesNum));

      if (comprehensivePlaces.length > 0) {
        try {
          const comprehensiveRoute = await optimizer.optimizeRoute(comprehensivePlaces, {
            startTime,
            totalTimeAvailable: timeAvailableNum,
            startDay
          });

          suggestions.push({
            type: 'Comprehensive Adventure',
            description: 'Maximum exploration for full-day trips with diverse experiences',
            route: comprehensiveRoute.route,
            totalTime: formatDuration(comprehensiveRoute.totalTime),
            totalDistance: ${comprehensiveRoute.totalDistance?.toFixed(1)} km,
            placesCount: comprehensiveRoute.route.length,
            difficulty: 'Challenging',
            estimatedCost: calculateRouteCost(comprehensiveRoute.route),
            highlights: getRouteHighlights(comprehensiveRoute.route)
          });
        } catch (error) {
          console.warn('Error creating comprehensive route:', error);
        }
      }
    }

    // Cultural Heritage Route (if cultural places available)
    const culturalPlaces = placesToUse.filter(p => 
      ['temple', 'heritage', 'museum', 'cultural'].includes(p.category?.toLowerCase())
    );

    if (culturalPlaces.length >= 3) {
      try {
        const culturalRoute = await optimizer.optimizeRoute(
          culturalPlaces.slice(0, Math.min(8, maxPlacesNum)), 
          {
            startTime,
            totalTimeAvailable: timeAvailableNum * 0.9,
            startDay
          }
        );

        suggestions.push({
          type: 'Cultural Heritage',
          description: 'Immerse yourself in rich cultural and historical experiences',
          route: culturalRoute.route,
          totalTime: formatDuration(culturalRoute.totalTime),
          totalDistance: ${culturalRoute.totalDistance?.toFixed(1)} km,
          placesCount: culturalRoute.route.length,
          difficulty: 'Moderate',
          estimatedCost: calculateRouteCost(culturalRoute.route),
          highlights: getRouteHighlights(culturalRoute.route),
          speciality: 'Cultural Focus'
        });
      } catch (error) {
        console.warn('Error creating cultural route:', error);
      }
    }

    if (suggestions.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Unable to create route suggestions with current constraints',
        suggestion: 'Try adjusting your criteria or increasing available time'
      });
    }

    res.status(200).json({
      success: true,
      data: {
        suggestions,
        totalAvailableTime: formatDuration(timeAvailableNum),
        basedOnCriteria: {
          interests: interests.length > 0 ? interests : ['all'],
          timeAvailable: timeAvailableNum,
          maxPlaces: maxPlacesNum,
          budget: budget || 'no limit',
          accessibility: accessibility || 'standard'
        },
        totalPlacesConsidered: placesToUse.length
      }
    });

  } catch (error) {
    console.error('Error generating route suggestions:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating route suggestions',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};

// Enhanced travel matrix with better error handling
const getTravelMatrix = async (req, res) => {
  try {
    const { placeIds } = req.body;

    if (!placeIds || !Array.isArray(placeIds)) {
      return res.status(400).json({
        success: false,
        message: 'placeIds array is required'
      });
    }

    if (placeIds.length < 2) {
      return res.status(400).json({
        success: false,
        message: 'At least 2 place IDs are required'
      });
    }

    if (placeIds.length > 15) {
      return res.status(400).json({
        success: false,
        message: 'Maximum 15 places allowed for matrix calculation (to prevent timeout)'
      });
    }

    const places = await Place.find({
      $or: [
        { _id: { $in: placeIds } },
        { id: { $in: placeIds } }
      ],
      isActive: true
    });

    if (places.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No valid places found'
      });
    }

    if (places.length !== placeIds.length) {
      console.warn(Warning: Only ${places.length} out of ${placeIds.length} places found);
    }

    // Validate all coordinates before processing
    const invalidPlaces = places.filter(place => !isValidCoordinates(place.location));
    if (invalidPlaces.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Some places have invalid coordinates',
        invalidPlaces: invalidPlaces.map(p => ({ id: p.id, name: p.name }))
      });
    }

    const optimizer = new PathOptimizer();

    // Build matrix with timeout protection
    const { matrix, distances } = await Promise.race([
      optimizer.buildAdjacencyMatrix(places),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Matrix calculation timeout')), 60000) // 60 second timeout
      )
    ]);

    // Format response with comprehensive information
    const travelMatrix = places.map((fromPlace, i) => ({
      from: {
        id: fromPlace.id || fromPlace._id,
        name: fromPlace.name,
        coordinates: fromPlace.location
      },
      destinations: places.map((toPlace, j) => {
        const distanceInfo = distances[i][j];
        return {
          to: {
            id: toPlace.id || toPlace._id,
            name: toPlace.name,
            coordinates: toPlace.location
          },
          duration: Math.round(matrix[i][j]),
          distance: parseFloat(distanceInfo.distance.toFixed(2)),
          durationText: distanceInfo.durationText,
          distanceText: distanceInfo.distanceText,
          durationInTraffic: Math.round(distanceInfo.durationInTraffic || matrix[i][j]),
          isFallback: distanceInfo.isFallback || false
        };
      })
    }));

    // Calculate matrix statistics
    const matrixStats = {
      totalPairs: places.length * places.length,
      averageDistance: calculateAverageDistance(distances),
      averageDuration: calculateAverageDuration(matrix),
      maxDistance: findMaxDistance(distances),
      minDistance: findMinDistance(distances)
    };

    res.status(200).json({
      success: true,
      data: {
        places: places.map(p => ({ 
          id: p.id || p._id, 
          name: p.name,
          coordinates: p.location 
        })),
        travelMatrix,
        statistics: matrixStats
      }
    });

  } catch (error) {
    console.error('Error calculating travel matrix:', error);

    if (error.message === 'Matrix calculation timeout') {
      return res.status(408).json({
        success: false,
        message: 'Travel matrix calculation took too long. Try with fewer places.',
        errorType: 'TIMEOUT'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error calculating travel matrix',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};

// Helper functions with enhanced logic

function validateOptimizeRouteInput(input) {
  const errors = [];
  const { placeIds, startTime, endTime, totalTimeAvailable, startDay, optimizationLevel } = input;

  // Validate placeIds
  if (!placeIds || !Array.isArray(placeIds)) {
    errors.push('placeIds must be an array');
  } else if (placeIds.length === 0) {
    errors.push('placeIds array cannot be empty');
  } else if (placeIds.length > 20) {
    errors.push('Maximum 20 places allowed for optimization');
  }

  // Validate time format
  const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
  if (startTime && !timeRegex.test(startTime)) {
    errors.push('startTime must be in HH:MM format');
  }
  if (endTime && !timeRegex.test(endTime)) {
    errors.push('endTime must be in HH:MM format');
  }

  // Validate time logic
  if (startTime && endTime) {
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    if (endMinutes <= startMinutes) {
      errors.push('endTime must be after startTime');
    }
  }

  // Validate totalTimeAvailable
  if (totalTimeAvailable !== undefined) {
    if (typeof totalTimeAvailable !== 'number' || totalTimeAvailable < 30) {
      errors.push('totalTimeAvailable must be a number >= 30 minutes');
    }
    if (totalTimeAvailable > 1440) {
      errors.push('totalTimeAvailable cannot exceed 1440 minutes (24 hours)');
    }
  }

  // Validate startDay
  if (startDay !== undefined && (typeof startDay !== 'number' || startDay < 0 || startDay > 6)) {
    errors.push('startDay must be a number between 0 (Sunday) and 6 (Saturday)');
  }

  // Validate optimizationLevel
  const validLevels = ['fast', 'balanced', 'optimal'];
  if (optimizationLevel && !validLevels.includes(optimizationLevel)) {
    errors.push(optimizationLevel must be one of: ${validLevels.join(', ')});
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

async function fetchValidPlaces(placeIds) {
  try {
    // Separate ObjectIds from string IDs
    const objectIds = [];
    const stringIds = [];

    placeIds.forEach(id => {
      // Check if the ID looks like a MongoDB ObjectId (24 hex characters)
      if (typeof id === 'string' && id.match(/^[0-9a-fA-F]{24}$/)) {
        objectIds.push(id);
      } else {
        stringIds.push(id);
      }
    });

    // Build query conditions
    const queryConditions = [];

    if (objectIds.length > 0) {
      queryConditions.push({ _id: { $in: objectIds } });
    }

    if (stringIds.length > 0) {
      queryConditions.push({ id: { $in: stringIds } });
    }

    // If no valid conditions, return empty array
    if (queryConditions.length === 0) {
      return [];
    }

    const places = await Place.find({
      $or: queryConditions,
      isActive: true
    }).select('-__v');

    // Validate each place has required data
    return places.filter(place => {
      const hasValidLocation = isValidCoordinates(place.location);
      const hasValidData = place.name && (place.averageVisitDuration || place.averageVisitDuration === 0);

      if (!hasValidLocation || !hasValidData) {
        console.warn(Skipping place ${place.name || place.id}: missing required data);
        return false;
      }

      return true;
    });
  } catch (error) {
    console.error('Error fetching places:', error);
    throw error;
  }
}

function isValidCoordinates(location) {
  return location && 
         typeof location.latitude === 'number' && 
         typeof location.longitude === 'number' &&
         location.latitude >= -90 && location.latitude <= 90 &&
         location.longitude >= -180 && location.longitude <= 180 &&
         !isNaN(location.latitude) && !isNaN(location.longitude);
}

function calculateRouteMetrics(optimizedRoute, allPlaces, timeConstraints) {
  const visitedPlaces = optimizedRoute.route.length;
  const totalPlaces = allPlaces.length;
  const efficiency = (visitedPlaces / totalPlaces * 100).toFixed(1);

  const totalVisitTime = optimizedRoute.route.reduce(
    (sum, place) => sum + (place.averageVisitDuration || 60), 0
  );

  return {
    placesVisited: visitedPlaces,
    placesSkipped: totalPlaces - visitedPlaces,
    totalTravelTime: formatDuration(optimizedRoute.totalTravelTime || 0),
    totalVisitTime: formatDuration(totalVisitTime),
    efficiency: ${efficiency}%,
    estimatedStartTime: timeConstraints.startTime,
    estimatedEndTime: calculateEndTime(timeConstraints.startTime, optimizedRoute.totalTime),
    averageRating: calculateAverageRating(optimizedRoute.route),
    totalEstimatedCost: calculateRouteCost(optimizedRoute.route),
    categoryDistribution: getCategoryDistribution(optimizedRoute.route)
  };
}

function generateWarnings(optimizedRoute, allPlaces, timeConstraints) {
  const warnings = [];

  if (optimizedRoute.route.length < allPlaces.length) {
    warnings.push({
      type: 'INCOMPLETE_ROUTE',
      message: ${allPlaces.length - optimizedRoute.route.length} places were skipped due to time constraints
    });
  }

  if (optimizedRoute.totalTravelTime > optimizedRoute.totalTime * 0.6) {
    warnings.push({
      type: 'HIGH_TRAVEL_TIME',
      message: 'This route involves significant travel time. Consider grouping places by area.'
    });
  }

  const endTime = calculateEndTime(timeConstraints.startTime, optimizedRoute.totalTime);
  if (timeToMinutes(endTime) > 20 * 60) { // After 8 PM
    warnings.push({
      type: 'LATE_FINISH',
      message: 'This route finishes quite late. Some places might be closed.'
    });
  }

  return warnings;
}

function formatDuration(minutes) {
  if (!minutes || minutes < 0) return '0m';

  const hours = Math.floor(minutes / 60);
  const mins = Math.round(minutes % 60);

  if (hours === 0) return ${mins}m;
  if (mins === 0) return ${hours}h;
  return ${hours}h ${mins}m;
}

function calculateEndTime(startTime, totalMinutes) {
  const [startHour, startMin] = startTime.split(':').map(Number);
  const startTotalMinutes = startHour * 60 + startMin;
  const endTotalMinutes = startTotalMinutes + Math.round(totalMinutes);

  const endHour = Math.floor(endTotalMinutes / 60) % 24;
  const endMin = endTotalMinutes % 60;

  return ${endHour.toString().padStart(2, '0')}:${endMin.toString().padStart(2, '0')};
}

function timeToMinutes(timeStr) {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
}

function calculateRouteCost(route) {
  return route.reduce((total, place) => {
    return total + (place.entryFee?.indian || 0);
  }, 0);
}

function getRouteHighlights(route) {
  return route
    .sort((a, b) => (b.rating || 0) - (a.rating || 0))
    .slice(0, 3)
    .map(place => place.name);
}

function calculateAverageRating(route) {
  const ratings = route.filter(place => place.rating).map(place => place.rating);
  return ratings.length > 0 ? (ratings.reduce((a, b) => a + b, 0) / ratings.length).toFixed(1) : 'N/A';
}

function getCategoryDistribution(route) {
  const categories = {};
  route.forEach(place => {
    const category = place.category || 'Other';
    categories[category] = (categories[category] || 0) + 1;
  });
  return categories;
}

function calculateAverageDistance(distances) {
  const allDistances = distances.flat().filter(d => d && d.distance > 0);
  const sum = allDistances.reduce((acc, d) => acc + d.distance, 0);
  return allDistances.length > 0 ? (sum / allDistances.length).toFixed(1) : 0;
}

function calculateAverageDuration(matrix) {
  const allDurations = matrix.flat().filter(d => d > 0);
  const sum = allDurations.reduce((acc, d) => acc + d, 0);
  return allDurations.length > 0 ? Math.round(sum / allDurations.length) : 0;
}

function findMaxDistance(distances) {
  let max = 0;
  distances.forEach(row => {
    row.forEach(d => {
      if (d && d.distance > max) max = d.distance;
    });
  });
  return max.toFixed(1);
}

function findMinDistance(distances) {
  let min = Infinity;
  distances.forEach(row => {
    row.forEach(d => {
      if (d && d.distance > 0 && d.distance < min) min = d.distance;
    });
  });
  return min === Infinity ? 0 : min.toFixed(1);
}

module.exports = {
  optimizeRoute,
  getDistanceBetweenPlaces,
  getSuggestedRoutes,
  getTravelMatrix
};
--
I need the frontend to be worked completely based on the optimization algorithm no based on the order I select the places 
---
// frontend/src/services/api.js - ENHANCED FOR PURE ALGORITHM OPTIMIZATION

class APIService {
  constructor() {
    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000';
    this.timeout = 45000; // Increased timeout for complex optimizations
  }

  async makeRequest(endpoint, options = {}) {
    const url = ${this.baseURL}${endpoint};
    const defaultOptions = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      timeout: this.timeout,
    };

    const config = { ...defaultOptions, ...options };

    try {
      console.log(🌐 API Request: ${config.method} ${url});
      if (config.body) {
        console.log('📤 Request Body:', JSON.parse(config.body));
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);

      const response = await fetch(url, {
        ...config,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);
      console.log(📥 API Response: ${response.status} ${response.statusText});

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new Error(errorData?.message || HTTP ${response.status}: ${response.statusText});
      }

      const data = await response.json();
      console.log('📊 Response Data:', data);
      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new Error('Request timeout - optimization is taking too long. Try with fewer places.');
      }
      console.error(❌ API Error for ${url}:, error);
      throw error;
    }
  }

  async healthCheck() {
    try {
      return await this.makeRequest('/api/health');
    } catch (error) {
      console.error('Health check failed:', error);
      return { status: 'ERROR', message: error.message };
    }
  }

  async getAllPlaces() {
    try {
      return await this.makeRequest('/api/places');
    } catch (error) {
      console.error('Failed to fetch places:', error);
      throw error;
    }
  }

  /**
   * MAIN OPTIMIZATION METHOD - Uses ONLY backend algorithms
   * This method ensures NO frontend fallbacks are used
   */
  async optimizeRouteWithAlgorithm(optimizationData) {
    try {
      console.log('🎯 ALGORITHM-BASED OPTIMIZATION STARTING...');
      console.log('📋 Optimization request:', optimizationData);

      // Validate input data thoroughly
      if (!optimizationData.places || !Array.isArray(optimizationData.places)) {
        throw new Error('Invalid places data provided');
      }

      if (optimizationData.places.length < 2) {
        throw new Error('At least 2 places are required for algorithmic optimization');
      }

      if (optimizationData.places.length > 20) {
        throw new Error('Maximum 20 places allowed for optimization algorithms');
      }

      // Ensure all places have required fields for algorithms
      const invalidPlaces = optimizationData.places.filter(place => 
        !place.id || 
        !place.name || 
        !place.location ||
        typeof place.location.latitude !== 'number' ||
        typeof place.location.longitude !== 'number' ||
        isNaN(place.location.latitude) ||
        isNaN(place.location.longitude) ||
        !place.averageVisitDuration
      );

      if (invalidPlaces.length > 0) {
        console.error('Invalid places found:', invalidPlaces);
        throw new Error(${invalidPlaces.length} places have missing required data for optimization);
      }

      // Prepare data specifically for algorithm processing
      const algorithmPayload = {
        // Core places data - cleaned and standardized
        places: optimizationData.places.map(place => ({
          id: place.id,
          name: place.name,
          category: place.category || 'attraction',
          description: place.description || '',
          location: {
            latitude: parseFloat(place.location.latitude),
            longitude: parseFloat(place.location.longitude)
          },
          averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
          rating: parseFloat(place.rating) || 3.5,
          city: place.city || 'Unknown',
          state: place.state || 'Unknown',
          entryFee: place.entryFee || { indian: 0, foreign: 0 },
          kidFriendly: place.kidFriendly !== false,
          wheelchairAccessible: place.wheelchairAccessible === true,
          openingHours: place.openingHours || null,
          priority: place.priority || 0
        })),

        // Algorithm selection and configuration
        preferences: {
          // Select optimization algorithm based on problem size and user preference
          algorithm: this.selectOptimizationAlgorithm(
            optimizationData.places.length, 
            optimizationData.preferences?.optimizationLevel || 'balanced'
          ),

          // Multi-criteria optimization weights
          weights: {
            rating: optimizationData.preferences?.ratingWeight || 0.3,
            distance: optimizationData.preferences?.distanceWeight || 0.25,
            time: optimizationData.preferences?.timeWeight || 0.2,
            cost: optimizationData.preferences?.costWeight || 0.15,
            accessibility: optimizationData.preferences?.accessibilityWeight || 0.1
          },

          // Optimization strategy
          optimizeFor: optimizationData.preferences?.optimizeFor || 'balanced', // 'time', 'distance', 'rating', 'cost', 'balanced'
          allowPartialRoute: optimizationData.preferences?.allowPartialRoute !== false,
          prioritizeHighRated: optimizationData.preferences?.prioritizeHighRated === true,
          minimizeTravel: optimizationData.preferences?.minimizeTravel === true,
          maximizeDiversity: optimizationData.preferences?.maximizeDiversity === true
        },

        // Enhanced constraints for algorithms
        constraints: {
          // Time constraints
          startTime: optimizationData.constraints?.startTime || '09:00',
          endTime: optimizationData.constraints?.endTime || '18:00',
          totalTimeAvailable: parseInt(optimizationData.constraints?.totalTimeAvailable) || 480,
          startDay: optimizationData.constraints?.startDay || new Date().getDay(),

          // Location constraints
          startLocation: optimizationData.constraints?.startLocation || null,
          endLocation: optimizationData.constraints?.endLocation || null,
          maxDistancePerLeg: optimizationData.constraints?.maxDistancePerLeg || 150,
          maxTotalDistance: optimizationData.constraints?.maxTotalDistance || 500,

          // Budget and accessibility
          budget: optimizationData.constraints?.budget || null,
          accessibility: {
            wheelchairAccess: optimizationData.constraints?.accessibility?.wheelchairAccess === true,
            kidFriendly: optimizationData.constraints?.accessibility?.kidFriendly === true,
            elderlyFriendly: optimizationData.constraints?.accessibility?.elderlyFriendly === true
          },

          // Advanced constraints
          weatherConditions: optimizationData.constraints?.weatherConditions || 'normal',
          trafficConditions: optimizationData.constraints?.trafficConditions || 'normal',
          seasonalFactors: optimizationData.constraints?.seasonalFactors === true
        },

        // Algorithm-specific parameters
        algorithmParams: this.getAlgorithmParameters(
          optimizationData.places.length,
          optimizationData.preferences?.optimizationLevel || 'balanced'
        )
      };

      console.log('🧮 Algorithm payload prepared:', {
        placesCount: algorithmPayload.places.length,
        algorithm: algorithmPayload.preferences.algorithm,
        constraints: Object.keys(algorithmPayload.constraints),
        weights: algorithmPayload.preferences.weights
      });

      // Call the BACKEND OPTIMIZATION ENDPOINT - No frontend fallbacks
      const result = await this.makeRequest('/api/trips/generate', {
        method: 'POST',
        body: JSON.stringify(algorithmPayload),
      });

      console.log('✅ Backend algorithm result:', result);

      // Validate the algorithmic response
      if (!result || !result.success) {
        throw new Error(result?.message || 'Algorithm optimization failed');
      }

      if (!result.data || !result.data.optimizedRoute || !Array.isArray(result.data.optimizedRoute)) {
        throw new Error('Invalid algorithmic route data in response');
      }

      if (result.data.optimizedRoute.length === 0) {
        throw new Error('Algorithm could not find a feasible route with given constraints');
      }

      // Return the pure algorithmic result - NO modifications
      return {
        success: true,
        algorithm: result.data.algorithm || algorithmPayload.preferences.algorithm,
        route: result.data.optimizedRoute,
        itinerary: result.data.itinerary || [],
        metrics: result.data.metrics || {},
        optimizationDetails: {
          totalDistance: result.data.metrics?.totalDistance || 0,
          totalTime: result.data.metrics?.totalTime || 0,
          totalTravelTime: result.data.metrics?.totalTravelTime || 0,
          efficiency: result.data.metrics?.efficiency || 0,
          algorithmUsed: result.data.algorithm,
          constraintsSatisfied: result.data.metrics?.constraintsSatisfied || {},
          placesVisited: result.data.optimizedRoute.length,
          placesSkipped: optimizationData.places.length - result.data.optimizedRoute.length
        },
        alternatives: result.data.alternatives || [],
        recommendations: result.data.recommendations || [],
        warnings: result.data.warnings || []
      };

    } catch (error) {
      console.error('❌ Algorithm-based route optimization failed:', error);

      // Enhanced error handling with algorithm-specific messages
      if (error.message.includes('timeout')) {
        throw new Error('Algorithm optimization timeout. Try with fewer places or simpler constraints.');
      } else if (error.message.includes('no feasible route')) {
        throw new Error('Algorithm could not find a feasible route. Try relaxing time constraints or increasing budget.');
      } else if (error.message.includes('invalid coordinates')) {
        throw new Error('Some places have invalid location data preventing algorithmic optimization.');
      } else if (error.message.includes('insufficient data')) {
        throw new Error('Places lack required data for algorithmic processing.');
      }

      throw error;
    }
  }

  /**
   * Select optimal algorithm based on problem complexity and user preferences
   */
  selectOptimizationAlgorithm(placeCount, optimizationLevel) {
    console.log(🔍 Selecting algorithm for ${placeCount} places, level: ${optimizationLevel});

    // Algorithm selection logic based on computational complexity
    if (placeCount <= 3) {
      return 'advanced-greedy'; // Fast for small problems
    } else if (placeCount <= 6 && optimizationLevel === 'optimal') {
      return 'dynamic-programming'; // Exact solution for small problems
    } else if (placeCount <= 8 && optimizationLevel === 'optimal') {
      return 'genetic'; // Near-optimal for medium problems
    } else if (placeCount <= 12) {
      if (optimizationLevel === 'fast') return 'advanced-greedy';
      if (optimizationLevel === 'balanced') return 'genetic';
      if (optimizationLevel === 'optimal') return 'simulated-annealing';
    } else if (placeCount <= 16) {
      if (optimizationLevel === 'fast') return 'advanced-greedy';
      if (optimizationLevel === 'balanced') return 'ant-colony';
      if (optimizationLevel === 'optimal') return 'genetic';
    } else {
      // Large problems (16+ places)
      if (optimizationLevel === 'fast') return 'advanced-greedy';
      if (optimizationLevel === 'balanced') return 'ant-colony';
      if (optimizationLevel === 'optimal') return 'multi-objective';
    }

    return 'advanced-greedy'; // Default fallback
  }

  /**
   * Get algorithm-specific parameters for optimization
   */
  getAlgorithmParameters(placeCount, optimizationLevel) {
    const baseParams = {
      maxIterations: placeCount * 10,
      convergenceThreshold: 0.001,
      timeLimit: 30000 // 30 seconds max
    };

    switch (optimizationLevel) {
      case 'fast':
        return {
          ...baseParams,
          greedyParams: {
            lookaheadDepth: 1,
            diversityFactor: 0.1
          },
          maxIterations: Math.min(baseParams.maxIterations, 50)
        };

      case 'balanced':
        return {
          ...baseParams,
          geneticParams: {
            populationSize: Math.min(placeCount * 4, 50),
            generations: Math.min(placeCount * 5, 100),
            mutationRate: 0.1,
            crossoverRate: 0.8,
            eliteSize: Math.floor(placeCount * 0.2)
          },
          acoParams: {
            antCount: Math.min(placeCount * 2, 30),
            iterations: Math.min(placeCount * 3, 75),
            alpha: 1.0,
            beta: 2.0,
            evaporation: 0.5
          }
        };

      case 'optimal':
        return {
          ...baseParams,
          geneticParams: {
            populationSize: Math.min(placeCount * 6, 100),
            generations: Math.min(placeCount * 8, 200),
            mutationRate: 0.05,
            crossoverRate: 0.9,
            eliteSize: Math.floor(placeCount * 0.3)
          },
          saParams: {
            initialTemperature: 10000,
            coolingRate: 0.95,
            minTemperature: 1,
            maxIterationsPerTemp: placeCount * 2
          },
          moParams: {
            populationSize: Math.min(placeCount * 8, 150),
            generations: Math.min(placeCount * 10, 150),
            objectives: ['distance', 'time', 'cost', 'rating', 'diversity']
          },
          maxIterations: Math.min(baseParams.maxIterations * 2, 500),
          timeLimit: 45000 // 45 seconds for optimal
        };

      default:
        return baseParams;
    }
  }

  /**
   * Legacy method - now redirects to algorithm-based optimization
   */
  async optimizeRoute(optimizationData) {
    console.warn('⚠️ Using legacy optimizeRoute method - redirecting to algorithm-based optimization');
    return this.optimizeRouteWithAlgorithm(optimizationData);
  }

  /**
   * Get route validation and feasibility check from backend algorithms
   */
  async validateRouteAlgorithmically(routeData) {
    try {
      return await this.makeRequest('/api/routes/validate', {
        method: 'POST',
        body: JSON.stringify(routeData)
      });
    } catch (error) {
      console.error('Route validation failed:', error);
      throw error;
    }
  }

  /**
   * Get algorithmic suggestions based on preferences
   */
  async getAlgorithmicSuggestions(criteria) {
    try {
      const params = new URLSearchParams();

      Object.keys(criteria).forEach(key => {
        if (criteria[key] !== undefined && criteria[key] !== null) {
          if (Array.isArray(criteria[key])) {
            params.append(key, criteria[key].join(','));
          } else {
            params.append(key, criteria[key].toString());
          }
        }
      });

      const endpoint = /api/routes/suggestions${params.toString() ? '?' + params.toString() : ''};
      return await this.makeRequest(endpoint);
    } catch (error) {
      console.error('Failed to get algorithmic suggestions:', error);
      throw error;
    }
  }

  /**
   * Calculate distance matrix using backend algorithms
   */
  async calculateTravelMatrix(placeIds) {
    try {
      return await this.makeRequest('/api/routes/matrix', {
        method: 'POST',
        body: JSON.stringify({ placeIds })
      });
    } catch (error) {
      console.error('Travel matrix calculation failed:', error);
      throw error;
    }
  }

  // Utility method for retrying failed optimizations with different algorithms
  async retryOptimizationWithFallback(optimizationData, maxRetries = 3) {
    const algorithms = ['advanced-greedy', 'genetic', 'ant-colony'];

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const modifiedData = {
          ...optimizationData,
          preferences: {
            ...optimizationData.preferences,
            algorithm: algorithms[attempt % algorithms.length]
          }
        };

        console.log(🔄 Retry attempt ${attempt + 1} with algorithm: ${modifiedData.preferences.algorithm});
        return await this.optimizeRouteWithAlgorithm(modifiedData);

      } catch (error) {
        console.error(Attempt ${attempt + 1} failed:, error.message);

        if (attempt === maxRetries - 1) {
          throw error;
        }

        // Wait before retry with exponential backoff
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
      }
    }
  }

  // Test connectivity and algorithm availability
  async testAlgorithmConnectivity() {
    try {
      const start = Date.now();

      // Test basic health
      const health = await this.healthCheck();

      // Test algorithm endpoints
      const tests = await Promise.allSettled([
        this.makeRequest('/api/routes/algorithms'),
        this.makeRequest('/api/optimization/status')
      ]);

      const duration = Date.now() - start;

      return {
        connected: health.status === 'OK',
        responseTime: duration,
        algorithmsAvailable: tests[0].status === 'fulfilled',
        optimizationService: tests[1].status === 'fulfilled',
        details: {
          health,
          tests: tests.map(t => t.status)
        }
      };
    } catch (error) {
      return {
        connected: false,
        responseTime: null,
        algorithmsAvailable: false,
        optimizationService: false,
        error: error.message
      };
    }
  }
}

// Export singleton instance
export const apiService = new APIService();

// Export utility functions for algorithm handling
export const algorithmUtils = {
  isAlgorithmError: (error) => {
    return error.message.includes('algorithm') || 
           error.message.includes('optimization') || 
           error.message.includes('feasible');
  },

  getAlgorithmErrorSuggestion: (error, placeCount) => {
    if (error.message.includes('timeout')) {
      return placeCount > 10 ? 
        'Try with fewer places (≤10) or use "fast" optimization level' :
        'Use "fast" optimization level for quicker results';
    } else if (error.message.includes('no feasible route')) {
      return 'Increase time budget, reduce places, or relax constraints';
    } else if (error.message.includes('invalid')) {
      return 'Check that all selected places have valid location data';
    }

    return 'Try with different optimization settings or fewer places';
  },

  formatOptimizationLevel: (level) => {
    const levels = {
      fast: 'Fast (Greedy Algorithm)',
      balanced: 'Balanced (Genetic/ACO Algorithm)', 
      optimal: 'Optimal (Multi-Algorithm Approach)'
    };
    return levels[level] || level;
  },

  estimateOptimizationTime: (placeCount, level = 'balanced') => {
    const timeEstimates = {
      fast: Math.min(placeCount * 0.5, 5),
      balanced: Math.min(placeCount * 1.5, 15),
      optimal: Math.min(placeCount * 3, 30)
    };

    return timeEstimates[level] || 10;
  }
};

export default apiService;
----
import React, { useState } from 'react';
import { 
  Clock, 
  MapPin, 
  Navigation, 
  CheckCircle, 
  Circle,
  Star,
  IndianRupee,
  Users,
  Car,
  Info,
  Download,
  Share2,
  Calendar
} from 'lucide-react';
import { UTILS } from '../utils/constants';
import toast from 'react-hot-toast';

const ItineraryDisplay = ({ 
  itinerary, 
  optimizedRoute, 
  visitedPlaces, 
  onPlaceVisited, 
  routeSettings 
}) => {
  const [expandedPlace, setExpandedPlace] = useState(null);
  const [showTravelDetails, setShowTravelDetails] = useState(false);

  if (!itinerary || itinerary.length === 0) {
    return (
      <div className="itinerary-empty">
        <div className="empty-state">
          <Calendar className="empty-icon" />
          <h3>No Itinerary Yet</h3>
          <p>Select places and optimize your route to see your personalized itinerary.</p>
        </div>
      </div>
    );
  }

  const summary = {
    totalPlaces: itinerary.length,
    totalTime: itinerary.reduce((sum, item) => 
      sum + (item.visitDuration || 0) + (item.travelTimeToNext || 0), 0
    ),
    totalDistance: itinerary.reduce((sum, item) => 
      sum + (item.travelDistanceToNext || 0), 0
    ),
    visitedCount: itinerary.filter(item => 
      visitedPlaces.has(item.place.id)
    ).length,
    estimatedCost: itinerary.reduce((sum, item) => 
      sum + (item.place.entryFee?.indian || 0), 0
    )
  };

  const handlePlaceVisited = (placeId, isVisited) => {
    onPlaceVisited(placeId, isVisited);
    toast.success(
      isVisited ? 'Place marked as visited!' : 'Place unmarked as visited'
    );
  };

  const handleShareItinerary = async () => {
    const itineraryText = `My South India Travel Itinerary:\n\n${
      itinerary.map((item, index) => 
        `${index + 1}. ${item.place.name} (${item.arrivalTime} - ${item.departureTime})`
      ).join('\n')
    }\n\nGenerated by TourWithAI`;

    try {
      if (navigator.share) {
        await navigator.share({
          title: 'My South India Itinerary',
          text: itineraryText
        });
      } else {
        await navigator.clipboard.writeText(itineraryText);
        toast.success('Itinerary copied to clipboard!');
      }
    } catch (error) {
      console.error('Share failed:', error);
      toast.error('Failed to share itinerary');
    }
  };

  const handleDownloadItinerary = () => {
    const itineraryData = {
      title: 'My South India Travel Itinerary',
      generatedAt: new Date().toISOString(),
      settings: routeSettings,
      summary,
      places: itinerary.map(item => ({
        name: item.place.name,
        city: item.place.city,
        state: item.place.state,
        arrivalTime: item.arrivalTime,
        departureTime: item.departureTime,
        visitDuration: item.visitDuration,
        entryFee: item.place.entryFee,
        category: item.place.category,
        rating: item.place.rating,
        description: item.place.description,
        address: item.place.address,
        amenities: item.place.amenities
      }))
    };

    const dataStr = JSON.stringify(itineraryData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `TourWithAI-Itinerary-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);
    toast.success('Itinerary downloaded!');
  };

  return (
    <div className="itinerary-container">
      <div className="itinerary-header">
        <div className="itinerary-title">
          <Calendar className="title-icon" />
          <h3>Your Itinerary</h3>
        </div>
        
        <div className="itinerary-actions">
          <button 
            onClick={handleShareItinerary}
            className="action-btn"
            title="Share Itinerary"
          >
            <Share2 size={16} />
          </button>
          <button 
            onClick={handleDownloadItinerary}
            className="action-btn"
            title="Download Itinerary"
          >
            <Download size={16} />
          </button>
        </div>
      </div>

      <div className="itinerary-summary">
        <div className="summary-cards">
          <div className="summary-card">
            <MapPin className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">{summary.totalPlaces}</span>
              <span className="summary-label">Places</span>
            </div>
          </div>
          
          <div className="summary-card">
            <Clock className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">{UTILS.formatDuration(summary.totalTime)}</span>
              <span className="summary-label">Total Time</span>
            </div>
          </div>
          
          <div className="summary-card">
            <Navigation className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">{UTILS.formatDistance(summary.totalDistance)}</span>
              <span className="summary-label">Distance</span>
            </div>
          </div>
          
          <div className="summary-card">
            <IndianRupee className="summary-icon" />
            <div className="summary-content">
              <span className="summary-value">₹{summary.estimatedCost}</span>
              <span className="summary-label">Entry Fees</span>
            </div>
          </div>
        </div>

        <div className="progress-section">
          <div className="progress-header">
            <span>Progress: {summary.visitedCount}/{summary.totalPlaces} places visited</span>
            <span className="progress-percentage">
              {Math.round((summary.visitedCount / summary.totalPlaces) * 100)}%
            </span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${(summary.visitedCount / summary.totalPlaces) * 100}%` 
              }}
            />
          </div>
        </div>
      </div>

      <div className="itinerary-list">
        {itinerary.map((item, index) => {
          const isVisited = visitedPlaces.has(item.place.id);
          const isExpanded = expandedPlace === item.place.id;
          const isLast = index === itinerary.length - 1;

          return (
            <div key={item.place.id} className={`itinerary-item ${isVisited ? 'visited' : ''}`}>
              <div className="timeline-connector">
                <div className={`timeline-dot ${isVisited ? 'completed' : ''}`}>
                  {isVisited ? (
                    <CheckCircle className="timeline-icon completed" />
                  ) : (
                    <Circle className="timeline-icon" />
                  )}
                </div>
                {!isLast && <div className="timeline-line" />}
              </div>

              <div className="itinerary-content">
                <div className="place-header">
                  <div className="place-main-info">
                    <div className="place-number">{index + 1}</div>
                    <div className="place-details">
                      <h4 className="place-name">{item.place.name}</h4>
                      <p className="place-location">
                        {item.place.city}, {item.place.state}
                      </p>
                    </div>
                  </div>

                  <div className="place-actions">
                    <button
                      onClick={() => handlePlaceVisited(item.place.id, !isVisited)}
                      className={`visited-btn ${isVisited ? 'visited' : ''}`}
                      title={isVisited ? 'Mark as not visited' : 'Mark as visited'}
                    >
                      {isVisited ? (
                        <CheckCircle className="visited-icon" />
                      ) : (
                        <Circle className="visited-icon" />
                      )}
                    </button>
                    
                    <button
                      onClick={() => setExpandedPlace(isExpanded ? null : item.place.id)}
                      className="expand-btn"
                      title={isExpanded ? 'Show less' : 'Show more'}
                    >
                      <Info className={`expand-icon ${isExpanded ? 'expanded' : ''}`} />
                    </button>
                  </div>
                </div>

                <div className="timing-info">
                  <div className="timing-item">
                    <Clock className="timing-icon" />
                    <span>{item.arrivalTime} - {item.departureTime}</span>
                    <span className="duration">({UTILS.formatDuration(item.visitDuration)})</span>
                  </div>
                  
                  {item.place.rating && (
                    <div className="rating">
                      <Star className="star-icon filled" />
                      <span>{item.place.rating}</span>
                    </div>
                  )}
                </div>

                {isExpanded && (
                  <div className="expanded-details">
                    <div className="place-description">
                      <p>{item.place.description}</p>
                    </div>

                    <div className="place-meta">
                      <div className="meta-grid">
                        <div className="meta-item">
                          <span className="meta-label">Category:</span>
                          <span className="meta-value">{item.place.category}</span>
                        </div>
                        
                        {item.place.entryFee && (
                          <div className="meta-item">
                            <span className="meta-label">Entry Fee:</span>
                            <span className="meta-value">
                              ₹{item.place.entryFee.indian} 
                              {item.place.entryFee.foreign > 0 && 
                                ` / ₹${item.place.entryFee.foreign} (Foreign)`
                              }
                            </span>
                          </div>
                        )}
                        
                        {item.place.kidFriendly && (
                          <div className="meta-item">
                            <span className="meta-label">Kid Friendly:</span>
                            <span className="meta-value">Yes</span>
                          </div>
                        )}
                        
                        {item.place.wheelchairAccessible && (
                          <div className="meta-item">
                            <span className="meta-label">Wheelchair Access:</span>
                            <span className="meta-value">Yes</span>
                          </div>
                        )}
                      </div>

                      {item.place.amenities && item.place.amenities.length > 0 && (
                        <div className="amenities">
                          <span className="amenities-label">Amenities:</span>
                          <div className="amenities-list">
                            {item.place.amenities.map((amenity, idx) => (
                              <span key={idx} className="amenity-tag">
                                {amenity}
                              </span>
                            ))}
                          </div>
                        </div>
                      )}

                      {item.place.bestTimeToVisit && item.place.bestTimeToVisit.length > 0 && (
                        <div className="best-time">
                          <span className="best-time-label">Best time to visit:</span>
                          <span className="best-time-value">
                            {item.place.bestTimeToVisit.join(', ')}
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {!isLast && item.travelTimeToNext > 0 && (
                  <div className="travel-info">
                    <div className="travel-header">
                      <Car className="travel-icon" />
                      <span>Travel to next destination</span>
                    </div>
                    
                    <div className="travel-details">
                      <div className="travel-time">
                        <Clock className="detail-icon" />
                        <span>{UTILS.formatDuration(item.travelTimeToNext)}</span>
                      </div>
                      
                      {item.travelDistanceToNext > 0 && (
                        <div className="travel-distance">
                          <Navigation className="detail-icon" />
                          <span>{UTILS.formatDistance(item.travelDistanceToNext)}</span>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>

      <div className="itinerary-settings">
        <h4>Route Settings</h4>
        <div className="settings-grid">
          <div className="setting-item">
            <span className="setting-label">Start Time:</span>
            <span className="setting-value">{routeSettings?.startTime || '09:00'}</span>
          </div>
          
          <div className="setting-item">
            <span className="setting-label">Available Time:</span>
            <span className="setting-value">
              {UTILS.formatDuration(routeSettings?.totalTimeAvailable || 480)}
            </span>
          </div>
          
          <div className="setting-item">
            <span className="setting-label">Optimization:</span>
            <span className="setting-value">
              {routeSettings?.optimizationLevel === 'optimal' ? 'Optimal (DP)' : 'Fast (Greedy)'}
            </span>
          </div>
        </div>
      </div>

      <div className="itinerary-tips">
        <h4>💡 Travel Tips</h4>
        <ul className="tips-list">
          <li>Check opening hours before visiting temples and palaces</li>
          <li>Carry water and snacks for longer journeys</li>
          <li>Keep extra time buffer for traffic in city areas</li>
          <li>Download offline maps for areas with poor connectivity</li>
          <li>Respect local customs and dress codes at religious sites</li>
        </ul>
      </div>

      <div className="emergency-info">
        <h4>🆘 Emergency Contacts</h4>
        <div className="emergency-grid">
          <div className="emergency-item">
            <span className="emergency-label">Police:</span>
            <span className="emergency-number">100</span>
          </div>
          <div className="emergency-item">
            <span className="emergency-label">Ambulance:</span>
            <span className="emergency-number">108</span>
          </div>
          <div className="emergency-item">
            <span className="emergency-label">Fire:</span>
            <span className="emergency-number">101</span>
          </div>
          <div className="emergency-item">
            <span className="emergency-label">Tourist Helpline:</span>
            <span className="emergency-number">1363</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ItineraryDisplay;
---
i need the frontend to work completely based on the optimization algorithm and clearly execute the algorithm
