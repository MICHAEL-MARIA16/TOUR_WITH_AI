i have 20 tourist places in my mongodb , 
it has opening time, closing time, average 
time needed to explore that specific place, 
best time to visit, ratings etc.. 
now take 10 district 1.coimbatore tidal park,2.thirunelveli,3.tanjore,4.allepey(kerela),5.chennai,6.salem,7.erode,8.kanniyakumari,9.banglore(karnataka),10.mysore->keep an option in the place selection page to choose the user location among these 10 places and what place the user is selecting ,the trip should start from that specific place and based on the user starting of the trip and the number of hours the user decided to spend in tour ,the tour plan should be given and need a live date and time update in the website like It should behave like a google map but with an extra feature of ai to chat and a detailed trip plan from start to end all the minute things should be suggested in a clear way so that the user follows only the things provided by our trip planner .so for a trip from leaving the home to completing the trip all should be organised by the ai and the algorithm in a detailed manner .note:work base on live date and time of the user



now take 10 district 1.coimbatore tidal park,2.thirunelveli,3.tanjore,4.allepey(kerela),5.chennai,6.salem,7.erode,8.kanniyakumari,9.banglore(karnataka),10.mysore->keep an option in the place selection page to choose the user location among these 10 places and what place the user is selecting ,the trip should start from that specific place and based on the user starting of the trip and the number of hours the user decided to spend in tour ,the tour plan should be given and need a live date and time update in the website like It should behave like a google map but with an extra feature of ai to chat and a detailed trip plan from start to end all the minute things should be suggested in a clear way so that the user follows only the things provided by our trip planner .so for a trip from leaving the home to completing the trip all should be organised by the ai and the algorithm in a detailed manner
---
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import toast from 'react-hot-toast';
import { apiService } from '../services/api';
import ConnectionStatus from './ConnectionStatus';
import LocationSelector from './LocationSelector';
import ItineraryDisplay from './ItineraryDisplay';
import OptimizedGraphVisualization from './OptimizedGraphVisualization';
import { 
  Settings, 
  Zap, 
  Brain, 
  Clock, 
  MapPin, 
  Target,
  AlertCircle,
  CheckCircle,
  Loader
} from 'lucide-react';
import { STORAGE_KEYS, ROUTE_SETTINGS, PLACE_CATEGORIES } from '../utils/constants';

const TripPlannerPage = ({ isConnected, onRetry }) => {
  const [places, setPlaces] = useState([]);
  const [selectedPlaces, setSelectedPlaces] = useState([]);
  const [optimizedRoute, setOptimizedRoute] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [visitedPlaces, setVisitedPlaces] = useState(new Set());
  const [showSettings, setShowSettings] = useState(false);
  const [apiError, setApiError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  const [optimizationStatus, setOptimizationStatus] = useState(null);

  // Enhanced route settings with algorithm preferences
  const [routeSettings, setRouteSettings] = useState({
    startTime: ROUTE_SETTINGS.DEFAULT_START_TIME,
    totalTimeAvailable: ROUTE_SETTINGS.DEFAULT_DURATION,
    optimizationLevel: 'balanced', // 'fast', 'balanced', 'optimal'

    // Algorithm-specific preferences
    preferences: {
      optimizeFor: 'balanced', // 'time', 'distance', 'rating', 'cost', 'balanced'
      ratingWeight: 0.3,
      distanceWeight: 0.25,
      timeWeight: 0.2,
      costWeight: 0.15,
      accessibilityWeight: 0.1,
      prioritizeHighRated: false,
      minimizeTravel: false,
      maximizeDiversity: true,
      allowPartialRoute: true
    },

    // Enhanced constraints
    constraints: {
      startLocation: null,
      endLocation: null,
      maxDistancePerLeg: 150,
      maxTotalDistance: 500,
      budget: null,
      accessibility: {
        wheelchairAccess: false,
        kidFriendly: false,
        elderlyFriendly: false
      }
    }
  });

  // Load places on connection
  const loadAllPlaces = useCallback(async (showToast = true) => {
    setLoading(true);
    setError(null);
    setApiError(null);

    try {
      console.log('üîÑ Loading places from API...');
      const response = await apiService.getAllPlaces();

      if (!response?.success || !response?.places) {
        throw new Error('Invalid API response structure');
      }

      const places = response.places;
      console.log(‚úÖ Loaded ${places.length} places from API);

      // Validate and normalize places for algorithm compatibility
      const validPlaces = places.filter(place => {
        const hasValidLocation = place.location && 
          typeof place.location.latitude === 'number' && 
          typeof place.location.longitude === 'number' &&
          !isNaN(place.location.latitude) && 
          !isNaN(place.location.longitude);

        const hasRequiredData = place.name && place.id && place.averageVisitDuration;

        if (!hasValidLocation || !hasRequiredData) {
          console.warn(‚ö†Ô∏è Skipping place ${place.name}: missing algorithm-required data);
          return false;
        }

        return true;
      });

      console.log(üìä ${validPlaces.length}/${places.length} places are algorithm-compatible);

      setPlaces(validPlaces);
      setRetryCount(0);

      if (showToast) {
        toast.success(Loaded ${validPlaces.length} algorithm-ready places!);
      }

    } catch (error) {
      console.error('üí• Error loading places:', error);
      setError(error.message);
      setApiError(error);
      setRetryCount(prev => prev + 1);

      if (showToast) {
        toast.error(error.message);
      }
    } finally {
      setLoading(false);
    }
  }, []);

  // Enhanced localStorage handling
  useEffect(() => {
    try {
      const storedVisited = localStorage.getItem(STORAGE_KEYS.VISITED_PLACES);
      const storedSettings = localStorage.getItem(STORAGE_KEYS.ROUTE_SETTINGS);

      if (storedVisited) {
        const visitedArray = JSON.parse(storedVisited);
        if (Array.isArray(visitedArray)) {
          setVisitedPlaces(new Set(visitedArray));
        }
      }

      if (storedSettings) {
        const savedSettings = JSON.parse(storedSettings);
        setRouteSettings(prev => ({ ...prev, ...savedSettings }));
      }
    } catch (err) {
      console.error('Error loading from localStorage:', err);
      localStorage.removeItem(STORAGE_KEYS.VISITED_PLACES);
      localStorage.removeItem(STORAGE_KEYS.ROUTE_SETTINGS);
    }
  }, []);

  // Load places when connected
  useEffect(() => {
    if (isConnected) {
      loadAllPlaces();
    }
  }, [isConnected, loadAllPlaces]);

  // Place selection handler
  const handlePlaceSelect = useCallback((place, isSelected) => {
    setSelectedPlaces(prev => {
      let newSelection;
      if (isSelected) {
        newSelection = [...prev, place];
        console.log(‚úÖ Added ${place.name} to selection (${newSelection.length} total));
      } else {
        newSelection = prev.filter(p => p.id !== place.id);
        console.log(‚ùå Removed ${place.name} from selection (${newSelection.length} total));
        if (newSelection.length < 2) {
          setOptimizedRoute(null);
          setOptimizationStatus(null);
        }
      }
      return newSelection;
    });
  }, []);

  // Clear selection
  const handleClearSelection = useCallback(() => {
    setSelectedPlaces([]);
    setOptimizedRoute(null);
    setOptimizationStatus(null);
    setVisitedPlaces(new Set());

    try {
      localStorage.removeItem(STORAGE_KEYS.VISITED_PLACES);
    } catch (err) {
      console.error('Error clearing localStorage:', err);
    }

    toast('Selection cleared', { icon: 'üóëÔ∏è' });
  }, []);

  // Place visited handler
  const handlePlaceVisited = useCallback((placeId, isVisited) => {
    setVisitedPlaces(prev => {
      const newSet = new Set(prev);
      if (isVisited) {
        newSet.add(placeId);
        toast.success('Place marked as visited!', { icon: '‚úÖ' });
      } else {
        newSet.delete(placeId);
        toast('Place unmarked', { icon: '‚Ü©Ô∏è' });
      }

      try {
        localStorage.setItem(STORAGE_KEYS.VISITED_PLACES, JSON.stringify(Array.from(newSet)));
      } catch (err) {
        console.error('Error saving visited places:', err);
      }

      return newSet;
    });
  }, []);

  // MAIN ALGORITHM-BASED OPTIMIZATION METHOD
  const handleOptimizeRoute = useCallback(async () => {
    if (selectedPlaces.length < 2) {
      toast.error('Please select at least 2 places for algorithmic optimization.');
      return;
    }

    if (selectedPlaces.length > 20) {
      toast.error('Maximum 20 places allowed for optimization algorithms.');
      return;
    }

    setLoading(true);
    setError(null);
    setOptimizedRoute(null);
    setOptimizationStatus('initializing');

    console.log('ü§ñ STARTING PURE ALGORITHM-BASED OPTIMIZATION');
    console.log(üìç Places to optimize: ${selectedPlaces.length});
    console.log(‚öôÔ∏è Algorithm level: ${routeSettings.optimizationLevel});
    console.log(üéØ Optimization target: ${routeSettings.preferences.optimizeFor});

    try {
      // Prepare algorithm-specific payload
      const algorithmPayload = {
        places: selectedPlaces.map(place => ({
          id: place.id,
          name: place.name,
          category: place.category || 'attraction',
          description: place.description || '',
          location: {
            latitude: parseFloat(place.location.latitude),
            longitude: parseFloat(place.location.longitude)
          },
          averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
          rating: parseFloat(place.rating) || 3.5,
          city: place.city || 'Unknown',
          state: place.state || 'Unknown',
          entryFee: place.entryFee || { indian: 0, foreign: 0 },
          kidFriendly: place.kidFriendly !== false,
          wheelchairAccessible: place.wheelchairAccessible === true,
          openingHours: place.openingHours || null,
          priority: 0
        })),

        preferences: {
          optimizationLevel: routeSettings.optimizationLevel,
          ...routeSettings.preferences
        },

        constraints: {
          startTime: routeSettings.startTime,
          totalTimeAvailable: routeSettings.totalTimeAvailable,
          startDay: new Date().getDay(),
          ...routeSettings.constraints
        }
      };

      setOptimizationStatus('running');
      console.log('üöÄ Calling backend optimization algorithm...');

      // Call the PURE algorithm-based optimization
      const result = await apiService.optimizeRouteWithAlgorithm(algorithmPayload);

      console.log('‚úÖ Algorithm optimization completed:', result);

      if (!result.success || !result.route || result.route.length === 0) {
        throw new Error('Algorithm failed to generate a valid route');
      }

      // Set the algorithm result directly - NO frontend modifications
      setOptimizedRoute({
        route: result.route,
        itinerary: result.itinerary,
        totalTime: result.optimizationDetails?.totalTime || 0,
        totalDistance: result.optimizationDetails?.totalDistance || 0,
        totalTravelTime: result.optimizationDetails?.totalTravelTime || 0,
        efficiency: result.optimizationDetails?.efficiency || 0,
        algorithm: result.algorithm,
        metrics: result.metrics,
        placesVisited: result.optimizationDetails?.placesVisited || 0,
        placesSkipped: result.optimizationDetails?.placesSkipped || 0
      });

      setOptimizationStatus('completed');

      // Show success message with algorithm details
      const algorithmName = result.algorithm || 'Unknown Algorithm';
      const placesOptimized = result.route.length;
      const efficiency = result.optimizationDetails?.efficiency || 0;

      toast.success(
        üß† ${algorithmName} optimized ${placesOptimized} places with ${efficiency}% efficiency!,
        { duration: 4000 }
      );

      // Show warnings if any places were skipped
      if (result.optimizationDetails?.placesSkipped > 0) {
        toast(
          ‚ö†Ô∏è Algorithm skipped ${result.optimizationDetails.placesSkipped} places due to constraints,
          { icon: '‚ö†Ô∏è', duration: 3000 }
        );
      }

    } catch (error) {
      console.error('üí• Algorithm optimization failed:', error);
      setError(error.message);
      setOptimizationStatus('failed');

      // Enhanced error handling for algorithm-specific issues
      if (error.message.includes('timeout')) {
        toast.error('Algorithm timeout - try fewer places or "fast" mode', { duration: 5000 });
      } else if (error.message.includes('no feasible route')) {
        toast.error('No feasible route found - try relaxing constraints', { duration: 5000 });
      } else if (error.message.includes('invalid')) {
        toast.error('Invalid data - check place locations', { duration: 5000 });
      } else {
        toast.error(Algorithm error: ${error.message}, { duration: 5000 });
      }

      // Suggest fallback options
      setTimeout(() => {
        if (selectedPlaces.length > 10) {
          toast('üí° Try with fewer places (‚â§10) for better algorithm performance', { 
            icon: 'üí°', 
            duration: 4000 
          });
        } else if (routeSettings.optimizationLevel === 'optimal') {
          toast('üí° Try "balanced" or "fast" optimization level', { 
            icon: 'üí°', 
            duration: 4000 
          });
        }
      }, 1000);
    } finally {
      setLoading(false);
    }
  }, [selectedPlaces, routeSettings]);

  // Route settings change handler
  const handleRouteSettingsChange = useCallback((newSettings) => {
    setRouteSettings(prev => {
      const updated = { ...prev, ...newSettings };

      try {
        localStorage.setItem(STORAGE_KEYS.ROUTE_SETTINGS, JSON.stringify(updated));
      } catch (err) {
        console.error('Error saving route settings:', err);
      }

      return updated;
    });
  }, []);

  // Enhanced retry functionality
  const handleRetry = useCallback(() => {
    setError(null);
    setApiError(null);
    setOptimizationStatus(null);
    loadAllPlaces(true);
  }, [loadAllPlaces]);

  // Auto-retry with exponential backoff
  useEffect(() => {
    if (apiError && retryCount < 3 && isConnected) {
      const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 10000);
      console.log(Auto-retrying in ${retryDelay}ms (attempt ${retryCount + 1}/3));

      const timer = setTimeout(() => {
        console.log(Auto-retry attempt ${retryCount + 1});
        loadAllPlaces(false);
      }, retryDelay);

      return () => clearTimeout(timer);
    }
  }, [apiError, retryCount, isConnected, loadAllPlaces]);

  // Connection check
  if (!isConnected) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-6">
        <div className="max-w-xl w-full">
          <ConnectionStatus isConnected={isConnected} onRetry={onRetry} />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto p-6 space-y-6">

        {/* Header with Algorithm Status */}
        <div className="bg-white rounded-lg shadow-sm border p-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h1 className="text-3xl font-bold text-gray-900 flex items-center gap-3">
                <Brain className="text-blue-600" size={32} />
                AI-Powered Trip Planner
              </h1>
              <p className="text-gray-600 mt-2">
                Advanced algorithms optimize your route for the best travel experience
              </p>
            </div>

            <button
              onClick={() => setShowSettings(!showSettings)}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
            >
              <Settings size={20} />
              Algorithm Settings
            </button>
          </div>

          {/* Algorithm Status Indicator */}
          {optimizationStatus && (
            <div className="mb-4 p-3 rounded-lg bg-blue-50 border border-blue-200">
              <div className="flex items-center gap-3">
                {optimizationStatus === 'running' && <Loader className="animate-spin text-blue-600" size={20} />}
                {optimizationStatus === 'completed' && <CheckCircle className="text-green-600" size={20} />}
                {optimizationStatus === 'failed' && <AlertCircle className="text-red-600" size={20} />}

                <span className="font-medium">
                  {optimizationStatus === 'initializing' && 'Preparing algorithm...'}
                  {optimizationStatus === 'running' && 'Algorithm optimizing route...'}
                  {optimizationStatus === 'completed' && Algorithm completed successfully!}
                  {optimizationStatus === 'failed' && 'Algorithm optimization failed'}
                </span>
              </div>
            </div>
          )}

          {/* Algorithm Settings Panel */}
          {showSettings && (
            <div className="mt-4 p-4 bg-gray-50 rounded-lg border">
              <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                <Target className="text-blue-600" size={20} />
                Algorithm Configuration
              </h3>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">

                {/* Optimization Level */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Optimization Level
                  </label>
                  <select
                    value={routeSettings.optimizationLevel}
                    onChange={(e) => handleRouteSettingsChange({ optimizationLevel: e.target.value })}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  >
                    <option value="fast">Fast (Greedy Algorithm)</option>
                    <option value="balanced">Balanced (Genetic/ACO)</option>
                    <option value="optimal">Optimal (Multi-Algorithm)</option>
                  </select>
                </div>

                {/* Optimization Target */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Optimize For
                  </label>
                  <select
                    value={routeSettings.preferences.optimizeFor}
                    onChange={(e) => handleRouteSettingsChange({ 
                      preferences: { ...routeSettings.preferences, optimizeFor: e.target.value }
                    })}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  >
                    <option value="balanced">Balanced Experience</option>
                    <option value="time">Minimize Travel Time</option>
                    <option value="distance">Minimize Distance</option>
                    <option value="rating">Maximize Ratings</option>
                    <option value="cost">Minimize Costs</option>
                  </select>
                </div>

                {/* Total Time Available */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2 flex items-center gap-1">
                    <Clock size={16} />
                    Time Available (hours)
                  </label>
                  <input
                    type="number"
                    min="2"
                    max="24"
                    value={Math.round(routeSettings.totalTimeAvailable / 60)}
                    onChange={(e) => handleRouteSettingsChange({ 
                      totalTimeAvailable: parseInt(e.target.value) * 60 
                    })}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  />
                </div>

                {/* Algorithm Preferences */}
                <div className="md:col-span-2 lg:col-span-3">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Algorithm Preferences
                  </label>
                  <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={routeSettings.preferences.prioritizeHighRated}
                        onChange={(e) => handleRouteSettingsChange({
                          preferences: { ...routeSettings.preferences, prioritizeHighRated: e.target.checked }
                        })}
                      />
                      <span className="text-sm">Prioritize High-Rated</span>
                    </label>

                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={routeSettings.preferences.minimizeTravel}
                        onChange={(e) => handleRouteSettingsChange({
                          preferences: { ...routeSettings.preferences, minimizeTravel: e.target.checked }
                        })}
                      />
                      <span className="text-sm">Minimize Travel</span>
                    </label>

                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={routeSettings.preferences.maximizeDiversity}
                        onChange={(e) => handleRouteSettingsChange({
                          preferences: { ...routeSettings.preferences, maximizeDiversity: e.target.checked }
                        })}
                      />
                      <span className="text-sm">Maximize Diversity</span>
                    </label>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Main Content Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">

          {/* Place Selection Panel */}
          <div className="lg:col-span-1">
            <div className="bg-white rounded-lg shadow-sm border">
              <LocationSelector 
                places={places}
                selectedPlaces={selectedPlaces}
                onPlaceSelect={handlePlaceSelect}
                onClearSelection={handleClearSelection}
                onOptimizeRoute={handleOptimizeRoute}
                isLoading={loading}
                error={error}
              />
            </div>
          </div>

          {/* Visualization and Itinerary */}
          <div className="lg:col-span-2 space-y-6">

            {/* Route Visualization */}
            <div className="bg-white rounded-lg shadow-sm border">
              <OptimizedGraphVisualization
                optimizedRoute={optimizedRoute}
                selectedPlaces={selectedPlaces}
                visitedPlaces={visitedPlaces}
                onPlaceVisited={handlePlaceVisited}
                isLoading={loading && selectedPlaces.length >= 2}
                onOptimizeRoute={handleOptimizeRoute}
                routeSettings={routeSettings}
                onRouteSettingsChange={handleRouteSettingsChange}
              />
            </div>

            {/* Itinerary Display */}
            {optimizedRoute && optimizedRoute.itinerary && (
              <div className="bg-white rounded-lg shadow-sm border">
                <ItineraryDisplay 
                  itinerary={optimizedRoute.itinerary}
                  optimizedRoute={optimizedRoute}
                  visitedPlaces={visitedPlaces}
                  onPlaceVisited={handlePlaceVisited}
                  routeSettings={routeSettings}
                />
              </div>
            )}
          </div>
        </div>

        {/* Algorithm Information Panel */}
        {optimizedRoute && (
          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200 p-6">
            <h3 className="text-lg font-semibold text-blue-900 mb-3 flex items-center gap-2">
              <Brain className="text-blue-600" size={20} />
              Algorithm Optimization Results
            </h3>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-blue-800">Algorithm Used</div>
                <div className="text-blue-600">{optimizedRoute.algorithm || 'Advanced Optimization'}</div>
              </div>

              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-green-800">Efficiency</div>
                <div className="text-green-600">{optimizedRoute.efficiency || 0}%</div>
              </div>

              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-purple-800">Places Optimized</div>
                <div className="text-purple-600">{optimizedRoute.placesVisited || 0}</div>
              </div>

              <div className="bg-white rounded p-3 border">
                <div className="font-semibold text-orange-800">Total Distance</div>
                <div className="text-orange-600">{optimizedRoute.totalDistance?.toFixed(1) || 0} km</div>
              </div>
            </div>

            <div className="mt-3 text-sm text-blue-700">
              <strong>Note:</strong> This route was generated using advanced optimization algorithms that considered 
              travel time, distances, ratings, costs, and your preferences to create the most efficient path.
            </div>
          </div>
        )}

        {/* Error Display */}
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4">
            <div className="flex items-start gap-3">
              <AlertCircle className="text-red-500 flex-shrink-0 mt-0.5" size={20} />
              <div>
                <h4 className="font-medium text-red-800">Algorithm Optimization Error</h4>
                <p className="text-red-700 mt-1">{error}</p>
                <div className="mt-3 flex gap-2">
                  <button 
                    onClick={handleRetry}
                    className="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                  >
                    Try Again
                  </button>
                  {selectedPlaces.length > 10 && (
                    <button 
                      onClick={() => {
                        const reducedPlaces = selectedPlaces.slice(0, 8);
                        setSelectedPlaces(reducedPlaces);
                        toast('Reduced to 8 places for better algorithm performance', { icon: 'üí°' });
                      }}
                      className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
                    >
                      Reduce Places
                    </button>
                  )}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default TripPlannerPage;
---
// Updated server.js - Add map routes

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const connectDB = require('./config/database');

// Import routes
const placeRoutes = require('./routes/places');
const routeRoutes = require('./routes/routes');
const chatRoutes = require('./routes/chat');
const tripRoutes = require('./routes/trips');
const distanceRoutes = require('./routes/distance');
const mapRoutes = require('./routes/map'); // ADD THIS LINE

const app = express();
const PORT = process.env.PORT || 5000;

// Connect to MongoDB
connectDB();

// Security middleware
app.use(helmet());

// Enhanced rate limiting
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, 
  max: 100,
  message: {
    error: 'Too many requests from this IP, please try again later.',
    retryAfter: '15 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

const intensiveLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100, 
  message: {
    error: 'Too many optimization requests. Please try again later.',
    retryAfter: '15 minutes'
  }
});

// CORS configuration - MUST come before routes
const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};
app.use(cors(corsOptions));

// Body parsing middleware - MUST come before routes
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Request logging middleware
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  const ip = req.ip || req.connection.remoteAddress;
  console.log([${timestamp}] ${req.method} ${req.url} - IP: ${ip});
  next();
});

// Apply general rate limiting to all API routes
app.use('/api/', rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 200,
  message: {
    error: 'Too many requests from this IP, please try again later.',
    retryAfter: '15 minutes'
  }
}));

// Apply intensive rate limiting only to specific optimization endpoints
app.use('/api/trips/generate', intensiveLimiter);
app.use('/api/trips/optimize', intensiveLimiter);
app.use('/api/trips/matrix', intensiveLimiter);
app.use('/api/routes/optimize', intensiveLimiter);
app.use('/api/routes/matrix', intensiveLimiter);

app.set('trust proxy', 1);

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const mongoose = require('mongoose');
    const dbStatus = mongoose.connection.readyState;

    let placeCount = 0;
    try {
      const Place = require('./models/Place');
      placeCount = await Place.countDocuments();
    } catch (dbError) {
      console.log('Database query failed:', dbError.message);
    }

    res.status(200).json({
      status: 'OK',
      success: true,
      database: dbStatus === 1 ? 'connected' : 'disconnected',
      placesInDatabase: placeCount,
      features: {
        leafletMaps: true,
        openStreetMap: true,
        freeMapping: true,
        noApiKeysRequired: true
      },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      success: false, 
      message: error.message 
    });
  }
});

// Mount API routes
app.use('/api/places', placeRoutes);
app.use('/api/routes', routeRoutes);
app.use('/api/chat', chatRoutes);
app.use('/api/trips', tripRoutes);
app.use('/api/distance', distanceRoutes);
app.use('/api/map', mapRoutes); // ADD THIS LINE

// API documentation endpoint
app.get('/api/docs', (req, res) => {
  res.status(200).json({
    title: 'TourWithAI Backend API Documentation',
    version: '2.1.0',
    description: 'AI-powered travel planning with Leaflet.js + OpenStreetMap integration',
    baseUrl: ${req.protocol}://${req.get('host')}/api,
    mappingTechnology: {
      frontend: 'Leaflet.js',
      tiles: 'OpenStreetMap',
      cost: 'Free',
      features: ['No API keys required', 'Unlimited requests', 'Open source']
    },
    endpoints: {
      places: {
        base: '/places',
        description: 'Tourist place data and search',
        methods: ['GET'],
        examples: [
          'GET /places - Get all places with filters',
          'GET /places/category/temple - Get temples',
          'GET /places/nearby?latitude=12.9716&longitude=77.5946 - Get nearby places'
        ]
      },
      map: {
        base: '/map',
        description: 'Leaflet.js + OpenStreetMap integration endpoints',
        methods: ['GET', 'POST'],
        examples: [
          'GET /map/bounds - Get map bounds for places',
          'GET /map/places-in-bounds - Get places in viewport',
          'POST /map/optimize-route - Get optimized route coordinates',
          'GET /map/clustered-markers - Get clustered markers',
          'GET /map/heatmap-data - Get heatmap data',
          'GET /map/geocode?q=Bangalore - Geocode address',
          'GET /map/reverse-geocode?lat=12.9716&lng=77.5946 - Reverse geocode',
          'GET /map/config - Get map configuration'
        ]
      },
      trips: {
        base: '/trips',
        description: 'Advanced trip planning with AI optimization',
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        examples: [
          'GET /trips - Get all trips for user',
          'GET /trips/:id - Get specific trip',
          'POST /trips/generate - Generate new trip',
          'POST /trips/optimize - Optimize trip places',
          'GET /trips/templates - Get trip templates',
          'PUT /trips/:id - Update trip',
          'DELETE /trips/:id - Delete trip'
        ]
      },
      routes: {
        base: '/routes',
        description: 'Legacy route optimization',
        methods: ['GET', 'POST'],
        examples: [
          'POST /routes/optimize - Basic route optimization',
          'GET /routes/suggestions - Get route suggestions'
        ]
      },
      chat: {
        base: '/chat',
        description: 'AI chat assistant for travel planning',
        methods: ['POST'],
        examples: [
          'POST /chat - Chat with AI assistant'
        ]
      },
      distance: {
        base: '/distance',
        description: 'Distance and travel time calculations',
        methods: ['POST'],
        examples: [
          'POST /distance/matrix - Calculate distance matrix'
        ]
      }
    }
  });
});

// Test endpoint for Leaflet integration
app.get('/api/test/leaflet', (req, res) => {
  res.json({
    success: true,
    message: 'Leaflet.js + OpenStreetMap integration ready!',
    features: {
      mapping: 'Leaflet.js',
      tiles: 'OpenStreetMap',
      geocoding: 'Nominatim (OSM)',
      routing: 'OSRM',
      cost: 'Free',
      apiKeysRequired: false
    },
    testEndpoints: [
      'GET /api/map/bounds',
      'GET /api/map/config',
      'GET /api/map/geocode?q=Bangalore'
    ],
    timestamp: new Date().toISOString()
  });
});

// Debug endpoint to list all places
app.get('/api/debug/places', async (req, res) => {
  try {
    const Place = require('./models/Place');
    const places = await Place.find({}).limit(5);
    const count = await Place.countDocuments();

    res.status(200).json({
      success: true,
      totalPlaces: count,
      samplePlaces: places.map(place => ({
        id: place.id || place._id,
        name: place.name,
        city: place.city,
        state: place.state,
        category: place.category,
        coordinates: {
          latitude: place.location?.latitude,
          longitude: place.location?.longitude
        }
      })),
      message: Found ${count} places in database,
      leafletReady: true
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Failed to query places from database'
    });
  }
});

// 404 handler for unknown API endpoints
app.use('/api/*', (req, res) => {
  res.status(404).json({
    success: false,
    message: 'API endpoint not found',
    availableEndpoints: ['/places', '/routes', '/trips', '/chat', '/distance', '/map'],
    requestedEndpoint: req.originalUrl,
    suggestion: 'Check /api/docs for available endpoints'
  });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('Global error handler:', {
    error: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method
  });

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Validation Error',
      errors: Object.values(err.errors).map(e => e.message)
    });
  }

  res.status(err.status || 500).json({
    success: false,
    message: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error'
  });
});

// Start server
const server = app.listen(PORT, () => {
  console.log(üöÄ TourWithAI Backend running on port ${PORT});
  console.log(üìç Environment: ${process.env.NODE_ENV || 'development'});
  console.log(üåê CORS enabled for: ${process.env.FRONTEND_URL || 'http://localhost:3000'});
  console.log(üó∫Ô∏è  Leaflet.js + OpenStreetMap: ENABLED);
  console.log(üìù API Documentation: http://localhost:${PORT}/api/docs);
  console.log(üîç Health Check: http://localhost:${PORT}/api/health);
  console.log(üß™ Leaflet Test: http://localhost:${PORT}/api/test/leaflet);
  console.log(üåç Map API: http://localhost:${PORT}/api/map/*);
});

server.timeout = 120000;
module.exports = app;
---
import React, { useState, useEffect, useCallback } from 'react';
import { 
  Brain, 
  MapPin, 
  Clock, 
  Calendar, 
  Star, 
  IndianRupee, 
  Navigation,
  AlertCircle,
  CheckCircle,
  Loader,
  Settings,
  Target,
  Info,
  Coffee,
  Camera,
  Utensils,
  Fuel,
  MapIcon,
  ChevronRight,
  Download,
  Share,
 // Route as RouteIcon // Rename to avoid conflict with react-router-dom Route
} from 'lucide-react';
// Removed: import { Route } from 'react-router-dom'; // This was causing the conflict

const DetailedTripPlanner = ({ optimizedRoute, routeSettings }) => {
  const [detailedPlan, setDetailedPlan] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState('timeline');

  // Generate detailed plan using Gemini AI integration
  const generateDetailedPlan = useCallback(async () => {
    if (!optimizedRoute?.route || optimizedRoute.route.length === 0) return;

    setLoading(true);
    setError(null);

    try {
      // Enhanced payload for Gemini AI
      const geminiPayload = {
        places: optimizedRoute.route.map(place => ({
          id: place.id,
          name: place.name,
          category: place.category,
          city: place.city,
          state: place.state,
          rating: place.rating,
          averageVisitDuration: place.averageVisitDuration,
          entryFee: place.entryFee,
          description: place.description,
          amenities: place.amenities,
          bestTimeToVisit: place.bestTimeToVisit,
          location: place.location
        })),
        preferences: {
          startTime: routeSettings.startTime,
          totalTimeAvailable: routeSettings.totalTimeAvailable,
          optimizationLevel: routeSettings.optimizationLevel,
          budget: routeSettings.constraints?.budget
        },
        routeMetrics: optimizedRoute.metrics,
        algorithm: optimizedRoute.algorithm
      };

      // Call your backend API that integrates with Gemini
      const response = await fetch('/api/trips/generate-detailed-plan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(geminiPayload)
      });

      if (!response.ok) {
        throw new Error('Failed to generate detailed plan');
      }

      const result = await response.json();

      // Enhanced detailed plan structure
      const enhancedPlan = {
        ...result,
        timeline: generateTimeline(optimizedRoute.route, routeSettings),
        insights: generateTripInsights(optimizedRoute.route),
        recommendations: generateRecommendations(optimizedRoute.route),
        logistics: generateLogistics(optimizedRoute.route),
        cultural: generateCulturalTips(optimizedRoute.route)
      };

      setDetailedPlan(enhancedPlan);

    } catch (error) {
      console.error('Error generating detailed plan:', error);
      setError(error.message);
      // Fallback to local generation
      generateFallbackPlan();
    } finally {
      setLoading(false);
    }
  }, [optimizedRoute, routeSettings]);

  // Fallback plan generation
  const generateFallbackPlan = () => {
    const fallbackPlan = {
      summary: {
        title: ${optimizedRoute.route.length}-Day South India Adventure,
        duration: ${Math.ceil(routeSettings.totalTimeAvailable / 60)} hours,
        totalDistance: optimizedRoute.metrics?.totalDistance || 0,
        estimatedCost: calculateTotalCost(optimizedRoute.route),
        difficulty: getDifficultyLevel(optimizedRoute.route)
      },
      timeline: generateTimeline(optimizedRoute.route, routeSettings),
      insights: generateTripInsights(optimizedRoute.route),
      recommendations: generateRecommendations(optimizedRoute.route),
      logistics: generateLogistics(optimizedRoute.route),
      cultural: generateCulturalTips(optimizedRoute.route)
    };

    setDetailedPlan(fallbackPlan);
  };

  // Generate timeline
  const generateTimeline = (places, settings) => {
    let currentTime = timeToMinutes(settings.startTime);
    const timeline = [];

    places.forEach((place, index) => {
      const arrivalTime = currentTime;
      const visitDuration = place.averageVisitDuration || 90;
      const departureTime = arrivalTime + visitDuration;

      timeline.push({
        time: minutesToTime(arrivalTime),
        endTime: minutesToTime(departureTime),
        place,
        duration: visitDuration,
        activities: generateActivities(place),
        tips: generatePlaceTips(place),
        isBreakfast: arrivalTime >= 420 && arrivalTime <= 600, // 7-10 AM
        isLunch: arrivalTime >= 720 && arrivalTime <= 840,     // 12-2 PM
        isDinner: arrivalTime >= 1080 && arrivalTime <= 1200,  // 6-8 PM
        travel: index < places.length - 1 ? {
          duration: 45, // Default travel time
          mode: 'car',
          distance: 25 // Default distance
        } : null
      });

      // Add travel time for next place
      currentTime = departureTime + (index < places.length - 1 ? 45 : 0);
    });

    return timeline;
  };

  // Generate trip insights
  const generateTripInsights = (places) => {
    const categories = places.map(p => p.category);
    const cities = [...new Set(places.map(p => p.city))];
    const avgRating = places.reduce((sum, p) => sum + (p.rating || 0), 0) / places.length;

    return {
      diversity: categories.length / places.length,
      cityCount: cities.length,
      averageRating: avgRating.toFixed(1),
      totalDuration: places.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
      highlights: places.filter(p => (p.rating || 0) >= 4.5),
      categories: [...new Set(categories)],
      experienceLevel: avgRating >= 4.0 ? 'Premium' : avgRating >= 3.5 ? 'Good' : 'Standard'
    };
  };

  // Generate recommendations
  const generateRecommendations = (places) => {
    return {
      photography: places.filter(p => ['palace', 'heritage', 'fort'].includes(p.category)).slice(0, 3),
      cultural: places.filter(p => p.category === 'temple').slice(0, 2),
      nature: places.filter(p => ['hill-station', 'beach', 'nature'].includes(p.category)).slice(0, 2),
      timing: [
        'Start early (8:00 AM) to avoid crowds',
        'Carry sufficient water and snacks',
        'Wear comfortable walking shoes',
        'Respect local customs and dress codes'
      ]
    };
  };

  // Generate logistics
  const generateLogistics = (places) => {
    return {
      transportation: 'Private car/taxi recommended',
      parking: 'Most places have parking facilities',
      restrooms: 'Available at major attractions',
      food: 'Local restaurants available near most places',
      shopping: 'Souvenir shops at heritage sites',
      emergency: '108 for emergencies, tourist helpline available'
    };
  };

  // Generate cultural tips
  const generateCulturalTips = (places) => {
    const hasTemples = places.some(p => p.category === 'temple');
    const hasHeritage = places.some(p => p.category === 'heritage');

    const tips = [
      'Learn basic local greetings',
      'Try authentic South Indian cuisine',
      'Bargain respectfully at local markets',
      'Be patient with local customs'
    ];

    if (hasTemples) {
      tips.push('Remove footwear before entering temples');
      tips.push('Dress modestly at religious sites');
    }

    if (hasHeritage) {
      tips.push('Hire local guides for historical context');
      tips.push('Photography may be restricted in some areas');
    }

    return tips;
  };

  // Helper functions
  const timeToMinutes = (timeStr) => {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
  };

  const minutesToTime = (minutes) => {
    const hours = Math.floor(minutes / 60) % 24;
    const mins = minutes % 60;
    return ${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')};
  };

  const calculateTotalCost = (places) => {
    return places.reduce((sum, place) => {
      const entryCost = place.entryFee?.indian || place.entryFee?.amount || 0;
      return sum + entryCost;
    }, 0);
  };

  const getDifficultyLevel = (places) => {
    const avgDuration = places.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0) / places.length;
    return avgDuration > 150 ? 'Challenging' : avgDuration > 90 ? 'Moderate' : 'Easy';
  };

  const generateActivities = (place) => {
    const activities = {
      'temple': ['Worship and prayers', 'Architecture photography', 'Cultural exploration'],
      'palace': ['Royal architecture tour', 'Museum visit', 'Garden walk'],
      'heritage': ['Historical tour', 'Photography', 'Archaeological exploration'],
      'fort': ['Historical exploration', 'Panoramic views', 'Photography'],
      'beach': ['Beach walk', 'Water activities', 'Sunset viewing'],
      'hill-station': ['Nature walk', 'Scenic photography', 'Cool climate'],
      'nature': ['Nature photography', 'Wildlife spotting', 'Fresh air'],
      'museum': ['Art and history', 'Educational tour', 'Cultural learning']
    };

    return activities[place.category] || ['Sightseeing', 'Photography', 'Cultural experience'];
  };

  const generatePlaceTips = (place) => {
    const tips = {
      'temple': ['Dress modestly', 'Remove footwear', 'Maintain silence'],
      'palace': ['Book guided tours', 'Check photography rules', 'Allow 2-3 hours'],
      'heritage': ['Hire local guide', 'Carry water', 'Wear sun protection'],
      'fort': ['Wear comfortable shoes', 'Carry water', 'Best in morning/evening'],
      'beach': ['Apply sunscreen', 'Stay hydrated', 'Check tide timings'],
      'hill-station': ['Carry light jacket', 'Check weather', 'Book accommodation early']
    };

    return tips[place.category] || ['Plan sufficient time', 'Carry essentials', 'Follow local guidelines'];
  };

  useEffect(() => {
    if (optimizedRoute?.route?.length > 0) {
      generateDetailedPlan();
    }
  }, [optimizedRoute, generateDetailedPlan]);

  if (!optimizedRoute?.route || optimizedRoute.route.length === 0) {
    return (
      <div className="bg-white rounded-lg shadow-sm border p-6">
        <div className="text-center py-12">
          <Brain className="mx-auto mb-4 text-gray-400" size={48} />
          <h3 className="text-lg font-medium text-gray-900 mb-2">No Route Optimized</h3>
          <p className="text-gray-600">
            Please optimize a route first to see the detailed trip plan.
          </p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-sm border p-6">
        <div className="text-center py-12">
          <Loader className="mx-auto mb-4 text-blue-600 animate-spin" size={48} />
          <h3 className="text-lg font-medium text-gray-900 mb-2">Generating Detailed Plan</h3>
          <p className="text-gray-600">
            Our AI is creating your personalized trip itinerary...
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow-sm border p-6">
        <div className="text-center py-12">
          <AlertCircle className="mx-auto mb-4 text-red-500" size={48} />
          <h3 className="text-lg font-medium text-gray-900 mb-2">Plan Generation Failed</h3>
          <p className="text-red-600 mb-4">{error}</p>
          <button
            onClick={generateDetailedPlan}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  if (!detailedPlan) {
    return (
      <div className="bg-white rounded-lg shadow-sm border p-6">
        <div className="text-center py-12">
          <Brain className="mx-auto mb-4 text-gray-400" size={48} />
          <h3 className="text-lg font-medium text-gray-900 mb-2">Plan Not Available</h3>
          <p className="text-gray-600">
            Unable to generate detailed plan. Please try again.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border">
      {/* Header */}
      <div className="p-6 border-b bg-gradient-to-r from-blue-50 to-purple-50">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-3">
              <Brain className="text-purple-600" size={28} />
              Detailed Trip Plan
            </h2>
            <p className="text-gray-600 mt-1">
              AI-generated comprehensive itinerary for your journey
            </p>
          </div>
          <div className="flex gap-3">
            <button className="flex items-center gap-2 px-3 py-2 bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow">
              <Download size={18} />
              Export
            </button>
            <button className="flex items-center gap-2 px-3 py-2 bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow">
              <Share size={18} />
              Share
            </button>
          </div>
        </div>

        {/* Quick Summary */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
          <div className="bg-white p-3 rounded-lg shadow-sm">
            <div className="flex items-center gap-2">
              <MapPin className="text-blue-600" size={16} />
              <span className="text-sm font-medium">{optimizedRoute.route.length} Places</span>
            </div>
          </div>
          <div className="bg-white p-3 rounded-lg shadow-sm">
            <div className="flex items-center gap-2">
              <Clock className="text-green-600" size={16} />
              <span className="text-sm font-medium">{Math.ceil(routeSettings.totalTimeAvailable / 60)} Hours</span>
            </div>
          </div>
          <div className="bg-white p-3 rounded-lg shadow-sm">
            <div className="flex items-center gap-2">
              <Navigation className="text-purple-600" size={16} />

              <span className="text-sm font-medium">{optimizedRoute.metrics?.totalDistance?.toFixed(0) || 0} KM</span>
            </div>
          </div>
          <div className="bg-white p-3 rounded-lg shadow-sm">
            <div className="flex items-center gap-2">
              <IndianRupee className="text-orange-600" size={16} />
              <span className="text-sm font-medium">‚Çπ{calculateTotalCost(optimizedRoute.route)}</span>
            </div>
          </div>
        </div>
      </div>

      {/* Tab Navigation */}
      <div className="border-b">
        <nav className="flex space-x-8 px-6">
          {[
            { id: 'timeline', label: 'Timeline', icon: Clock },
            { id: 'insights', label: 'Insights', icon: Target },
            { id: 'recommendations', label: 'Tips', icon: Info },
            { id: 'logistics', label: 'Logistics', icon: MapIcon }
          ].map(tab => {
            const Icon = tab.icon;
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={flex items-center gap-2 py-4 border-b-2 transition-colors ${
                  activeTab === tab.id 
                    ? 'border-blue-600 text-blue-600' 
                    : 'border-transparent text-gray-600 hover:text-gray-900'
                }}
              >
                <Icon size={16} />
                {tab.label}
              </button>
            );
          })}
        </nav>
      </div>

      {/* Tab Content /}
      <div className="p-6">
        {/ Timeline Tab */}
        {activeTab === 'timeline' && (
          <div className="space-y-6">
            <div className="flex items-center gap-3 mb-6">
              <Calendar className="text-blue-600" size={24} />
              <h3 className="text-xl font-semibold">Day-by-Day Timeline</h3>
            </div>

            <div className="space-y-4">
              {detailedPlan.timeline.map((item, index) => (
                <div key={index} className="flex gap-4">
                  {/* Time Column */}
                  <div className="flex-shrink-0 w-20 text-center">
                    <div className="bg-blue-100 text-blue-800 px-3 py-1 rounded-lg text-sm font-medium">
                      {item.time}
                    </div>
                    {item.endTime && (
                      <div className="text-xs text-gray-500 mt-1">
                        to {item.endTime}
                      </div>
                    )}
                  </div>

                  {/* Content Column */}
                  <div className="flex-grow">
                    <div className="bg-gray-50 rounded-lg p-4">
                      <div className="flex items-start justify-between mb-3">
                        <div>
                          <h4 className="font-semibold text-gray-900">{item.place.name}</h4>
                          <p className="text-sm text-gray-600">{item.place.city}, {item.place.state}</p>
                        </div>
                        <div className="flex items-center gap-1 text-yellow-500">
                          <Star size={14} fill="currentColor" />
                          <span className="text-sm font-medium">{item.place.rating}</span>
                        </div>
                      </div>

                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {/* Activities */}
                        <div>
                          <h5 className="font-medium text-gray-800 mb-2">Activities</h5>
                          <ul className="space-y-1">
                            {item.activities.map((activity, idx) => (
                              <li key={idx} className="text-sm text-gray-600 flex items-center gap-2">
                                <div className="w-1 h-1 bg-blue-500 rounded-full"></div>
                                {activity}
                              </li>
                            ))}
                          </ul>
                        </div>

                        {/* Tips */}
                        <div>
                          <h5 className="font-medium text-gray-800 mb-2">Tips</h5>
                          <ul className="space-y-1">
                            {item.tips.map((tip, idx) => (
                              <li key={idx} className="text-sm text-gray-600 flex items-center gap-2">
                                <div className="w-1 h-1 bg-green-500 rounded-full"></div>
                                {tip}
                              </li>
                            ))}
                          </ul>
                        </div>
                      </div>

                      <div className="mt-3 pt-3 border-t border-gray-200">
                        <div className="flex items-center justify-between text-sm text-gray-600">
                          <span>Duration: {item.duration} minutes</span>
                          {item.place.entryFee && (
                            <span>Entry: ‚Çπ{item.place.entryFee.indian || item.place.entryFee.amount || 0}</span>
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Travel Info */}
                    {item.travel && index < detailedPlan.timeline.length - 1 && (
                      <div className="flex items-center gap-2 mt-3 ml-4">
                        <div className="flex items-center gap-2 bg-blue-50 px-3 py-1 rounded-full text-sm text-blue-700">
                          <Navigation size={14} />
                          <span>{item.travel.duration} min drive</span>
                          <span>‚Ä¢</span>
                          <span>{item.travel.distance} km</span>
                        </div>
                        <ChevronRight className="text-gray-400" size={16} />
                      </div>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Insights Tab */}
        {activeTab === 'insights' && (
          <div className="space-y-6">
            <div className="flex items-center gap-3 mb-6">
              <Target className="text-green-600" size={24} />
              <h3 className="text-xl font-semibold">Trip Insights</h3>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              <div className="bg-gradient-to-br from-blue-50 to-blue-100 p-4 rounded-lg">
                <h4 className="font-semibold text-blue-800 mb-2">Experience Level</h4>
                <p className="text-2xl font-bold text-blue-900">{detailedPlan.insights.experienceLevel}</p>
                <p className="text-sm text-blue-700">Based on ratings and variety</p>
              </div>

              <div className="bg-gradient-to-br from-green-50 to-green-100 p-4 rounded-lg">
                <h4 className="font-semibold text-green-800 mb-2">Cities Covered</h4>
                <p className="text-2xl font-bold text-green-900">{detailedPlan.insights.cityCount}</p>
                <p className="text-sm text-green-700">Different cities in your journey</p>
              </div>

              <div className="bg-gradient-to-br from-purple-50 to-purple-100 p-4 rounded-lg">
                <h4 className="font-semibold text-purple-800 mb-2">Average Rating</h4>
                <p className="text-2xl font-bold text-purple-900">‚≠ê {detailedPlan.insights.averageRating}</p>
                <p className="text-sm text-purple-700">Quality of selected places</p>
              </div>
            </div>

            <div className="bg-gray-50 p-4 rounded-lg">
              <h4 className="font-semibold text-gray-800 mb-3">Categories Covered</h4>
              <div className="flex flex-wrap gap-2">
                {detailedPlan.insights.categories.map(category => (
                  <span key={category} className="bg-white px-3 py-1 rounded-full text-sm capitalize border">
                    {category.replace('-', ' ')}
                  </span>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Recommendations Tab */}
        {activeTab === 'recommendations' && (
          <div className="space-y-6">
            <div className="flex items-center gap-3 mb-6">
              <Info className="text-orange-600" size={24} />
              <h3 className="text-xl font-semibold">Recommendations & Tips</h3>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Photography Spots */}
              {detailedPlan.recommendations.photography.length > 0 && (
                <div className="bg-gray-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                    <Camera className="text-pink-600" size={18} />
                    Best Photography Spots
                  </h4>
                  <div className="space-y-2">
                    {detailedPlan.recommendations.photography.map(place => (
                      <div key={place.id} className="flex items-center gap-3 p-2 bg-white rounded">
                        <div className="w-2 h-2 bg-pink-500 rounded-full"></div>
                        <span className="text-sm">{place.name}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Cultural Sites */}
              {detailedPlan.recommendations.cultural.length > 0 && (
                <div className="bg-gray-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                    <Info className="text-orange-600" size={18} />
                    Cultural Experiences
                  </h4>
                  <div className="space-y-2">
                    {detailedPlan.recommendations.cultural.map(place => (
                      <div key={place.id} className="flex items-center gap-3 p-2 bg-white rounded">
                        <div className="w-2 h-2 bg-orange-500 rounded-full"></div>
                        <span className="text-sm">{place.name}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>

            {/* General Tips */}
            <div className="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
              <h4 className="font-semibold text-yellow-800 mb-3">General Tips</h4>
              <ul className="space-y-2">
                {detailedPlan.recommendations.timing.map((tip, index) => (
                  <li key={index} className="text-sm text-yellow-700 flex items-center gap-2">
                    <CheckCircle size={14} className="text-yellow-600" />
                    {tip}
                  </li>
                ))}
              </ul>
            </div>

            {/* Cultural Tips */}
            <div className="bg-purple-50 p-4 rounded-lg border border-purple-200">
              <h4 className="font-semibold text-purple-800 mb-3">Cultural Tips</h4>
              <ul className="space-y-2">
                {detailedPlan.cultural.map((tip, index) => (
                  <li key={index} className="text-sm text-purple-700 flex items-center gap-2">
                    <Info size={14} className="text-purple-600" />
                    {tip}
                  </li>
                ))}
              </ul>
            </div>
          </div>
        )}

        {/* Logistics Tab */}
        {activeTab === 'logistics' && (
          <div className="space-y-6">
            <div className="flex items-center gap-3 mb-6">
              <MapIcon className="text-red-600" size={24} />
              <h3 className="text-xl font-semibold">Logistics & Practical Info</h3>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                <div className="bg-blue-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-blue-800 mb-2 flex items-center gap-2">
                    <Navigation size={18} />
                    Transportation
                  </h4>
                  <p className="text-blue-700">{detailedPlan.logistics.transportation}</p>
                </div>

                <div className="bg-green-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-green-800 mb-2 flex items-center gap-2">
                    <Utensils size={18} />
                    Food & Dining
                  </h4>
                  <p className="text-green-700">{detailedPlan.logistics.food}</p>
                </div>

                <div className="bg-purple-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-purple-800 mb-2 flex items-center gap-2">
                    <Coffee size={18} />
                    Shopping
                  </h4>
                  <p className="text-purple-700">{detailedPlan.logistics.shopping}</p>
                </div>
              </div>

              <div className="space-y-4">
                <div className="bg-orange-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-orange-800 mb-2 flex items-center gap-2">
                    <Fuel size={18} />
                    Parking
                  </h4>
                  <p className="text-orange-700">{detailedPlan.logistics.parking}</p>
                </div>

                <div className="bg-red-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-red-800 mb-2 flex items-center gap-2">
                    <AlertCircle size={18} />
                    Emergency Info
                  </h4>
                  <p className="text-red-700">{detailedPlan.logistics.emergency}</p>
                </div>

                <div className="bg-gray-50 p-4 rounded-lg">
                  <h4 className="font-semibold text-gray-800 mb-2">Facilities</h4>
                  <p className="text-gray-700">{detailedPlan.logistics.restrooms}</p>
                </div>
              </div>
            </div>

            {/* Budget Breakdown */}
            <div className="bg-gradient-to-r from-green-50 to-blue-50 p-6 rounded-lg">
              <h4 className="font-semibold text-gray-800 mb-4 flex items-center gap-2">
                <IndianRupee size={20} className="text-green-600" />
                Estimated Budget Breakdown
              </h4>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h5 className="text-sm font-medium text-gray-600 mb-1">Entry Fees</h5>
                  <p className="text-xl font-bold text-green-600">‚Çπ{calculateTotalCost(optimizedRoute.route)}</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h5 className="text-sm font-medium text-gray-600 mb-1">Transportation</h5>
                  <p className="text-xl font-bold text-blue-600">‚Çπ{Math.round((optimizedRoute.metrics?.totalDistance || 0) * 8)}</p>
                  <p className="text-xs text-gray-500">Est. ‚Çπ8/km</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h5 className="text-sm font-medium text-gray-600 mb-1">Food & Misc</h5>
                  <p className="text-xl font-bold text-orange-600">‚Çπ{optimizedRoute.route.length * 300}</p>
                  <p className="text-xs text-gray-500">Est. ‚Çπ300/place</p>
                </div>
              </div>
              <div className="mt-4 p-3 bg-white rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="font-semibold text-gray-800">Total Estimated Cost:</span>
                  <span className="text-2xl font-bold text-purple-600">
                    ‚Çπ{calculateTotalCost(optimizedRoute.route) + Math.round((optimizedRoute.metrics?.totalDistance || 0) * 8) + (optimizedRoute.route.length * 300)}
                  </span>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Action Buttons */}
      <div className="border-t bg-gray-50 p-6">
        <div className="flex flex-wrap gap-3 justify-between items-center">
          <div className="flex gap-3">
            <button className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
              <MapIcon size={16} />
              View on Map
            </button>
            <button className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors">
              <CheckCircle size={16} />
              Start Trip
            </button>
          </div>
          <div className="flex gap-3">
            <button className="flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
              <Settings size={16} />
              Customize
            </button>
            <button className="flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
              <Download size={16} />
              Download PDF
            </button>
          </div>
        </div>
      </div>

      {/* AI Attribution */}
      <div className="border-t bg-gradient-to-r from-purple-50 to-blue-50 p-4">
        <div className="flex items-center justify-center gap-2 text-sm text-gray-600">
          <Brain className="text-purple-600" size={16} />
          <span>Powered by Gemini AI ‚Ä¢ Generated with advanced algorithms</span>
        </div>
      </div>
    </div>
  );
};

export default DetailedTripPlanner;
--
// Updated TripPlannerPage.jsx with DetailedTripPlanner integration
import React, { useState, useEffect, useCallback } from 'react';
import toast from 'react-hot-toast';
import { apiService } from '../services/api';
import ConnectionStatus from '../components/ConnectionStatus';
import LoadingSpinner from '../components/LoadingSpinner';
import DetailedTripPlanner from '../components/DetailedTripPlanner'; // Import the new component
import { 
  Settings, 
  Zap, 
  Brain, 
  Clock, 
  MapPin, 
  Target,
  AlertCircle,
  CheckCircle,
  Loader,
  Eye,
  EyeOff,
  ChevronLeft,
  ChevronRight,
  Navigation
} from 'lucide-react';
import { STORAGE_KEYS, ROUTE_SETTINGS, ALGORITHMS } from '../utils/constants';

import RealTimeTripTracker from '../components/RealTimeTripTracker';

const TripPlannerPage = ({ isConnected, onRetry }) => {
  const [places, setPlaces] = useState([]);
  const [selectedPlaces, setSelectedPlaces] = useState([]);
  const [optimizedRoute, setOptimizedRoute] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [showSettings, setShowSettings] = useState(false);
  const [optimizationStatus, setOptimizationStatus] = useState(null);
  const [currentView, setCurrentView] = useState('selection'); // 'selection', 'results', 'detailed'
  const [showDetailedPlan, setShowDetailedPlan] = useState(false);
  const [showLiveTracking, setShowLiveTracking] = useState(false);
  const [userLocation, setUserLocation] = useState(null);

  // Route settings with algorithm preferences
  const [routeSettings, setRouteSettings] = useState({
    startTime: ROUTE_SETTINGS.DEFAULT_START_TIME,
    totalTimeAvailable: ROUTE_SETTINGS.DEFAULT_DURATION,
    optimizationLevel: 'balanced',

    preferences: {
      optimizeFor: 'balanced',
      ratingWeight: 0.3,
      distanceWeight: 0.25,
      timeWeight: 0.2,
      costWeight: 0.15,
      accessibilityWeight: 0.1
    },

    constraints: {
      startLocation: {
        name: 'Coimbatore Tidal Park',
        latitude: 11.0638,
        longitude: 77.0596
      },
      budget: null,
      accessibility: {
        wheelchairAccess: false,
        kidFriendly: false
      }
    }
  });

  // Load places from API
  const loadPlaces = useCallback(async () => {
    if (!isConnected) return;

    setLoading(true);
    setError(null);

    try {
      console.log('üîÑ Loading places from API...');
      const response = await apiService.getAllPlaces();

      if (!response?.success || !response?.places) {
        throw new Error('Invalid API response structure');
      }

      const places = response.places;
      console.log(‚úÖ Loaded ${places.length} places);

      // Validate places for algorithm compatibility
      const validPlaces = places.filter(place => {
        const hasValidLocation = place.location && 
          typeof place.location.latitude === 'number' && 
          typeof place.location.longitude === 'number';
        const hasRequiredData = place.name && place.id && place.averageVisitDuration;
        return hasValidLocation && hasRequiredData;
      });

      console.log(üìä ${validPlaces.length}/${places.length} places are algorithm-ready);
      setPlaces(validPlaces);
      toast.success(Loaded ${validPlaces.length} places!);

    } catch (error) {
      console.error('üí• Error loading places:', error);
      setError(error.message);
      toast.error(error.message);
    } finally {
      setLoading(false);
    }
  }, [isConnected]);

  // Load places on mount
  useEffect(() => {
    if (isConnected) {
      loadPlaces();
    }
  }, [isConnected, loadPlaces]);

  // Handle place selection
  const handlePlaceSelect = useCallback((place, isSelected) => {
    setSelectedPlaces(prev => {
      if (isSelected) {
        return [...prev, place];
      } else {
        return prev.filter(p => p.id !== place.id);
      }
    });
  }, []);

  // Algorithm-based route optimization
  const handleOptimizeRoute = useCallback(async () => {
    if (selectedPlaces.length < 2) {
      toast.error('Please select at least 2 places for optimization.');
      return;
    }

    if (selectedPlaces.length > 20) {
      toast.error('Maximum 20 places allowed for optimization.');
      return;
    }

    setLoading(true);
    setError(null);
    setOptimizedRoute(null);
    setOptimizationStatus('running');
    setCurrentView('results');

    console.log('ü§ñ Starting algorithm-based optimization');
    console.log(üìç Places: ${selectedPlaces.length});
    console.log(‚öôÔ∏è Level: ${routeSettings.optimizationLevel});

    try {
      // Prepare algorithm payload
      const algorithmPayload = {
        places: selectedPlaces.map(place => ({
          id: place.id,
          name: place.name,
          category: place.category || 'attraction',
          location: {
            latitude: parseFloat(place.location.latitude),
            longitude: parseFloat(place.location.longitude)
          },
          averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
          rating: parseFloat(place.rating) || 3.5,
          city: place.city || 'Unknown',
          state: place.state || 'Unknown',
          entryFee: place.entryFee || { indian: 0, foreign: 0 },
          description: place.description || '',
          amenities: place.amenities || [],
          bestTimeToVisit: place.bestTimeToVisit || ['morning']
        })),
        preferences: routeSettings.preferences,
        constraints: {
          startTime: routeSettings.startTime,
          totalTimeAvailable: routeSettings.totalTimeAvailable,
          startDay: new Date().getDay(),
          ...routeSettings.constraints
        }
      };

      console.log('üöÄ Calling backend optimization...');
      const result = await apiService.optimizeRouteWithAlgorithm(algorithmPayload);

      if (!result.success || !result.route || result.route.length === 0) {
        throw new Error('Algorithm failed to generate a valid route');
      }

      setOptimizedRoute({
        route: result.route,
        itinerary: result.itinerary,
        algorithm: result.algorithm,
        metrics: result.metrics,
        efficiency: result.metrics?.efficiency || 0,
        aiInsights: result.aiInsights || {},
        originalPlaces: selectedPlaces
      });

      setOptimizationStatus('completed');

      toast.success(
        üß† ${result.algorithm} optimized ${result.route.length} places!,
        { duration: 4000 }
      );

    } catch (error) {
      console.error('üí• Optimization failed:', error);
      setError(error.message);
      setOptimizationStatus('failed');
      setCurrentView('selection');
      toast.error(Algorithm error: ${error.message});
    } finally {
      setLoading(false);
    }
  }, [selectedPlaces, routeSettings]);

  // Handle view detailed plan
  const handleViewDetailedPlan = () => {
    setCurrentView('detailed');
    setShowDetailedPlan(true);
  };

  // Handle back navigation
  const handleBackToResults = () => {
    setCurrentView('results');
    setShowDetailedPlan(false);
  };

  const handleBackToSelection = () => {
    setCurrentView('selection');
    setOptimizedRoute(null);
    setOptimizationStatus(null);
    setShowDetailedPlan(false);
  };

  // Connection check
  if (!isConnected) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-6">
        <div className="max-w-xl w-full">
          <ConnectionStatus isConnected={isConnected} onRetry={onRetry} />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto p-6 space-y-6">

        {/* Header with Navigation /}
        <div className="bg-white rounded-lg shadow-sm border p-6">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              {/ Back Button */}
              {currentView !== 'selection' && (
                <button
                  onClick={currentView === 'detailed' ? handleBackToResults : handleBackToSelection}
                  className="flex items-center gap-2 px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
                >
                  <ChevronLeft size={20} />
                  Back
                </button>
              )}

              <div>
                <h1 className="text-3xl font-bold text-gray-900 flex items-center gap-3">
                  <Brain className="text-blue-600" size={32} />
                  AI-Powered Trip Planner
                </h1>
                <p className="text-gray-600 mt-2">
                  {currentView === 'selection' && 'Advanced algorithms optimize your route for the best travel experience'}
                  {currentView === 'results' && 'Your optimized route is ready'}
                  {currentView === 'detailed' && 'Comprehensive AI-generated trip plan'}
                </p>
              </div>
            </div>

            {/* View Toggle & Settings */}
            <div className="flex items-center gap-3">
              {optimizedRoute && currentView === 'results' && (
                <button
                  onClick={showDetailedPlan ? () => setShowDetailedPlan(false) : handleViewDetailedPlan}
                  className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white hover:bg-blue-700 rounded-lg transition-colors"
                >
                  {showDetailedPlan ? <EyeOff size={18} /> : <Eye size={18} />}
                  {showDetailedPlan ? 'Hide' : 'View'} Detailed Plan
                </button>
              )}

              {currentView === 'selection' && (
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
                >
                  <Settings size={20} />
                  Settings
                </button>
              )}
            </div>
          </div>

          {/* Breadcrumb Navigation */}
          <div className="flex items-center gap-2 text-sm text-gray-600">
            <button 
              onClick={() => setCurrentView('selection')}
              className={px-3 py-1 rounded ${currentView === 'selection' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}}
            >
              Place Selection
            </button>
            <ChevronRight size={16} className="text-gray-400" />
            <button 
              onClick={() => optimizedRoute && setCurrentView('results')}
              className={px-3 py-1 rounded ${currentView === 'results' ? 'bg-blue-100 text-blue-700' : optimizedRoute ? 'hover:bg-gray-100' : 'text-gray-400'}}
              disabled={!optimizedRoute}
            >
              Optimization Results
            </button>
            <ChevronRight size={16} className="text-gray-400" />
            <button 
              onClick={() => optimizedRoute && setCurrentView('detailed')}
              className={px-3 py-1 rounded ${currentView === 'detailed' ? 'bg-blue-100 text-blue-700' : optimizedRoute ? 'hover:bg-gray-100' : 'text-gray-400'}}
              disabled={!optimizedRoute}
            >
              Detailed Plan
            </button>
          </div>
          {currentView === 'results' && optimizedRoute && showLiveTracking && (
            <div className="mt-6">
              <RealTimeTripTracker 
                optimizedRoute={optimizedRoute}
                onLocationUpdate={setUserLocation}
              />
            </div>
          )}

          {/* Algorithm Status */}
          {optimizationStatus && currentView !== 'detailed' && (
            <div className="mt-4 p-3 rounded-lg bg-blue-50 border border-blue-200">
              <div className="flex items-center gap-3">
                {optimizationStatus === 'running' && <Loader className="animate-spin text-blue-600" size={20} />}
                {optimizationStatus === 'completed' && <CheckCircle className="text-green-600" size={20} />}
                {optimizationStatus === 'failed' && <AlertCircle className="text-red-600" size={20} />}

                <span className="font-medium">
                  {optimizationStatus === 'running' && 'Algorithm optimizing route...'}
                  {optimizationStatus === 'completed' && 'Optimization completed!'}
                  {optimizationStatus === 'failed' && 'Optimization failed'}
                </span>
              </div>
            </div>
          )}

          {/* Settings Panel */}
          {showSettings && currentView === 'selection' && (
            <div className="mt-4 p-4 bg-gray-50 rounded-lg border">
              <h3 className="text-lg font-semibold mb-3">Algorithm Configuration</h3>

              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Optimization Level
                  </label>
                  <select
                    value={routeSettings.optimizationLevel}
                    onChange={(e) => setRouteSettings(prev => ({
                      ...prev,
                      optimizationLevel: e.target.value
                    }))}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  >
                    {Object.values(ALGORITHMS).map(alg => (
                      <option key={alg.id} value={alg.id}>
                        {alg.name}
                      </option>
                    ))}
                  </select>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Time Available (hours)
                  </label>
                  <input
                    type="number"
                    min="2"
                    max="24"
                    value={Math.round(routeSettings.totalTimeAvailable / 60)}
                    onChange={(e) => setRouteSettings(prev => ({
                      ...prev,
                      totalTimeAvailable: parseInt(e.target.value) * 60
                    }))}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Start Time
                  </label>
                  <input
                    type="time"
                    value={routeSettings.startTime}
                    onChange={(e) => setRouteSettings(prev => ({
                      ...prev,
                      startTime: e.target.value
                    }))}
                    className="w-full p-2 border border-gray-300 rounded-md"
                  />
                </div>
              </div>

              {/* Start Location Info */}
              <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                <div className="flex items-center gap-2 mb-1">
                  <MapPin className="text-blue-600" size={16} />
                  <span className="font-medium text-blue-800">Fixed Start Location</span>
                </div>
                <p className="text-sm text-blue-700">
                  All routes will begin from Coimbatore Tidal Park as per your requirements
                </p>
              </div>
            </div>
          )}
        </div>

        {/* Dynamic Content Based on Current View */}
        {currentView === 'selection' && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">

            {/* Place Selection */}
            <div className="bg-white rounded-lg shadow-sm border p-6">
              <h2 className="text-xl font-semibold mb-4">Select Places to Visit</h2>

              {loading ? (
                <div className="flex justify-center py-8">
                  <LoadingSpinner message="Loading places..." />
                </div>
              ) : places.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  <MapPin className="mx-auto mb-4" size={48} />
                  <p>No places available. Please check your backend connection.</p>
                </div>
              ) : (
                <div className="space-y-3 max-h-96 overflow-y-auto">
                  {places.slice(0, 20).map((place) => (
                    <div
                      key={place.id}
                      className={p-3 border rounded-lg cursor-pointer transition-all ${
                        selectedPlaces.some(p => p.id === place.id)
                          ? 'border-blue-500 bg-blue-50'
                          : 'border-gray-200 hover:border-gray-300'
                      }}
                      onClick={() => handlePlaceSelect(
                        place, 
                        !selectedPlaces.some(p => p.id === place.id)
                      )}
                    >
                      <div className="flex justify-between items-start">
                        <div>
                          <h3 className="font-semibold text-gray-900">{place.name}</h3>
                          <p className="text-sm text-gray-600">{place.city}, {place.state}</p>
                          <div className="flex items-center space-x-4 mt-1 text-xs text-gray-500">
                            <span>‚≠ê {place.rating}</span>
                            <span>üïí {place.averageVisitDuration}min</span>
                            <span>üè∑Ô∏è {place.category}</span>
                          </div>
                        </div>
                        <div className="text-right">
                          <div className={w-6 h-6 rounded border-2 ${
                            selectedPlaces.some(p => p.id === place.id)
                              ? 'border-blue-500 bg-blue-500'
                              : 'border-gray-300'
                          }}>
                            {selectedPlaces.some(p => p.id === place.id) && (
                              <CheckCircle className="w-full h-full text-white" />
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Selection Summary */}
              <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm text-gray-600">
                    Selected: {selectedPlaces.length} places
                  </span>
                  <button
                    onClick={handleOptimizeRoute}
                    disabled={selectedPlaces.length < 2 || loading}
                    className={flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors ${
                      selectedPlaces.length >= 2 && !loading
                        ? 'bg-blue-600 text-white hover:bg-blue-700'
                        : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    }}
                  >
                    {loading ? (
                      <Loader className="animate-spin" size={16} />
                    ) : (
                      <Zap size={16} />
                    )}
                    Optimize Route
                  </button>
                </div>
              </div>
            </div>

            {/* Preview/Instructions */}
            <div className="bg-white rounded-lg shadow-sm border p-6">
              <h2 className="text-xl font-semibold mb-4">How It Works</h2>

              <div className="space-y-4">
                <div className="flex items-start gap-3">
                  <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0">
                    <span className="text-blue-600 font-semibold">1</span>
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-900">Select Places</h3>
                    <p className="text-sm text-gray-600">Choose 2-20 places you want to visit from our curated list.</p>
                  </div>
                </div>

                <div className="flex items-start gap-3">
                  <div className="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center flex-shrink-0">
                    <span className="text-green-600 font-semibold">2</span>
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-900">AI Optimization</h3>
                    <p className="text-sm text-gray-600">Our algorithms find the best route starting from Coimbatore Tidal Park.</p>
                  </div>
                </div>

                <div className="flex items-start gap-3">
                  <div className="w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center flex-shrink-0">
                    <span className="text-purple-600 font-semibold">3</span>
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-900">Detailed Plan</h3>
                    <p className="text-sm text-gray-600">Get a comprehensive itinerary with timing, tips, and cultural insights.</p>
                  </div>
                </div>
              </div>

              {selectedPlaces.length > 0 && (
                <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
                  <h4 className="font-medium text-blue-800 mb-2">Selected Places Preview</h4>
                  <div className="space-y-1">
                    {selectedPlaces.slice(0, 5).map((place, index) => (
                      <div key={place.id} className="text-sm text-blue-700">
                        {index + 1}. {place.name} ({place.city})
                      </div>
                    ))}
                    {selectedPlaces.length > 5 && (
                      <div className="text-sm text-blue-600">
                        +{selectedPlaces.length - 5} more places...
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {currentView === 'results' && optimizedRoute && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">

            {/* Optimized Route Results */}
            <div className="bg-white rounded-lg shadow-sm border p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-semibold">Optimized Route</h2>
                <button
                  onClick={handleViewDetailedPlan}
                  className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
                >
                  <Brain size={16} />
                  View Detailed Plan
                </button>
              </div>

              <div className="space-y-4">
                {/* Route Summary */}
                <div className="p-4 bg-green-50 rounded-lg border border-green-200">
                  <h3 className="font-semibold text-green-800 mb-2">
                    üß† {optimizedRoute.algorithm || 'AI Algorithm'} Results
                  </h3>
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="text-gray-600">Places Optimized:</span>
                      <span className="font-semibold ml-2">{optimizedRoute.route.length}</span>
                    </div>
                    <div>
                      <span className="text-gray-600">Efficiency:</span>
                      <span className="font-semibold ml-2">{optimizedRoute.efficiency || 0}%</span>
                    </div>
                    {optimizedRoute.metrics && (
                      <>
                        <div>
                          <span className="text-gray-600">Total Distance:</span>
                          <span className="font-semibold ml-2">{optimizedRoute.metrics.totalDistance?.toFixed(1) || 0} km</span>
                        </div>
                        <div>
                          <span className="text-gray-600">Total Time:</span>
                          <span className="font-semibold ml-2">{Math.ceil((optimizedRoute.metrics.totalTime || 0) / 60)} hours</span>
                        </div>
                      </>
                    )}
                  </div>
                </div>

                {/* Route List /}
                <div className="space-y-2">
                  {/ Start Location */}
                  <div className="flex items-center p-3 bg-blue-50 border border-blue-200 rounded-lg">
                    <div className="flex-shrink-0 w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center">
                      <MapPin className="text-white" size={16} />
                    </div>
                    <div className="ml-3 flex-grow">
                      <h4 className="font-medium text-blue-900">Start: Coimbatore Tidal Park</h4>
                      <p className="text-sm text-blue-700">Your journey begins here</p>
                    </div>
                    <div className="text-right text-sm text-blue-600">
                      <div>{routeSettings.startTime}</div>
                    </div>
                  </div>

                  {/* Route Places */}
                  {optimizedRoute.route.map((place, index) => (
                    <div key={place.id} className="flex items-center p-3 border rounded-lg">
                      <div className="flex-shrink-0 w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
                        <span className="text-green-600 font-semibold text-sm">{index + 1}</span>
                      </div>
                      <div className="ml-3 flex-grow">
                        <h4 className="font-medium text-gray-900">{place.name}</h4>
                        <p className="text-sm text-gray-600">{place.city}, {place.state}</p>
                        <div className="flex items-center gap-4 mt-1 text-xs text-gray-500">
                          <span>‚≠ê {place.rating}</span>
                          <span>üïí {place.averageVisitDuration}min</span>
                          <span>üè∑Ô∏è {place.category}</span>
                        </div>
                      </div>
                      <div className="text-right text-sm text-gray-500">
                        {place.entryFee && (
                          <div>‚Çπ{place.entryFee.indian || place.entryFee.amount || 0}</div>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            {/* AI Insights & Actions */}
            <div className="space-y-6">

              {/* AI Insights */}
              {optimizedRoute.aiInsights && Object.keys(optimizedRoute.aiInsights).length > 0 && (
                <div className="bg-white rounded-lg shadow-sm border p-6">
                  <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                    <Target className="text-purple-600" size={20} />
                    AI Insights
                  </h3>

                  {optimizedRoute.aiInsights.tripOverview && (
                    <div className="mb-4 p-3 bg-purple-50 rounded-lg">
                      <h4 className="font-medium text-purple-800 mb-1">Trip Overview</h4>
                      <p className="text-sm text-purple-700">{optimizedRoute.aiInsights.tripOverview}</p>
                    </div>
                  )}

                  {optimizedRoute.aiInsights.recommendations && optimizedRoute.aiInsights.recommendations.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-medium text-gray-800 mb-2">Recommendations</h4>
                      <ul className="space-y-1">
                        {optimizedRoute.aiInsights.recommendations.slice(0, 3).map((rec, index) => (
                          <li key={index} className="text-sm text-gray-600 flex items-center gap-2">
                            <CheckCircle size={14} className="text-green-500" />
                            {rec}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {optimizedRoute.aiInsights.budgetEstimate && (
                    <div className="p-3 bg-green-50 rounded-lg">
                      <h4 className="font-medium text-green-800 mb-1">Budget Estimate</h4>
                      <p className="text-lg font-bold text-green-900">
                        ‚Çπ{optimizedRoute.aiInsights.budgetEstimate.total || 'N/A'}
                      </p>
                      <p className="text-xs text-green-700">Including entry fees, transport & meals</p>
                    </div>
                  )}
                </div>
              )}

              {/* Quick Actions */}
              <div className="bg-white rounded-lg shadow-sm border p-6">
                <h3 className="text-lg font-semibold mb-4">Quick Actions</h3>

                <div className="space-y-3">
                  <button
                    onClick={handleViewDetailedPlan}
                    className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg hover:from-purple-700 hover:to-blue-700 transition-all"
                  >
                    <Brain size={18} />
                    Generate Detailed AI Plan
                  </button>

                  <button className="w-full flex items-center justify-center gap-2 px-4 py-3 border border-blue-600 text-blue-600 rounded-lg hover:bg-blue-50 transition-colors">
                    <MapPin size={18} />
                    View on Map
                  </button>

                  <button className="w-full flex items-center justify-center gap-2 px-4 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors">
                    <CheckCircle size={18} />
                    Save Route
                  </button>

                  <button
                    onClick={() => setShowLiveTracking(!showLiveTracking)}
                    className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg hover:from-green-700 hover:to-blue-700 transition-all"
                  >
                    <Navigation size={18} />
                    {showLiveTracking ? 'Hide' : 'Start'} Live Tracking
                  </button>

                  <button
                    onClick={handleBackToSelection}
                    className="w-full flex items-center justify-center gap-2 px-4 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors"
                  >
                    <Settings size={18} />
                    Modify Selection
                  </button>
                </div>
              </div>

              {/* Route Statistics */}
              <div className="bg-white rounded-lg shadow-sm border p-6">
                <h3 className="text-lg font-semibold mb-4">Route Statistics</h3>

                <div className="grid grid-cols-2 gap-4">
                  <div className="text-center p-3 bg-blue-50 rounded-lg">
                    <div className="text-2xl font-bold text-blue-600">{optimizedRoute.route.length}</div>
                    <div className="text-sm text-blue-800">Places</div>
                  </div>

                  <div className="text-center p-3 bg-green-50 rounded-lg">
                    <div className="text-2xl font-bold text-green-600">
                      {Math.ceil((optimizedRoute.metrics?.totalTime || 0) / 60)}h
                    </div>
                    <div className="text-sm text-green-800">Duration</div>
                  </div>

                  <div className="text-center p-3 bg-orange-50 rounded-lg">
                    <div className="text-2xl font-bold text-orange-600">
                      {optimizedRoute.metrics?.totalDistance?.toFixed(0) || 0}
                    </div>
                    <div className="text-sm text-orange-800">KM</div>
                  </div>

                  <div className="text-center p-3 bg-purple-50 rounded-lg">
                    <div className="text-2xl font-bold text-purple-600">
                      {[...new Set(optimizedRoute.route.map(p => p.city))].length}
                    </div>
                    <div className="text-sm text-purple-800">Cities</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {currentView === 'detailed' && optimizedRoute && (
          <DetailedTripPlanner 
            optimizedRoute={optimizedRoute} 
            routeSettings={routeSettings}
          />
        )}

        {/* Error Display */}
        {error && currentView === 'selection' && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4">
            <div className="flex items-start gap-3">
              <AlertCircle className="text-red-500 flex-shrink-0 mt-0.5" size={20} />
              <div>
                <h4 className="font-medium text-red-800">Optimization Error</h4>
                <p className="text-red-700 mt-1">{error}</p>
                <button
                  onClick={() => {
                    setError(null);
                    setOptimizationStatus(null);
                  }}
                  className="mt-2 text-sm text-red-600 hover:text-red-800 underline"
                >
                  Dismiss
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Loading Overlay */}
        {loading && currentView === 'results' && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg p-8 max-w-md mx-4">
              <div className="text-center">
                <Loader className="mx-auto mb-4 text-blue-600 animate-spin" size={48} />
                <h3 className="text-lg font-semibold text-gray-900 mb-2">Optimizing Your Route</h3>
                <p className="text-gray-600 mb-4">
                  Our AI is analyzing {selectedPlaces.length} places to create the perfect itinerary...
                </p>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div className="bg-blue-600 h-2 rounded-full animate-pulse" style={{ width: '60%' }}></div>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default TripPlannerPage;
--
// API Service Layer for TourWithAI
import axios from 'axios';
import toast from 'react-hot-toast';

// API Configuration
const API_BASE_URL = process.env.NODE_ENV === 'production' 
  ? 'https://your-backend-url.com/api'
  : 'http://localhost:5000/api';

const API_TIMEOUT = 30000; // 30 seconds
const MAX_RETRIES = 3;

// Create axios instance with default config
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: API_TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

// Request interceptor
apiClient.interceptors.request.use(
  (config) => {
    const timestamp = new Date().toISOString();
    console.log(üåê API Request [${timestamp}]: ${config.method?.toUpperCase()} ${config.url});

    // Add request timestamp
    config.metadata = { startTime: Date.now() };
    return config;
  },
  (error) => {
    console.error('API Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor
apiClient.interceptors.response.use(
  (response) => {
    const duration = Date.now() - response.config.metadata.startTime;
    console.log(‚úÖ API Response [${duration}ms]: ${response.config.method?.toUpperCase()} ${response.config.url});
    return response;
  },
  (error) => {
    const duration = error.config?.metadata ? Date.now() - error.config.metadata.startTime : 0;
    console.error(‚ùå API Error [${duration}ms]:, {
      url: error.config?.url,
      method: error.config?.method?.toUpperCase(),
      status: error.response?.status,
      message: error.message,
    });

    // Handle specific error cases
    if (error.code === 'ECONNREFUSED' || error.code === 'NETWORK_ERROR') {
      toast.error('Backend server is not running. Please start the server.');
    } else if (error.response?.status >= 500) {
      toast.error('Server error. Please try again later.');
    } else if (error.response?.status === 429) {
      toast.error('Too many requests. Please wait a moment.');
    }

    return Promise.reject(error);
  }
);

// Utility function for retries
const withRetry = async (fn, retries = MAX_RETRIES) => {
  try {
    return await fn();
  } catch (error) {
    if (retries > 0 && (error.code === 'ECONNREFUSED' || error.response?.status >= 500)) {
      console.log(üîÑ Retrying API call... ${retries} attempts left);
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
      return withRetry(fn, retries - 1);
    }
    throw error;
  }
};

// API Service Object
export const apiService = {
  // Health Check
  async checkHealth() {
    try {
      const response = await withRetry(() => apiClient.get('/health'));
      return response.data;
    } catch (error) {
      throw new Error(Backend connection failed: ${error.message});
    }
  },

  // PLACES API
  async getAllPlaces(filters = {}) {
    try {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== '') {
          params.append(key, value);
        }
      });

      const response = await apiClient.get(/places?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to fetch places: ${error.response?.data?.message || error.message});
    }
  },

  async getPlaceById(id) {
    try {
      const response = await apiClient.get(/places/${id});
      return response.data;
    } catch (error) {
      throw new Error(Failed to fetch place: ${error.response?.data?.message || error.message});
    }
  },

  async searchPlaces(query, filters = {}) {
    try {
      const params = new URLSearchParams({
        q: query,
        ...filters
      });

      const response = await apiClient.get(/places/search?${params});
      return response.data;
    } catch (error) {
      throw new Error(Search failed: ${error.response?.data?.message || error.message});
    }
  },

  async getNearbyPlaces(latitude, longitude, radius = 50, filters = {}) {
    try {
      const params = new URLSearchParams({
        latitude,
        longitude,
        radius,
        ...filters
      });

      const response = await apiClient.get(/places/nearby?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to fetch nearby places: ${error.response?.data?.message || error.message});
    }
  },

  async getPlacesByCategory(category, filters = {}) {
    try {
      const params = new URLSearchParams(filters);
      const response = await apiClient.get(/places/category/${category}?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to fetch places by category: ${error.response?.data?.message || error.message});
    }
  },

  async getPlaceStats() {
    try {
      const response = await apiClient.get('/places/stats');
      return response.data;
    } catch (error) {
      throw new Error(Failed to fetch place statistics: ${error.response?.data?.message || error.message});
    }
  },

  // ROUTE OPTIMIZATION API
  async optimizeRouteWithAlgorithm(payload) {
    try {
      console.log('üöÄ Calling algorithm-based route optimization...');
      console.log('üìä Payload:', {
        placesCount: payload.places?.length,
        optimizationLevel: payload.preferences?.optimizationLevel,
        totalTimeAvailable: payload.constraints?.totalTimeAvailable
      });

      const response = await apiClient.post('/routes/optimize-with-algorithm', payload);

      console.log('‚úÖ Algorithm optimization response:', {
        success: response.data.success,
        algorithm: response.data.algorithm,
        placesOptimized: response.data.route?.length,
        efficiency: response.data.metrics?.efficiency
      });

      return response.data;
    } catch (error) {
      console.error('üí• Algorithm optimization failed:', error);
      throw new Error(Route optimization failed: ${error.response?.data?.message || error.message});
    }
  },

  async getRouteSuggestions(criteria = {}) {
    try {
      const params = new URLSearchParams(criteria);
      const response = await apiClient.get(/routes/suggestions?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to get route suggestions: ${error.response?.data?.message || error.message});
    }
  },

  // TRIP PLANNING API
  async createTrip(tripData) {
    try {
      const response = await apiClient.post('/trips', tripData);
      return response.data;
    } catch (error) {
      throw new Error(Failed to create trip: ${error.response?.data?.message || error.message});
    }
  },

  async optimizeTrip(payload) {
    try {
      const response = await apiClient.post('/trips/optimize', payload);
      return response.data;
    } catch (error) {
      throw new Error(Trip optimization failed: ${error.response?.data?.message || error.message});
    }
  },

  // Add to apiService in src/services/api.js

// Real-time tracking endpoints
async startRealTimeTracking(payload) {
  try {
    const response = await apiClient.post('/trips/start-realtime-tracking', payload);
    return response.data;
  } catch (error) {
    throw new Error(Failed to start tracking: ${error.response?.data?.message || error.message});
  }
},

async updateTripProgress(payload) {
  try {
    const response = await apiClient.put('/trips/update-progress', payload);
    return response.data;
  } catch (error) {
    throw new Error(Failed to update progress: ${error.response?.data?.message || error.message});
  }
},

async getRealTimeUpdates(tripId, currentLocation, lastUpdateTime) {
  try {
    const params = new URLSearchParams({
      tripId,
      currentLocation: JSON.stringify(currentLocation),
      lastUpdateTime
    });
    const response = await apiClient.get(/trips/real-time-updates?${params});
    return response.data;
  } catch (error) {
    throw new Error(Failed to get updates: ${error.response?.data?.message || error.message});
  }
},

  async getTripSuggestions(criteria = {}) {
    try {
      const params = new URLSearchParams(criteria);
      const response = await apiClient.get(/trips/suggestions?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to get trip suggestions: ${error.response?.data?.message || error.message});
    }
  },

  // AI CHAT API
  async chatWithAI(message, context = {}) {
    try {
      const response = await apiClient.post('/chat', { message, context });
      return response.data;
    } catch (error) {
      throw new Error(AI chat failed: ${error.response?.data?.message || error.message});
    }
  },

  async getTravelSuggestions(preferences) {
    try {
      const response = await apiClient.post('/chat/suggestions', preferences);
      return response.data;
    } catch (error) {
      throw new Error(Failed to get travel suggestions: ${error.response?.data?.message || error.message});
    }
  },

  async getPlaceInfo(placeId, question = null) {
    try {
      const response = await apiClient.post('/chat/place-info', { placeId, question });
      return response.data;
    } catch (error) {
      throw new Error(Failed to get place information: ${error.response?.data?.message || error.message});
    }
  },

  // MAP API
  async getMapBounds(filters = {}) {
    try {
      const params = new URLSearchParams(filters);
      const response = await apiClient.get(/map/bounds?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to get map bounds: ${error.response?.data?.message || error.message});
    }
  },

  async getPlacesInBounds(bounds, filters = {}) {
    try {
      const params = new URLSearchParams({
        ...bounds,
        ...filters
      });
      const response = await apiClient.get(/map/places-in-bounds?${params});
      return response.data;
    } catch (error) {
      throw new Error(Failed to get places in bounds: ${error.response?.data?.message || error.message});
    }
  },

  async getOptimizedRoute(payload) {
    try {
      const response = await apiClient.post('/map/optimize-route', payload);
      return response.data;
    } catch (error) {
      throw new Error(Failed to get optimized route: ${error.response?.data?.message || error.message});
    }
  },

  async getClusteredMarkers(params = {}) {
    try {
      const queryParams = new URLSearchParams(params);
      const response = await apiClient.get(/map/clustered-markers?${queryParams});
      return response.data;
    } catch (error) {
      throw new Error(Failed to get clustered markers: ${error.response?.data?.message || error.message});
    }
  },

  async getHeatmapData(params = {}) {
    try {
      const queryParams = new URLSearchParams(params);
      const response = await apiClient.get(/map/heatmap-data?${queryParams});
      return response.data;
    } catch (error) {
      throw new Error(Failed to get heatmap data: ${error.response?.data?.message || error.message});
    }
  },

  async geocodeAddress(address) {
    try {
      const response = await apiClient.get(/map/geocode?q=${encodeURIComponent(address)});
      return response.data;
    } catch (error) {
      throw new Error(Geocoding failed: ${error.response?.data?.message || error.message});
    }
  },

  async reverseGeocode(latitude, longitude) {
    try {
      const response = await apiClient.get(/map/reverse-geocode?lat=${latitude}&lng=${longitude});
      return response.data;
    } catch (error) {
      throw new Error(Reverse geocoding failed: ${error.response?.data?.message || error.message});
    }
  },

  // DISTANCE API
  async calculateDistanceMatrix(origins, destinations) {
    try {
      const response = await apiClient.post('/distance/matrix', { origins, destinations });
      return response.data;
    } catch (error) {
      throw new Error(Distance calculation failed: ${error.response?.data?.message || error.message});
    }
  },

  async calculateDistance(origin, destination) {
    try {
      const response = await apiClient.post('/distance/calculate', { origin, destination });
      return response.data;
    } catch (error) {
      throw new Error(Distance calculation failed: ${error.response?.data?.message || error.message});
    }
  },

  async generateDetailedTripPlan(payload) {
    try {
      console.log('üß† Calling detailed trip plan generation...');
      console.log('üìä Payload:', {
        placesCount: payload.places?.length,
        algorithm: payload.algorithm,
        startTime: payload.preferences?.startTime
      });

      const response = await apiClient.post('/trips/generate-detailed-plan', payload);

      console.log('‚úÖ Detailed plan generation response:', {
        success: response.data.success,
        aiModel: response.data.aiModel,
        hasTimeline: !!response.data.data?.timeline,
        hasCulturalGuide: !!response.data.data?.culturalGuide
      });

      return response.data;
    } catch (error) {
      console.error('üí• Detailed plan generation failed:', error);
      throw new Error(Detailed plan generation failed: ${error.response?.data?.message || error.message});
    }
  },

  // Enhanced route optimization that also prepares for detailed plan
  async optimizeRouteWithAlgorithm(payload) {
    try {
      console.log('üöÄ Calling algorithm-based route optimization...');
      console.log('üìä Payload:', {
        placesCount: payload.places?.length,
        optimizationLevel: payload.preferences?.optimizationLevel,
        totalTimeAvailable: payload.constraints?.totalTimeAvailable,
        startLocation: payload.constraints?.startLocation?.name
      });

      const response = await apiClient.post('/routes/optimize-with-algorithm', payload);

      console.log('‚úÖ Algorithm optimization response:', {
        success: response.data.success,
        algorithm: response.data.algorithm,
        placesOptimized: response.data.route?.length,
        efficiency: response.data.metrics?.efficiency,
        hasAiInsights: !!response.data.aiInsights
      });

      // If optimization is successful, prepare data for potential detailed plan generation
      if (response.data.success && response.data.route) {
        // Store optimization result for detailed plan generation
        response.data._detailedPlanPayload = {
          places: response.data.route,
          preferences: payload.preferences || {},
          routeMetrics: response.data.metrics || {},
          algorithm: response.data.algorithm || 'unknown',
          constraints: payload.constraints || {}
        };
      }

      return response.data;
    } catch (error) {
      console.error('üí• Algorithm optimization failed:', error);
      throw new Error(Route optimization failed: ${error.response?.data?.message || error.message});
    }
  },

  // TRIP PLANNING API - Enhanced
  async createTripWithDetailedPlan(tripData) {
    try {
      // First optimize the route
      const optimizedResult = await this.optimizeRouteWithAlgorithm(tripData);

      if (optimizedResult.success) {
        // Then generate detailed plan
        const detailedPlan = await this.generateDetailedTripPlan(optimizedResult._detailedPlanPayload);

        // Combine both results
        return {
          success: true,
          optimizedRoute: optimizedResult,
          detailedPlan: detailedPlan.data,
          combined: true
        };
      }

      return optimizedResult;
    } catch (error) {
      throw new Error(Complete trip creation failed: ${error.message});
    }
  },

  // Enhanced trip optimization with detailed plan option
  async optimizeTrip(payload, includeDetailedPlan = false) {
    try {
      const response = await apiClient.post('/trips/optimize', payload);

      if (includeDetailedPlan && response.data.success) {
        try {
          const detailedPlan = await this.generateDetailedTripPlan({
            places: response.data.route || [],
            preferences: payload.preferences || {},
            routeMetrics: response.data.metrics || {},
            algorithm: response.data.algorithm || 'unknown'
          });

          response.data.detailedPlan = detailedPlan.data;
        } catch (detailError) {
          console.warn('Failed to generate detailed plan:', detailError);
          // Continue without detailed plan
        }
      }

      return response.data;
    } catch (error) {
      throw new Error(Trip optimization failed: ${error.response?.data?.message || error.message});
    }
  },

  // UTILITY FUNCTIONS
  isOnline() {
    return navigator.onLine;
  },

  async testConnection() {
    try {
      await this.checkHealth();
      return true;
    } catch (error) {
      return false;
    }
  },

  // Cache management
  clearCache() {
    // Clear any cached data if needed
    console.log('üóëÔ∏è API cache cleared');
  },

  // Debug information
  getDebugInfo() {
    return {
      baseURL: API_BASE_URL,
      timeout: API_TIMEOUT,
      maxRetries: MAX_RETRIES,
      isOnline: navigator.onLine,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString()
    };
  }
};

// Enhanced error handling for trip planning
export const handleTripPlanningError = (error) => {
  if (error.message.includes('Gemini')) {
    return {
      type: 'AI_ERROR',
      message: 'AI service is temporarily unavailable. Using fallback planning.',
      fallbackAvailable: true
    };
  }

  if (error.message.includes('optimization')) {
    return {
      type: 'OPTIMIZATION_ERROR',
      message: 'Route optimization failed. Please try with fewer places.',
      suggestion: 'Reduce the number of selected places or adjust time constraints.'
    };
  }

  if (error.message.includes('timeout')) {
    return {
      type: 'TIMEOUT_ERROR',
      message: 'Request timed out. Please try again.',
      suggestion: 'Check your internet connection and try again.'
    };
  }

  return {
    type: 'GENERAL_ERROR',
    message: error.message || 'Something went wrong. Please try again.',
    suggestion: 'Please try again or contact support if the problem persists.'
  };
};

// Trip planning utilities
export const tripPlanningUtils = {
  // Validate trip data before sending to API
  validateTripData(data) {
    const errors = [];

    if (!data.places || !Array.isArray(data.places) || data.places.length === 0) {
      errors.push('At least one place must be selected');
    }

    if (data.places && data.places.length > 20) {
      errors.push('Maximum 20 places allowed');
    }

    if (data.preferences?.startTime && !/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(data.preferences.startTime)) {
      errors.push('Invalid start time format');
    }

    if (data.constraints?.totalTimeAvailable && (data.constraints.totalTimeAvailable < 120 || data.constraints.totalTimeAvailable > 1440)) {
      errors.push('Time available must be between 2-24 hours');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  // Format trip data for API
  formatTripDataForAPI(places, settings) {
    return {
      places: places.map(place => ({
        id: place.id,
        name: place.name,
        category: place.category || 'attraction',
        location: {
          latitude: parseFloat(place.location.latitude),
          longitude: parseFloat(place.location.longitude)
        },
        averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
        rating: parseFloat(place.rating) || 3.5,
        city: place.city || 'Unknown',
        state: place.state || 'Unknown',
        entryFee: place.entryFee || { indian: 0, foreign: 0 },
        description: place.description || '',
        amenities: place.amenities || [],
        bestTimeToVisit: place.bestTimeToVisit || ['morning']
      })),
      preferences: {
        startTime: settings.startTime,
        optimizationLevel: settings.optimizationLevel,
        optimizeFor: settings.preferences?.optimizeFor || 'balanced',
        ...settings.preferences
      },
      constraints: {
        totalTimeAvailable: settings.totalTimeAvailable,
        startDay: new Date().getDay(),
        startLocation: settings.constraints?.startLocation || {
          name: 'Coimbatore Tidal Park',
          latitude: 11.0638,
          longitude: 77.0596
        },
        ...settings.constraints
      }
    };
  },

  // Calculate trip statistics
  calculateTripStats(places) {
    if (!places || places.length === 0) {
      return {
        totalPlaces: 0,
        categories: [],
        cities: [],
        averageRating: 0,
        totalDuration: 0,
        estimatedCost: 0
      };
    }

    const categories = [...new Set(places.map(p => p.category))];
    const cities = [...new Set(places.map(p => p.city))];
    const averageRating = places.reduce((sum, p) => sum + (p.rating || 0), 0) / places.length;
    const totalDuration = places.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0);
    const estimatedCost = places.reduce((sum, p) => sum + (p.entryFee?.indian || p.entryFee?.amount || 0), 0);

    return {
      totalPlaces: places.length,
      categories,
      cities,
      averageRating: Math.round(averageRating * 10) / 10,
      totalDuration,
      estimatedCost
    };
  },

  // Format route metrics for display
  formatRouteMetrics(metrics) {
    if (!metrics) return {};

    return {
      totalTime: Math.ceil((metrics.totalTime || 0) / 60) + ' hours',
      totalDistance: (metrics.totalDistance || 0).toFixed(1) + ' km',
      efficiency: (metrics.efficiency || 0).toFixed(1) + '%',
      placesVisited: metrics.placesVisited || 0,
      estimatedCost: '‚Çπ' + (metrics.totalCost || 0)
    };
  }
};

// Export enhanced API client configuration
export const enhancedApiConfig = {
  ...apiClient.defaults,
  timeout: 45000, // Increased timeout for detailed plan generation
  retries: 2,
  retryDelay: 1000
};

// Detailed plan generation status tracking
export const detailedPlanStatus = {
  IDLE: 'idle',
  GENERATING: 'generating',
  SUCCESS: 'success',
  ERROR: 'error',
  FALLBACK: 'fallback'
};

// Export axios instance for direct use if needed
export { apiClient };

// Export API base URL for other modules
export { API_BASE_URL };
--
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { Toaster } from 'react-hot-toast';
import { apiService } from './services/api';

// Components
import Navbar from './components/Navbar';
import HomePage from './pages/HomePage';
import TripPlannerPage from './pages/TripPlannerPage';
import AIAssistantPage from './pages/AIAssistantPage';
import MapViewPage from './pages/MapViewPage';
import PlacesPage from './pages/PlacesPage';
import LoadingSpinner from './components/LoadingSpinner';

// Styles
import './App.css';

function App() {
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [connectionError, setConnectionError] = useState(null);

  // Check backend connection
  const checkConnection = async () => {
    setIsLoading(true);
    setConnectionError(null);

    try {
      console.log('üîÑ Checking backend connection...');
      const response = await apiService.checkHealth();

      if (response.success) {
        setIsConnected(true);
        console.log('‚úÖ Backend connected successfully');
        console.log(üìç Places in database: ${response.placesInDatabase});
      } else {
        throw new Error('Backend health check failed');
      }
    } catch (error) {
      console.error('‚ùå Backend connection failed:', error);
      setIsConnected(false);
      setConnectionError(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Initial connection check
  useEffect(() => {
    checkConnection();
  }, []);

  // Show loading screen while checking connection
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <h2 className="mt-4 text-xl font-semibold text-gray-700">
            Connecting to AI Backend...
          </h2>
          <p className="mt-2 text-gray-500">
            Setting up your intelligent travel assistant
          </p>
        </div>
      </div>
    );
  }

  return (
    <Router>
      <div className="App min-h-screen bg-gray-50">
        {/* Toast Notifications */}
        <Toaster
          position="top-right"
          toastOptions={{
            duration: 4000,
            style: {
              background: '
#363636',
              color: '#fff',
            },
            success: {
              duration: 3000,
              iconTheme: {
                primary: '
#4ade80',
                secondary: '#fff',
              },
            },
            error: {
              duration: 5000,
              iconTheme: {
                primary: '
#ef4444',
                secondary: '#fff',
              },
            },
          }}
        />

        {/* Navigation */}
        <Navbar isConnected={isConnected} />

        {/* Main Content /}
        <main className="pb-6">
          <Routes>
            {/ Home Page */}
            <Route 
              path="/" 
              element={
                <HomePage 
                  isConnected={isConnected} 
                  onRetry={checkConnection}
                />
              } 
            />

            {/* Trip Planner - Main Feature */}
            <Route 
              path="/trip-planner" 
              element={
                <TripPlannerPage 
                  isConnected={isConnected} 
                  onRetry={checkConnection}
                />
              } 
            />

            {/* AI Assistant */}
            <Route 
              path="/ai-assistant" 
              element={
                <AIAssistantPage 
                  isConnected={isConnected} 
                  onRetry={checkConnection}
                />
              } 
            />

            {/* Map View */}
            <Route 
              path="/map" 
              element={
                <MapViewPage 
                  isConnected={isConnected} 
                  onRetry={checkConnection}
                />
              } 
            />

            {/* Places Explorer */}
            <Route 
              path="/places" 
              element={
                <PlacesPage 
                  isConnected={isConnected} 
                  onRetry={checkConnection}
                />
              } 
            />

            {/* 404 Not Found /}
            <Route 
              path="" 
              element={
                <div className="min-h-screen flex items-center justify-center">
                  <div className="text-center">
                    <h1 className="text-4xl font-bold text-gray-900">404</h1>
                    <p className="mt-2 text-gray-600">Page not found</p>
                    <a 
                      href="/" 
                      className="mt-4 inline-block px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                    >
                      Go Home
                    </a>
                  </div>
                </div>
              } 
            />
          </Routes>
        </main>

        {/* Footer */}
        <footer className="bg-white border-t border-gray-200 py-8 mt-16">
          <div className="max-w-7xl mx-auto px-6">
            <div className="text-center">
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                Tour With AI
              </h3>
              <p className="text-gray-600 mb-4">
                Discover South India with AI Intelligence
              </p>

              {/* Connection Status */}
              <div className="flex items-center justify-center gap-2 text-sm">
                <div className={w-3 h-3 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}}></div>
                <span className={isConnected ? 'text-green-600' : 'text-red-600'}>
                  {isConnected ? 'AI Backend Connected' : 'Backend Disconnected'}
                </span>
              </div>

              <div className="mt-4 text-xs text-gray-500">
                <p>Powered by Advanced AI Algorithms & OpenStreetMap</p>
                <p className="mt-1">¬© 2024 Tour With AI. All rights reserved.</p>
              </div>
            </div>
          </div>
        </footer>
      </div>
    </Router>
  );
}

export default App;
---
now take 10 district 1.coimbatore tidal park,2.thirunelveli,3.tanjore,4.allepey(kerela),5.chennai,6.salem,7.erode,8.kanniyakumari,9.banglore(karnataka),10.mysore->keep an option in the place selection page to choose the user location among these 10 places and what place the user is selecting ,the trip should start from that specific place and based on the user starting of the trip and the number of hours the user decided to spend in tour ,the tour plan should be given and need a live date and time update in the website like It should behave like a google map but with an extra feature of ai to chat and a detailed trip plan from start to end all the minute things should be suggested in a clear way so that the user follows only the things provided by our trip planner .so for a trip from leaving the home to completing the trip all should be organised by the ai and the algorithm in a detailed manner
--
clearly analyse the codesand carefully generate the code
---
// backend/controllers/detailedTripController.js - FIXED VERSION

const { GoogleGenerativeAI } = require('@google/generative-ai');
const Place = require('../models/Place');
const DistanceCalculator = require('../utils/distanceCalculator');

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const distanceCalculator = new DistanceCalculator();

class DetailedTripController {
  constructor() {
    this.model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

    // Bind methods to preserve 'this' context
    this.generateDetailedPlan = this.generateDetailedPlan.bind(this);
    this.generatePersonalizedPlan = this.generatePersonalizedPlan.bind(this);
    this.calculateRealTimeSchedule = this.calculateRealTimeSchedule.bind(this);
    this.buildEnhancedPrompt = this.buildEnhancedPrompt.bind(this);
    this.parseAndEnhanceAIResponse = this.parseAndEnhanceAIResponse.bind(this);
    this.generateStructuredFallbackPlan = this.generateStructuredFallbackPlan.bind(this);
  }

  /**
   * MAIN ENDPOINT: Generate personalized detailed trip plan based on user selections
   */
  async generateDetailedPlan(req, res) {
    try {
      const { places, preferences, routeMetrics, algorithm, userProfile } = req.body;

      // Get comprehensive current date/time for real-time planning
      const currentDateTime = this.getCurrentDateTimeContext();

      console.log('üß† Generating PERSONALIZED detailed trip plan...');
      console.log(üìÖ Real-Time Context: ${currentDateTime.formatted});
      console.log(üìç User Selected Places: ${places?.length});
      console.log(‚öôÔ∏è Algorithm Used: ${algorithm});
      console.log(üë§ User Profile: ${userProfile ? 'Available' : 'Standard'});

      // Enhanced input validation
      if (!places || !Array.isArray(places) || places.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'At least one place must be selected for trip planning'
        });
      }

      if (places.length > 25) {
        return res.status(400).json({
          success: false,
          message: 'Maximum 25 places allowed for detailed planning'
        });
      }

      // Calculate real-time travel schedule with actual distances
      const realTimeSchedule = await this.calculateRealTimeSchedule(
        places, 
        preferences, 
        currentDateTime
      );

      // Generate comprehensive personalized plan using Gemini AI
      const personalizedPlan = await this.generatePersonalizedPlan(
        places, 
        preferences, 
        routeMetrics, 
        algorithm,
        currentDateTime,
        realTimeSchedule,
        userProfile
      );

      // Enhanced response with all features
      const response = {
        success: true,
        data: {
          ...personalizedPlan,

          // Real-time context
          realTimeContext: currentDateTime,

          // Interactive features
          interactiveFeatures: {
            mapView: {
              enabled: true,
              startLocation: {
                name: 'Coimbatore Tidal Park',
                coordinates: { lat: 11.0638, lng: 77.0596 }
              },
              waypoints: places.map((place, index) => ({
                id: place.id,
                name: place.name,
                coordinates: { 
                  lat: place.location.latitude, 
                  lng: place.location.longitude 
                },
                order: index + 1,
                category: place.category,
                scheduledTime: realTimeSchedule.timeline[index + 1]?.arrivalTime
              })),
              routePolyline: realTimeSchedule.routeCoordinates
            },

            tripTracking: {
              enabled: true,
              checkpoints: realTimeSchedule.timeline.map((item, index) => ({
                id: item.id || checkpoint_${index},
                name: item.name,
                type: item.type || 'destination',
                coordinates: item.coordinates,
                scheduledTime: item.scheduledTime,
                status: 'pending',
                realTimeETA: item.realTimeETA
              })),
              autoProgress: {
                enabled: true,
                interval: 40000, // 40 seconds
                smartProgression: true
              }
            }
          },

          // Personal recommendations
          personalizedRecommendations: personalizedPlan.personalizedRecommendations || {},

          // Live updates capability
          liveUpdates: {
            weatherIntegration: true,
            trafficUpdates: true,
            crowdLevelAlerts: true,
            lastUpdated: currentDateTime.timestamp
          }
        },

        // Metadata
        generatedAt: new Date().toISOString(),
        aiModel: 'gemini-1.5-flash-enhanced',
        algorithm: algorithm || 'personalized-optimization',
        userSpecific: true,
        realTimePlanning: true
      };

      console.log('‚úÖ Personalized detailed plan generated successfully');
      res.status(200).json(response);

    } catch (error) {
      console.error('üí• Detailed trip plan generation failed:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate personalized trip plan',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  }

  /**
   * Generate comprehensive personalized plan using Gemini AI
   */
  async generatePersonalizedPlan(places, preferences, routeMetrics, algorithm, currentDateTime, realTimeSchedule, userProfile) {
    try {
      // Build enhanced prompt with all user-specific data
      const prompt = this.buildEnhancedPrompt(
        places, 
        preferences, 
        routeMetrics, 
        algorithm, 
        currentDateTime, 
        realTimeSchedule, 
        userProfile
      );

      console.log('ü§ñ Sending enhanced request to Gemini AI for personalized planning...');
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const aiResponse = response.text();

      console.log('‚úÖ Gemini AI personalized response received');

      // Parse and enhance the AI response
      const structuredPlan = this.parseAndEnhanceAIResponse(
        aiResponse, 
        places, 
        preferences, 
        realTimeSchedule, 
        currentDateTime
      );

      return structuredPlan;

    } catch (error) {
      console.error('üö® Gemini AI personalized planning failed:', error);
      return this.generateStructuredFallbackPlan(
        places, 
        preferences, 
        realTimeSchedule, 
        currentDateTime
      );
    }
  }

  /**
   * Fixed parseAndEnhanceAIResponse method with robust JSON parsing
   */
  parseAndEnhanceAIResponse(aiResponse, places, preferences, realTimeSchedule, currentDateTime) {
    try {
      // Multiple JSON extraction strategies
      let parsedPlan = null;

      // Strategy 1: Look for the main JSON block
      let jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          parsedPlan = JSON.parse(jsonMatch[0]);
        } catch (e) {
          console.warn('Strategy 1 failed, trying strategy 2...');
        }
      }

      // Strategy 2: Look for JSON between code blocks
      if (!parsedPlan) {
        const codeBlockMatch = aiResponse.match(/json\s*([\s\S]*?)\s*/i);
        if (codeBlockMatch) {
          try {
            parsedPlan = JSON.parse(codeBlockMatch[1]);
          } catch (e) {
            console.warn('Strategy 2 failed, trying strategy 3...');
          }
        }
      }

      // Strategy 3: Clean and attempt to fix common JSON issues
      if (!parsedPlan && jsonMatch) {
        try {
          let cleanedJson = jsonMatch[0]
            .replace(/,\s}/g, '}')  // Remove trailing commas before }
            .replace(/,\s]/g, ']')  // Remove trailing commas before ]
            .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // Remove control characters
            .replace(/\n/g, ' ')     // Replace newlines with spaces
            .replace(/\r/g, '')      // Remove carriage returns
            .replace(/\t/g, ' ')     // Replace tabs with spaces
            .replace(/\s+/g, ' ');   // Collapse multiple spaces

          parsedPlan = JSON.parse(cleanedJson);
        } catch (e) {
          console.warn('Strategy 3 failed, using fallback...');
        }
      }

      // If all JSON parsing failed, use fallback
      if (!parsedPlan) {
        console.error('All JSON parsing strategies failed, using structured fallback');
        throw new Error('JSON parsing failed - using fallback plan');
      }

      // Enhance the parsed plan with interactive features
      const enhancedPlan = {
        ...parsedPlan,

        // Add map view functionality
        mapViewData: {
          enabled: true,
          startLocation: {
            name: 'Coimbatore Tidal Park',
            coordinates: { lat: 11.0638, lng: 77.0596 }
          },
          waypoints: places.map((place, index) => ({
            id: place.id,
            name: place.name,
            coordinates: { lat: place.location.latitude, lng: place.location.longitude },
            order: index + 1,
            scheduledTime: realTimeSchedule.timeline[index + 1]?.arrivalTime
          })),
          routePolyline: realTimeSchedule.routeCoordinates,
          realTimeTracking: true
        },

        // Add trip tracking functionality
        tripTracking: {
          enabled: true,
          startTripEndpoint: '/api/trips/start-realtime-tracking',
          updateProgressEndpoint: '/api/trips/update-progress',
          completeTrip: '/api/trips/complete-realtime-trip',
          autoProgress: {
            enabled: true,
            interval: 40000,
            smartProgression: true
          }
        },

        // Real-time context
        realTimeContext: currentDateTime,
        lastUpdated: new Date().toISOString()
      };

      console.log('‚úÖ AI response parsed and enhanced successfully');
      return enhancedPlan;

    } catch (error) {
      console.error('Error parsing AI response:', error);
      console.log('üîÑ Falling back to structured plan generation...');

      // Use fallback plan generation
      return this.generateStructuredFallbackPlan(places, preferences, realTimeSchedule, currentDateTime);
    }
  }

  /**
   * Generate structured fallback plan when AI parsing fails
   */
  generateStructuredFallbackPlan(places, preferences, realTimeSchedule, currentDateTime) {
    console.log('‚ö†Ô∏è Using structured fallback plan generation');

    try {
      const plan = {
        summary: {
          title: Personalized ${places.length}-Destination Journey,
          description: A tailored itinerary for your selected places, optimized for ${currentDateTime.dayOfWeek} ${currentDateTime.season} travel,
          personalizedHighlights: [
            'Custom route based on your selected places',
            Real-time planning for ${currentDateTime.formatted},
            'Personalized recommendations for each destination',
            'Interactive map and trip tracking enabled'
          ],
          tripPersonality: Customized for ${preferences?.userProfile?.travelStyle || 'explorer'} traveling ${preferences?.groupSize === 1 ? 'solo' : 'in group of ' + (preferences?.groupSize || 'multiple people')},
          uniqueExperiences: places.map(place => Explore ${place.name} - your personal choice),
          realTimeAdvice: Optimized for ${currentDateTime.dayOfWeek} ${currentDateTime.season} travel with live weather and crowd considerations
        },

        timeline: this.buildFallbackTimeline(places, realTimeSchedule, currentDateTime, preferences?.userProfile),

        personalizedRecommendations: {
          forYourInterests: this.buildInterestRecommendations(preferences?.userProfile?.interests, places),
          forYourTravelStyle: this.getRecommendationsForTravelStyle(preferences?.userProfile?.travelStyle, places),
          forYourGroup: this.getRecommendationsForGroupSize(preferences?.groupSize || 1, places),
          personalizedTiming: [
            Start at ${preferences?.startTime || '09:00'} - perfect for your schedule,
            this.getPersonalizedTimingTips(currentDateTime, preferences?.userProfile)
          ],
          budgetOptimization: this.getBudgetOptimizationTips(preferences?.budget, places)
        },

        personalizedLogistics: {
          transportationForYou: {
            recommended: this.getPersonalizedTransportation(preferences?.userProfile, places),
            alternatives: this.getTransportAlternatives(preferences?.userProfile),
            personalizedAdvice: this.getTransportPersonalizedAdvice(preferences?.userProfile, preferences?.groupSize || 1)
          },
          accommodationSuggestions: {
            personalizedOptions: this.getPersonalizedAccommodation(preferences?.userProfile, preferences?.budget),
            bookingStrategy: this.getBookingStrategy(currentDateTime, preferences?.userProfile)
          },
          personalizedPacking: {
            essentials: this.getPersonalizedPackingList(preferences?.userProfile, currentDateTime).split(',').map(item => item.trim()),
            seasonalItems: this.getSeasonalPackingItems(currentDateTime),
            personalPreferences: this.getPersonalPackingPreferences(preferences?.userProfile)
          },
          personalizedSafetyTips: this.getPersonalizedSafetyTips(preferences?.userProfile, preferences?.groupSize || 1, places)
        },

        realTimeFeatures: {
          liveMapIntegration: {
            enabled: true,
            startLocation: { name: "Coimbatore Tidal Park", coordinates: { lat: 11.0638, lng: 77.0596 } },
            waypoints: places.map(place => ({
              name: place.name,
              coordinates: { lat: place.location.latitude, lng: place.location.longitude }
            })),
            realTimeRouting: true,
            trafficUpdates: true
          },
          tripTracking: {
            autoProgress: true,
            checkpointNotifications: true,
            realTimeETA: true,
            smartRerouting: true
          },
          liveUpdates: {
            weatherAlerts: true,
            crowdLevelUpdates: true,
            specialEventNotifications: true,
            localRecommendations: true
          }
        },

        interactiveFeatures: {
          smartCheckpoints: this.buildSmartCheckpoints(realTimeSchedule, preferences?.userProfile),
          personalizedChallenges: this.getPersonalizedChallenges(places, preferences?.userProfile)
        },

        metadata: {
          personalizationLevel: "Fallback",
          userSpecific: true,
          realTimePlanning: true,
          basedOnUserSelections: true,
          generatedAt: new Date().toISOString(),
          validUntil: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
          aiModel: "fallback-structured",
          algorithm: algorithm || 'nearestNeighbor',
          planningContext: currentDateTime.planningTimeDescription,
          fallbackUsed: true
        }
      };

      console.log('‚úÖ Structured fallback plan generated successfully');
      return plan;

    } catch (error) {
      console.error('üí• Even fallback plan generation failed:', error);

      // Ultra-simple fallback
      return {
        summary: {
          title: 'Basic Trip Plan',
          description: Visit ${places.length} selected destinations,
          personalizedHighlights: ['Custom route', 'Your selected places'],
          tripPersonality: 'Basic itinerary',
          uniqueExperiences: places.map(p => Visit ${p.name}),
          realTimeAdvice: 'Basic travel recommendations'
        },
        timeline: places.map((place, index) => ({
          time: ${9 + index * 2}:00,
          place: { name: place.name, city: place.city },
          duration: place.averageVisitDuration || 90,
          activities: ['Explore and enjoy the location'],
          personalizedTips: ['Take your time', 'Enjoy the experience']
        })),
        personalizedRecommendations: {
          general: ['Start early', 'Carry water', 'Take photos']
        },
        metadata: {
          personalizationLevel: "Minimal",
          fallbackUsed: true,
          errorRecovery: true
        }
      };
    }
  }

  /**
   * Build fallback timeline when AI parsing fails
   */
  buildFallbackTimeline(places, realTimeSchedule, currentDateTime, userProfile) {
    const timeline = [];

    // Add start location
    timeline.push({
      time: realTimeSchedule.timeline[0]?.scheduledTime || '09:00',
      endTime: realTimeSchedule.timeline[0]?.endTime || '09:15',
      place: {
        name: "Coimbatore Tidal Park",
        type: "start_location",
        coordinates: { lat: 11.0638, lng: 77.0596 }
      },
      duration: 15,
      activities: [
        "Final preparation and departure checklist",
        "Weather check and route confirmation",
        "Personal travel ritual"
      ],
      personalizedTips: [
        Pack according to ${currentDateTime.season} season,
        "Download offline maps for selected destinations",
        "Carry essentials for the journey"
      ],
      realTimeUpdate: Current weather: ${currentDateTime.weatherCondition},
      travel: realTimeSchedule.timeline[1] ? {
        toNext: realTimeSchedule.timeline[1].name,
        duration: realTimeSchedule.timeline[1].travelTime || 45,
        distance: ${realTimeSchedule.timeline[1].travelDistance || 25}km,
        mode: "private_vehicle"
      } : null
    });

    // Add each place with fallback data
    places.forEach((place, index) => {
      const scheduleItem = realTimeSchedule.timeline[index + 1] || {
        arrivalTime: ${9 + (index + 1) * 2}:00,
        departureTime: ${9 + (index + 1) * 2 + 1}:30,
        duration: place.averageVisitDuration || 90
      };

      const timelineItem = {
        time: scheduleItem.arrivalTime,
        endTime: scheduleItem.departureTime,
        place: {
          name: place.name,
          city: place.city,
          state: place.state,
          category: place.category,
          rating: place.rating,
          coordinates: { 
            lat: place.location?.latitude || 11.0168, 
            lng: place.location?.longitude || 76.9558 
          },
          personalRelevance: this.getPersonalRelevance(place, userProfile)
        },
        duration: place.averageVisitDuration || 90,
        personalizedActivities: this.generatePersonalizedActivities(place, userProfile),
        culturalInsights: this.generateCulturalInsights(place, userProfile),
        personalizedTips: this.generatePersonalizedTips(place, userProfile, currentDateTime),
        photographyRecommendations: this.generatePhotographyTips(place, currentDateTime),
        personalizedFoodRecommendations: this.generatePersonalizedFoodRecommendations(place, userProfile),
        weatherConsiderations: [
          ${currentDateTime.season} season: ${this.getSeasonalAdvice(place, currentDateTime)},
          this.getWeatherSpecificAdvice(place, currentDateTime)
        ],
        entryInfo: {
          fee: place.entryFee?.indian || place.entryFee?.amount || 0,
          currency: "INR",
          personalizedTicketAdvice: this.getPersonalizedTicketAdvice(place, userProfile),
          openingHours: this.getRealTimeOpeningHours(place, currentDateTime)
        }
      };

      // Add travel info if not the last place
      if (index < places.length - 1) {
        timelineItem.travel = {
          toNext: places[index + 1].name,
          duration: 45,
          distance: "25km",
          personalizedRoute: this.getPersonalizedRoute(place, places[index + 1], userProfile),
          scenicStops: this.getScenicStops(place, places[index + 1])
        };
      }

      timeline.push(timelineItem);
    });

    return timeline;
  }

  /**
   * Fixed buildEnhancedPrompt method with simpler JSON structure
   */
  buildEnhancedPrompt(places, preferences, routeMetrics, algorithm, currentDateTime, realTimeSchedule, userProfile) {
    const startTime = preferences?.startTime || currentDateTime.time;
    const totalHours = Math.ceil((preferences?.totalTimeAvailable || 480) / 60);
    const budget = preferences?.budget || null;
    const groupSize = preferences?.groupSize || 1;

    // Simplified response structure to avoid JSON parsing issues
    const responseExample = {
      summary: {
        title: "Trip title here",
        description: "Trip description here",
        personalizedHighlights: ["highlight 1", "highlight 2"],
        tripPersonality: "trip personality here"
      },
      timeline: [
        {
          time: "09:00",
          place: { name: "Place name", city: "City" },
          duration: 90,
          activities: ["Activity 1", "Activity 2"],
          personalizedTips: ["Tip 1", "Tip 2"]
        }
      ],
      personalizedRecommendations: {
        forYourInterests: ["Recommendation 1", "Recommendation 2"]
      }
    };

    const prompt = `You are an expert AI travel planner. Create a comprehensive, detailed trip plan for the user's selected places.

REAL-TIME CONTEXT:
‚Ä¢ Current Date/Time: ${currentDateTime.formatted} (${currentDateTime.dayOfWeek})
‚Ä¢ Season: ${currentDateTime.season}
‚Ä¢ Weather: ${currentDateTime.weatherCondition}

USER'S SELECTED PLACES:
${places.map((place, index) => ${index + 1}. ${place.name} (${place.city}) - ${place.category} - Rating: ${place.rating}/5).join('\n')}

USER PREFERENCES:
‚Ä¢ Start Time: ${startTime}
‚Ä¢ Duration: ${totalHours} hours
‚Ä¢ Budget: ${budget ? '‚Çπ' + budget : 'Flexible'}
‚Ä¢ Group Size: ${groupSize}

IMPORTANT: Return ONLY valid JSON in this exact format:
${JSON.stringify(responseExample, null, 2)}

Generate a complete trip plan with all timeline items, tips, and recommendations. Ensure all JSON is properly formatted with no trailing commas or syntax errors.`;

    return prompt;
  }

  /**
   * Calculate real-time schedule with actual distances and timing
   */
  async calculateRealTimeSchedule(places, preferences, currentDateTime) {
    const schedule = {
      timeline: [],
      routeCoordinates: [],
      totalDuration: 0,
      totalDistance: 0
    };

    const startTime = preferences?.startTime || currentDateTime.time;
    const startDateTime = this.parseTimeToDateTime(startTime, currentDateTime);
    let currentTime = new Date(startDateTime);

    // Start location
    const tidalPark = {
      id: 'tidal_park_start',
      name: 'Coimbatore Tidal Park',
      type: 'start',
      coordinates: { lat: 11.0638, lng: 77.0596 },
      scheduledTime: this.formatDateTime(currentTime),
      endTime: this.formatDateTime(new Date(currentTime.getTime() + 15 * 60000)),
      duration: 15
    };

    schedule.timeline.push(tidalPark);
    schedule.routeCoordinates.push([11.0638, 77.0596]);
    currentTime = new Date(currentTime.getTime() + 15 * 60000);

    // Process each place with error handling
    for (let i = 0; i < places.length; i++) {
      const place = places[i];
      let travelTime = 45; // Default fallback
      let travelDistance = 25; // Default fallback

      try {
        // Try to calculate actual travel time and distance
        const prevLocation = i === 0 ? 
          { latitude: 11.0638, longitude: 77.0596 } : 
          places[i - 1].location;

        if (prevLocation && place.location) {
          const travelData = await distanceCalculator.calculateDrivingDistance(
            { lat: prevLocation.latitude, lng: prevLocation.longitude },
            { lat: place.location.latitude, lng: place.location.longitude }
          );

          travelTime = travelData.duration || 45;
          travelDistance = travelData.distance || 25;
        }
      } catch (error) {
        console.warn(Error calculating travel for ${place.name}:, error.message);
        // Use fallback values
      }

      // Add travel time
      currentTime = new Date(currentTime.getTime() + travelTime * 60000);

      const visitDuration = place.averageVisitDuration || 90;
      const arrivalTime = new Date(currentTime);
      const departureTime = new Date(currentTime.getTime() + visitDuration * 60000);

      const scheduleItem = {
        id: place.id,
        name: place.name,
        type: 'destination',
        order: i + 1,
        coordinates: { 
          lat: place.location?.latitude || 11.0168, 
          lng: place.location?.longitude || 76.9558 
        },
        scheduledTime: this.formatDateTime(arrivalTime),
        arrivalTime: this.formatDateTime(arrivalTime),
        departureTime: this.formatDateTime(departureTime),
        duration: visitDuration,
        travelTime,
        travelDistance,
        trafficCondition: this.getTrafficCondition(currentDateTime.dayOfWeek, currentDateTime.hour),
        expectedCrowdLevel: this.getCrowdLevel(place.category, currentDateTime.dayOfWeek, currentDateTime.hour)
      };

      schedule.timeline.push(scheduleItem);
      schedule.routeCoordinates.push([
        place.location?.latitude || 11.0168, 
        place.location?.longitude || 76.9558
      ]);
      schedule.totalDistance += travelDistance;

      currentTime = departureTime;
    }

    schedule.totalDuration = Math.round((currentTime - startDateTime) / (1000 * 60));
    return schedule;
  }

  // HELPER METHODS

  getCurrentDateTimeContext() {
    const now = new Date();
    const istOffset = 5.5 * 60 * 60 * 1000; // IST is UTC+5:30
    const istTime = new Date(now.getTime() + istOffset);

    return {
      timestamp: now.getTime(),
      date: istTime.toISOString().split('T')[0],
      time: istTime.toTimeString().split(' ')[0].substring(0, 5),
      hour: istTime.getHours(),
      dayOfWeek: istTime.toLocaleDateString('en-US', { weekday: 'long' }),
      formatted: istTime.toLocaleString('en-IN', { 
        timeZone: 'Asia/Kolkata',
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit'
      }),
      season: this.getCurrentSeason(istTime),
      weatherCondition: this.getWeatherCondition(istTime),
      localEvents: this.getLocalEvents(istTime),
      planningTimeDescription: this.getPlanningTimeDescription(istTime)
    };
  }

  getCurrentSeason(date) {
    const month = date.getMonth() + 1;
    if (month >= 10 || month <= 2) return 'Winter';
    if (month >= 3 && month <= 5) return 'Summer';
    if (month >= 6 && month <= 9) return 'Monsoon';
    return 'Pleasant';
  }

  getWeatherCondition(date) {
    const season = this.getCurrentSeason(date);
    const hour = date.getHours();

    if (season === 'Monsoon') return hour < 18 ? 'Partly cloudy with rain chances' : 'Evening showers possible';
    if (season === 'Summer') return hour > 10 && hour < 16 ? 'Hot and sunny' : 'Warm weather';
    return 'Pleasant weather';
  }

  getLocalEvents(date) {
    const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'long' });
    if (dayOfWeek === 'Friday' || dayOfWeek === 'Saturday') return 'Weekend activities, temple festivities';
    if (dayOfWeek === 'Sunday') return 'Weekend temple crowds, family outings';
    return 'Regular weekday activities';
  }

  getPlanningTimeDescription(date) {
    const hour = date.getHours();
    if (hour < 6) return 'Early morning planning - great for sunrise trips';
    if (hour < 12) return 'Morning planning - perfect timing for today\'s trip';
    if (hour < 16) return 'Afternoon planning - consider tomorrow\'s early start';
    if (hour < 20) return 'Evening planning - ideal for next day preparation';
    return 'Night planning - early morning start recommended';
  }

  parseTimeToDateTime(timeStr, currentDateTime) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    const date = new Date(currentDateTime.timestamp);
    date.setHours(hours, minutes, 0, 0);

    if (date <= new Date()) {
      date.setDate(date.getDate() + 1);
    }

    return date;
  }

  formatDateTime(date) {
    return date.toLocaleString('en-IN', {
      timeZone: 'Asia/Kolkata',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  }

  getTrafficCondition(dayOfWeek, hour) {
    if (['Saturday', 'Sunday'].includes(dayOfWeek)) return 'Light weekend traffic';
    if (hour >= 8 && hour <= 10) return 'Morning rush hour';
    if (hour >= 17 && hour <= 19) return 'Evening rush hour';
    return 'Normal traffic';
  }

  getCrowdLevel(category, dayOfWeek, hour) {
    if (category === 'temple' && dayOfWeek === 'Sunday') return 'High (Sunday prayers)';
    if (category === 'heritage' && ['Saturday', 'Sunday'].includes(dayOfWeek)) return 'High (weekend tourists)';
    if (hour >= 10 && hour <= 16) return 'Moderate (daytime visitors)';
    return 'Low to moderate';
  }

  // PERSONALIZATION HELPER METHODS

  getPersonalRelevance(place, userProfile) {
    let relevance = 'High - personally selected by you';

    if (userProfile?.interests && userProfile.interests.includes(place.category)) {
      relevance = 'Extremely High - matches your interests perfectly';
    }

    if (place.rating && place.rating >= 4.5) {
      relevance += ' (Top-rated destination)';
    }

    return relevance;
  }

  generatePersonalizedActivities(place, userProfile) {
    const baseActivities = this.getBaseActivities(place);
    const personalizedActivities = [...baseActivities];

    if (userProfile?.interests?.includes('photography')) {
      personalizedActivities.push('Dedicated photography session with best angles');
    }

    if (userProfile?.interests?.includes('history') && ['temple', 'heritage', 'fort'].includes(place.category)) {
      personalizedActivities.push('Deep dive into historical significance and stories');
    }

    if (userProfile?.interests?.includes('spirituality') && place.category === 'temple') {
      personalizedActivities.push('Participate in prayer rituals and meditation');
    }

    return personalizedActivities.slice(0, 4);
  }

  getBaseActivities(place) {
    const activities = {
      'temple': ['Explore sacred architecture', 'Learn about religious significance', 'Observe prayer ceremonies'],
      'palace': ['Royal chambers exploration', 'Palace museum visit', 'Garden walkthrough'],
      'heritage': ['Archaeological site tour', 'Historical significance learning', 'Ancient architecture study'],
      'fort': ['Rampart walk with views', 'Defense structure exploration', 'Historical battle stories'],
      'hill-station': ['Scenic viewpoint visits', 'Nature trail walking', 'Fresh air and relaxation'],
      'beach': ['Coastal walk and relaxation', 'Local fishing culture', 'Sunset/sunrise viewing']
    };

    return activities[place.category] || ['Sightseeing and exploration', 'Cultural learning', 'Photography'];
  }

  generateCulturalInsights(place, userProfile) {
    const insights = [];

    switch (place.category) {
      case 'temple':
        insights.push(${place.name} represents ancient South Indian temple architecture);
        insights.push('Sacred site with centuries of continuous worship');
        break;
      case 'heritage':
        insights.push(UNESCO World Heritage site with unique historical significance);
        insights.push('Witness to multiple dynasties and cultural periods');
        break;
      case 'palace':
        insights.push(Former royal residence showcasing architectural grandeur);
        insights.push('Royal lifestyle and courtly traditions preserved');
        break;
      case 'fort':
        insights.push(Strategic military fortification with panoramic views);
        insights.push('Stories of ancient battles and defense strategies');
        break;
      default:
        insights.push(${place.name} offers unique cultural experiences);
        insights.push('Rich local traditions and customs');
    }

    if (userProfile?.interests?.includes('history')) {
      insights.push('Perfect for history enthusiasts like yourself');
    }

    return insights.slice(0, 3);
  }

  generatePersonalizedTips(place, userProfile, currentDateTime) {
    const tips = [];

    // Base tips for place category
    if (place.category === 'temple') {
      tips.push('Remove footwear before entering temple premises');
      tips.push('Dress modestly - avoid shorts and sleeveless tops');
    }

    // Personalized based on user profile
    if (userProfile?.accessibilityNeeds?.wheelchairAccess) {
      tips.push(this.getAccessibilityTip(place));
    }

    if (userProfile?.groupSize > 1) {
      tips.push(For groups: designate meeting points);
    }

    // Weather-specific tips
    if (currentDateTime.season === 'Summer') {
      tips.push('Carry water and sun protection');
      tips.push('Best visited during cooler hours');
    }

    if (currentDateTime.season === 'Monsoon') {
      tips.push('Carry rain gear and wear non-slip footwear');
    }

    return tips.slice(0, 4);
  }

  getAccessibilityTip(place) {
    if (place.category === 'temple') return 'Check for ramp access and wheelchair-friendly paths';
    if (place.category === 'fort') return 'Some areas may have steep paths - inquire about accessible routes';
    return 'Contact site management about accessibility facilities';
  }

  generatePhotographyTips(place, currentDateTime) {
    const tips = [];

    if (currentDateTime.hour < 10 || currentDateTime.hour > 16) {
      tips.push('Excellent lighting conditions for photography');
    } else {
      tips.push('Harsh midday sun - seek shaded areas for photos');
    }

    switch (place.category) {
      case 'temple':
        tips.push('Focus on intricate carvings and architectural details');
        tips.push('Respect photography restrictions in inner sanctum');
        break;
      case 'palace':
        tips.push('Capture royal chambers and ornate decorations');
        tips.push('Garden courtyards provide excellent backdrops');
        break;
      case 'fort':
        tips.push('Panoramic views from ramparts and towers');
        tips.push('Sunset/sunrise shots from elevated positions');
        break;
      default:
        tips.push('Capture unique architectural elements');
        tips.push('Include surrounding landscape in compositions');
    }

    return tips.slice(0, 3);
  }

  generatePersonalizedFoodRecommendations(place, userProfile) {
    const recommendations = [];
    const regionalFood = this.getRegionalCuisine(place.state);

    if (userProfile?.foodPreferences === 'vegetarian' || !userProfile?.foodPreferences) {
      recommendations.push(...(regionalFood.vegetarian || []));
    }

    if (userProfile?.foodPreferences === 'vegan') {
      recommendations.push(...(regionalFood.vegan || []));
    }

    if (userProfile?.foodPreferences === 'all' || userProfile?.foodPreferences === 'non-vegetarian') {
      recommendations.push(...(regionalFood.nonVegetarian || []));
    }

    recommendations.push(Local specialty near ${place.name});

    return recommendations.slice(0, 3);
  }

  getRegionalCuisine(state) {
    const cuisine = {
      'Karnataka': {
        vegetarian: ['Mysore Pak', 'Bisi Bele Bath', 'Masala Dosa'],
        vegan: ['Ragi Mudde', 'Coconut Chutney', 'Vegetable Curry'],
        nonVegetarian: ['Chicken Sukka', 'Fish Curry', 'Mutton Biryani']
      },
      'Tamil Nadu': {
        vegetarian: ['Filter Coffee', 'Idli Sambar', 'Chettinad Vegetable Curry'],
        vegan: ['Coconut Rice', 'Rasam', 'Vegetable Kootu'],
        nonVegetarian: ['Chettinad Chicken', 'Fish Curry', 'Mutton Kuzhambu']
      }
    };

    return cuisine[state] || {
      vegetarian: ['South Indian Thali', 'Dosa varieties', 'Traditional sweets'],
      vegan: ['Coconut-based curries', 'Rice preparations', 'Vegetable dishes'],
      nonVegetarian: ['Regional chicken dishes', 'Fish curry', 'Biryani']
    };
  }

  getSeasonalAdvice(place, currentDateTime) {
    const advice = {
      'Summer': 'Visit early morning or late afternoon to avoid heat',
      'Monsoon': 'Carry rain protection and enjoy the lush greenery',
      'Winter': 'Perfect weather for extended exploration',
      'Pleasant': 'Ideal conditions for comfortable sightseeing'
    };

    return advice[currentDateTime.season] || 'Weather-appropriate planning recommended';
  }

  getWeatherSpecificAdvice(place, currentDateTime) {
    if (currentDateTime.season === 'Summer' && place.category === 'fort') {
      return 'Hot weather - bring water and sun protection for fort exploration';
    } else if (currentDateTime.season === 'Monsoon') {
      return 'Monsoon season - carry umbrella and wear non-slip footwear';
    }

    return 'Current weather is suitable for visiting';
  }

  getPersonalizedTicketAdvice(place, userProfile) {
    const advice = [];

    if (place.entryFee?.indian > 0) {
      advice.push(Entry fee: ‚Çπ${place.entryFee.indian} for Indians);
    } else {
      advice.push('Free entry for all visitors');
    }

    if (userProfile?.groupSize > 1) {
      advice.push(Group booking may be available);
    }

    advice.push('Book online in advance to avoid queues');

    return advice.join('; ');
  }

  getRealTimeOpeningHours(place, currentDateTime) {
    const defaultHours = {
      'temple': 'Daily 5:30 AM - 12:00 PM, 4:00 PM - 9:00 PM',
      'heritage': 'Daily 9:00 AM - 6:00 PM',
      'palace': 'Daily 10:00 AM - 5:00 PM',
      'fort': 'Daily sunrise to sunset'
    };

    let hours = defaultHours[place.category] || 'Daily 9:00 AM - 6:00 PM';

    const currentHour = currentDateTime.hour;
    if (place.category === 'temple') {
      if ((currentHour >= 5 && currentHour < 12) || (currentHour >= 16 && currentHour < 21)) {
        hours += ' (Currently OPEN)';
      } else {
        hours += ' (Currently CLOSED)';
      }
    } else {
      if (currentHour >= 9 && currentHour < 18) {
        hours += ' (Currently OPEN)';
      } else {
        hours += ' (Currently CLOSED)';
      }
    }

    return hours;
  }

  buildInterestRecommendations(interests, places) {
    const recommendations = {};

    if (interests && Array.isArray(interests)) {
      interests.forEach(interest => {
        recommendations[interest] = this.getRecommendationsForInterest(interest, places);
      });
    } else {
      recommendations.general = ["Explore at your own pace"];
    }

    return recommendations;
  }

  getRecommendationsForInterest(interest, places) {
    const interestMap = {
      'history': places.filter(p => ['temple', 'heritage', 'fort'].includes(p.category))
                      .map(p => Explore the rich history of ${p.name}),
      'photography': ['Best lighting times for each location', 'Architectural detail focus points'],
      'spirituality': places.filter(p => p.category === 'temple')
                            .map(p => Spiritual experience at ${p.name}),
      'nature': places.filter(p => ['hill-station', 'beach'].includes(p.category))
                      .map(p => Connect with nature at ${p.name})
    };

    return interestMap[interest] || [Enjoy ${interest}-related activities];
  }

  getRecommendationsForTravelStyle(travelStyle, places) {
    const recommendations = {
      'explorer': ['Spend extra time at each location', 'Look for hidden details and stories'],
      'cultural': ['Focus on historical significance', 'Engage with local customs'],
      'relaxed': ['Take your time at each spot', 'Enjoy the peaceful moments'],
      'adventure': ['Explore all accessible areas', 'Try local adventure activities'],
      'photographer': ['Golden hour visits', 'Unique angle discoveries']
    };

    return recommendations[travelStyle] || ['Enjoy your selected destinations at your own pace'];
  }

  getRecommendationsForGroupSize(groupSize, places) {
    if (groupSize === 1) {
      return ['Solo travel tips for each destination', 'Connect with other travelers'];
    } else if (groupSize <= 4) {
      return ['Perfect small group activities', 'Coordinate group photos'];
    } else {
      return ['Large group coordination strategies', 'Designate group leaders'];
    }
  }

  getPersonalizedTimingTips(currentDateTime, userProfile) {
    const tips = [];

    if (currentDateTime.hour < 8) {
      tips.push('Early start - beat the crowds and heat');
    } else if (currentDateTime.hour > 16) {
      tips.push('Evening start - cooler weather and different atmosphere');
    } else {
      tips.push('Mid-day start - plan for peak sun hours');
    }

    return tips.join('; ');
  }

  getBudgetOptimizationTips(budget, places) {
    const tips = [];
    const totalEntryFees = places.reduce((sum, place) => {
      return sum + (place.entryFee?.indian || place.entryFee?.amount || 0);
    }, 0);

    tips.push(Total entry fees: ‚Çπ${totalEntryFees});

    if (budget) {
      const remainingBudget = budget - totalEntryFees;
      tips.push(Remaining budget for food/transport: ‚Çπ${remainingBudget});

      if (remainingBudget < 1000) {
        tips.push('Budget tip: Pack lunch and use public transport');
      } else if (remainingBudget > 3000) {
        tips.push('Comfortable budget: Enjoy premium experiences');
      }
    }

    tips.push('Book accommodation in advance for better rates');

    return tips;
  }

  getPersonalizedTransportation(userProfile, places) {
    if (userProfile?.groupSize > 4) {
      return 'Large vehicle or tempo traveler recommended';
    } else if (places.length > 5) {
      return 'Private car with driver for convenience';
    } else if (userProfile?.budget && userProfile.budget < 2000) {
      return 'Public transport and shared cabs';
    }
    return 'Private cab or rental car';
  }

  getTransportAlternatives(userProfile) {
    return [
      'Public buses (most economical)',
      'Shared cabs/auto-rickshaws',
      'Rental two-wheeler',
      'Private car rental'
    ];
  }

  getTransportPersonalizedAdvice(userProfile, groupSize) {
    const advice = [];

    if (groupSize === 1) {
      advice.push('Solo travel: Use trusted cab services');
    } else {
      advice.push(Group of ${groupSize}: Book appropriate vehicle size);
    }

    if (userProfile?.accessibilityNeeds) {
      advice.push('Ensure wheelchair accessible transport if needed');
    }

    return advice.join('; ');
  }

  getPersonalizedAccommodation(userProfile, budget) {
    const options = {};

    if (!budget || budget < 2000) {
      options.budget = ['Hostels and guesthouses', 'Dharamshalas near temples'];
    }
    if (!budget || budget >= 2000) {
      options.midRange = ['Comfortable hotels', '3-star accommodations'];
    }
    if (budget && budget > 5000) {
      options.luxury = ['Premium hotels', 'Heritage properties'];
    }

    if (userProfile?.groupSize > 4) {
      options.family = ['Family rooms', 'Apartment stays'];
    }

    return options;
  }

  getBookingStrategy(currentDateTime, userProfile) {
    const strategies = [];

    if (['Friday', 'Saturday', 'Sunday'].includes(currentDateTime.dayOfWeek)) {
      strategies.push('Weekend travel: Book accommodations in advance');
    }

    if (currentDateTime.season === 'Winter') {
      strategies.push('Peak season: Higher rates expected');
    }

    return strategies;
  }

  getPersonalizedPackingList(userProfile, currentDateTime) {
    const items = ['Comfortable walking shoes', 'Water bottle', 'Camera/phone'];

    if (currentDateTime.season === 'Summer') items.push('Sun hat', 'Sunscreen', 'Light cotton clothes');
    if (currentDateTime.season === 'Monsoon') items.push('Rain jacket', 'Umbrella', 'Waterproof bag');
    if (currentDateTime.season === 'Winter') items.push('Light jacket', 'Warm layer');

    if (userProfile?.interests?.includes('photography')) items.push('Extra batteries', 'Lens cloth');
    if (userProfile?.activityLevel === 'high') items.push('Energy snacks', 'First aid kit');

    return items.join(', ');
  }

  getSeasonalPackingItems(currentDateTime) {
    const items = {
      'Summer': ['Sun hat', 'Sunscreen', 'Light cotton clothes', 'Extra water'],
      'Monsoon': ['Rain jacket', 'Umbrella', 'Waterproof bags', 'Quick-dry clothes'],
      'Winter': ['Light jacket', 'Comfortable layers']
    };

    return items[currentDateTime.season] || ['Weather-appropriate clothing'];
  }

  getPersonalPackingPreferences(userProfile) {
    const preferences = [];

    if (userProfile?.interests?.includes('photography')) {
      preferences.push('Camera equipment and extra batteries');
    }

    if (userProfile?.activityLevel === 'high') {
      preferences.push('Energy snacks and first aid kit');
    }

    if (userProfile?.accessibilityNeeds) {
      preferences.push('Mobility aids and comfort items');
    }

    return preferences;
  }

  getPersonalizedSafetyTips(userProfile, groupSize, places) {
    const tips = [];

    if (groupSize === 1) {
      tips.push('Solo travel: Share itinerary with someone');
      tips.push('Keep emergency contacts handy');
    } else {
      tips.push('Group travel: Designate meeting points');
    }

    tips.push('Carry copies of important documents');

    if (places.some(p => p.category === 'temple')) {
      tips.push('Temple visits: Respect dress codes and customs');
    }

    if (places.some(p => ['hill-station', 'fort'].includes(p.category))) {
      tips.push('Hill/fort areas: Wear sturdy footwear');
    }

    return tips;
  }

  buildSmartCheckpoints(realTimeSchedule, userProfile) {
    return realTimeSchedule.timeline.map((item, index) => ({
      id: item.id || checkpoint_${index},
      name: item.name,
      type: item.type || 'destination',
      coordinates: {
        lat: item.coordinates?.lat || 11.0638,
        lng: item.coordinates?.lng || 77.0596
      },
      scheduledTime: item.scheduledTime,
      personalizedActions: this.getPersonalizedCheckpointActions(item, userProfile),
      completionTriggers: ["GPS proximity", "Manual check-in", "Photo confirmation"]
    }));
  }

  getPersonalizedCheckpointActions(item, userProfile) {
    const actions = ['Check-in at location', 'Take memorable photos'];

    if (userProfile?.interests?.includes('social')) {
      actions.push('Share experience on social media');
    }

    if (item.type === 'destination') {
      actions.push('Complete main activity');
      actions.push('Collect personal memory/souvenir');
    }

    return actions;
  }

  getPersonalizedChallenges(places, userProfile) {
    const challenges = [];

    if (userProfile?.interests?.includes('photography')) {
      challenges.push('Photography challenge: Capture unique angles of each destination');
    }

    if (userProfile?.interests?.includes('history')) {
      challenges.push('History hunter: Learn one fascinating story from each location');
    }

    challenges.push('Cultural connection: Interact with locals at each destination');
    challenges.push('Taste explorer: Try one local specialty at each stop');
    challenges.push(Complete journey: Visit all ${places.length} of your chosen destinations);

    return challenges;
  }

  getPersonalizedRoute(fromPlace, toPlace, userProfile) {
    const route = [];

    route.push(Scenic route from ${fromPlace.name} to ${toPlace.name});

    if (userProfile?.interests?.includes('nature')) {
      route.push('Look for natural scenic stops along the way');
    }

    if (userProfile?.interests?.includes('photography')) {
      route.push('Photography opportunities during the journey');
    }

    return route.join('; ');
  }

  getCurrentDateTimeContext() {
    const now = new Date();
    const istTime = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));

    return {
      timestamp: now.getTime(),
      date: istTime.toISOString().split('T')[0],
      time: istTime.toTimeString().split(' ')[0].substring(0, 5),
      hour: istTime.getHours(),
      dayOfWeek: istTime.toLocaleDateString('en-US', { weekday: 'long' }),
      formatted: istTime.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }),
      season: this.getCurrentSeason(istTime),
      weatherCondition: this.getWeatherCondition(istTime)
    };
  }

  getScenicStops(fromPlace, toPlace) {
    return [
      'Rural landscapes and traditional villages',
      'Roadside temples and local markets',
      'Scenic viewpoints for quick photo stops'
    ];
  }
}

// Export as singleton instance
module.exports = new DetailedTripController();
--
// backend/controllers/tripController.js - FIXED PLACE ENRICHMENT LOGIC

const { GoogleGenerativeAI } = require('@google/generative-ai');
const Place = require('../models/Place');
const OptimizationAlgorithms = require('../utils/optimizationAlgorithms');
const DistanceCalculator = require('../utils/distanceCalculator');

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Initialize optimization algorithms
const optimizationAlgorithms = new OptimizationAlgorithms();
const distanceCalculator = new DistanceCalculator();

// FIXED: Enhanced place enrichment function with better error handling
async function enrichPlacesFromDatabase(inputPlaces) {
  console.log(üîç Starting place enrichment for ${inputPlaces.length} places...);
  const enrichedPlaces = [];

  for (const place of inputPlaces) {
    try {
      let dbPlace = null;
      const placeName = place.name || place.id || 'Unknown';

      console.log(üîé Searching for place: ${placeName});

      // Build flexible search query with multiple fallback strategies
      const searchStrategies = [];

      // Strategy 1: Search by ObjectId if the ID looks like one
      if (place.id && typeof place.id === 'string' && place.id.match(/^[0-9a-fA-F]{24}$/)) {
        searchStrategies.push({ _id: place.id });
      }

      // Strategy 2: Search by custom id field (string-based IDs)
      if (place.id) {
        searchStrategies.push({ id: place.id });
      }

      // Strategy 3: Search by slug/URL-friendly version
      if (place.id && typeof place.id === 'string') {
        searchStrategies.push({ slug: place.id.toLowerCase() });
        // Also try variations of the slug
        const slugVariations = [
          place.id.toLowerCase().replace(/-/g, ' '),
          place.id.toLowerCase().replace(//g, ' '),
          place.id.toLowerCase().replace(/[-]/g, '')
        ];
        slugVariations.forEach(variation => {
          searchStrategies.push({ slug: variation });
        });
      }

      // Strategy 4: Search by name (exact and fuzzy)
      if (place.name) {
        searchStrategies.push({ name: place.name });
        searchStrategies.push({ name: { $regex: new RegExp(^${escapeRegex(place.name)}$, 'i') } });
        searchStrategies.push({ name: { $regex: new RegExp(escapeRegex(place.name), 'i') } });
      }

      // Strategy 5: Search by name extracted from ID
      if (place.id && typeof place.id === 'string') {
        const nameFromId = place.id
          .split('-')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ')
          .replace(/([A-Z])/g, ' $1')
          .trim();

        if (nameFromId !== place.id) {
          searchStrategies.push({ name: { $regex: new RegExp(escapeRegex(nameFromId), 'i') } });
        }
      }

      // Strategy 6: Multi-field search
      if (place.city || place.state) {
        const cityStateQuery = {};
        if (place.city) cityStateQuery.city = { $regex: new RegExp(escapeRegex(place.city), 'i') };
        if (place.state) cityStateQuery.state = { $regex: new RegExp(escapeRegex(place.state), 'i') };

        if (place.name) {
          searchStrategies.push({
            ...cityStateQuery,
            name: { $regex: new RegExp(escapeRegex(place.name), 'i') }
          });
        }
      }

      // Execute search strategies sequentially until we find a match
      for (let i = 0; i < searchStrategies.length && !dbPlace; i++) {
        try {
          const strategy = searchStrategies[i];
          console.log(  üéØ Trying strategy ${i + 1}: ${JSON.stringify(strategy)});

          dbPlace = await Place.findOne({
            ...strategy,
            isActive: true
          }).lean();

          if (dbPlace) {
            console.log(  ‚úÖ Found place using strategy ${i + 1}: ${dbPlace.name});
            break;
          }
        } catch (searchError) {
          console.warn(  ‚ö†Ô∏è Strategy ${i + 1} failed:, searchError.message);
          continue;
        }
      }

      // If still no match, try a broad search across all fields
      if (!dbPlace && place.name) {
        try {
          console.log(  üîç Trying broad search for: ${place.name});
          const searchTerms = place.name.split(/\s+/).filter(term => term.length > 2);

          if (searchTerms.length > 0) {
            const regexQueries = searchTerms.map(term => ({
              $or: [
                { name: { $regex: new RegExp(escapeRegex(term), 'i') } },
                { description: { $regex: new RegExp(escapeRegex(term), 'i') } },
                { tags: { $regex: new RegExp(escapeRegex(term), 'i') } },
                { city: { $regex: new RegExp(escapeRegex(term), 'i') } }
              ]
            }));

            dbPlace = await Place.findOne({
              $and: regexQueries,
              isActive: true
            }).lean();

            if (dbPlace) {
              console.log(  ‚úÖ Found place using broad search: ${dbPlace.name});
            }
          }
        } catch (broadSearchError) {
          console.warn(  ‚ö†Ô∏è Broad search failed:, broadSearchError.message);
        }
      }

      if (dbPlace) {
        // Successfully found place in database - merge with input data
        const enrichedPlace = {
          // Start with input data
          ...place,
          // Override with database data (more authoritative)
          ...dbPlace,
          // Ensure critical fields are properly formatted
          id: dbPlace.id || dbPlace._id.toString(),
          _id: dbPlace._id.toString(),
          location: {
            latitude: parseFloat(dbPlace.location.latitude),
            longitude: parseFloat(dbPlace.location.longitude)
          },
          averageVisitDuration: parseInt(dbPlace.averageVisitDuration) || 90,
          rating: parseFloat(dbPlace.rating) || 3.5,
          entryFee: dbPlace.entryFee || { indian: 0, foreign: 0 },
          category: dbPlace.category || 'general',
          amenities: dbPlace.amenities || [],
          tags: dbPlace.tags || [],
          bestTimeToVisit: dbPlace.bestTimeToVisit || ['morning'],
          kidFriendly: dbPlace.kidFriendly !== false,
          wheelchairAccessible: dbPlace.wheelchairAccessible === true,
          // Mark as found in database
          _enriched: true,
          _source: 'database'
        };

        console.log(  ‚úÖ Successfully enriched: ${enrichedPlace.name});
        enrichedPlaces.push(enrichedPlace);

      } else {
        // Place not found in database - use input data with sensible defaults
        console.warn(  ‚ùå Place not found in database: ${placeName});

        const fallbackPlace = {
          ...place,
          id: place.id || place.id || `fallback${Date.now()}_${Math.random()},
          name: place.name || 'Unknown Place',
          location: place.location || { latitude: 11.0168, longitude: 76.9558 }, // Default to Coimbatore
          averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
          rating: parseFloat(place.rating) || 3.5,
          category: place.category || 'general',
          city: place.city || 'Unknown',
          state: place.state || 'Tamil Nadu',
          entryFee: place.entryFee || { indian: 0, foreign: 0 },
          description: place.description || Visit ${place.name || 'this place'} for a unique experience.`,
          amenities: place.amenities || [],
          tags: place.tags || [],
          bestTimeToVisit: place.bestTimeToVisit || ['morning', 'evening'],
          kidFriendly: place.kidFriendly !== false,
          wheelchairAccessible: place.wheelchairAccessible === true,
          // Mark as fallback data
          _enriched: false,
          _source: 'fallback',
          _warning: 'Place not found in database, using fallback data'
        };

        enrichedPlaces.push(fallbackPlace);
      }

    } catch (error) {
      console.error(üí• Error enriching place ${place.name || place.id}:, error);

      // Create absolute fallback entry
      const errorPlace = {
        ...place,
        id: place.id || error_${Date.now()},
        name: place.name || 'Error Place',
        location: { latitude: 11.0168, longitude: 76.9558 },
        averageVisitDuration: 90,
        rating: 3.0,
        category: 'general',
        city: 'Unknown',
        state: 'Tamil Nadu',
        entryFee: { indian: 0, foreign: 0 },
        description: 'Place data unavailable due to processing error.',
        _enriched: false,
        _source: 'error',
        _error: error.message
      };

      enrichedPlaces.push(errorPlace);
    }
  }

  console.log(üìä Place enrichment completed:);
  console.log(  ‚Ä¢ Total input places: ${inputPlaces.length});
  console.log(  ‚Ä¢ Successfully enriched: ${enrichedPlaces.filter(p => p._enriched).length});
  console.log(  ‚Ä¢ Using fallback data: ${enrichedPlaces.filter(p => p._source === 'fallback').length});
  console.log(  ‚Ä¢ Error cases: ${enrichedPlaces.filter(p => p._source === 'error').length});

  return enrichedPlaces;
}

// Helper function to escape regex special characters
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// FIXED: Enhanced Gemini analysis with better error handling
async function getGeminiTripAnalysis(places, preferences, constraints) {
  console.log('ü§ñ Starting Gemini AI analysis...');

  if (!process.env.GEMINI_API_KEY) {
    console.warn('‚ö†Ô∏è Gemini API key not found, using fallback analysis');
    return generateFallbackAnalysis(places, preferences, constraints);
  }

  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

    // Calculate geographic spread for algorithm selection
    const coordinates = places.map(p => p.location).filter(loc => loc && loc.latitude && loc.longitude);
    const spread = coordinates.length >= 2 ? calculateGeographicSpread(coordinates) : {
      maxDistance: 0,
      averageDistance: 0,
      density: 'high',
      complexity: 'low'
    };

    const analysisPrompt = `Analyze this South Indian trip and recommend the best optimization strategy:

PLACES TO VISIT (${places.length} places):
${places.map((place, index) => 
${index + 1}. ${place.name} (${place.city}, ${place.state})
   ‚Ä¢ Category: ${place.category}
   ‚Ä¢ Rating: ${place.rating}/5 ‚≠ê
   ‚Ä¢ Duration: ${place.averageVisitDuration} minutes
   ‚Ä¢ Entry: ‚Çπ${place.entryFee?.indian || 0}
   ‚Ä¢ Location: ${place.location.latitude}, ${place.location.longitude}
   ‚Ä¢ Source: ${place._source || 'database'}
).join('')}

CONSTRAINTS:
‚Ä¢ Time Available: ${constraints.totalTimeAvailable || 480} minutes
‚Ä¢ Budget: ${constraints.budget ? '‚Çπ' + constraints.budget : 'Flexible'}
‚Ä¢ Start Time: ${constraints.startTime || '09:00'}

GEOGRAPHIC ANALYSIS:
‚Ä¢ Max Distance: ${spread.maxDistance?.toFixed(1) || 0}km
‚Ä¢ Avg Distance: ${spread.averageDistance?.toFixed(1) || 0}km
‚Ä¢ Complexity: ${spread.complexity || 'low'}

Select the best algorithm and provide analysis in JSON format:

{
  "tripOverview": "Brief 2-3 sentence description of this trip",
  "algorithmRecommendation": {
    "algorithm": "advancedGreedy",
    "reason": "Why this algorithm is best for this scenario",
    "confidence": "high"
  },
  "routingStrategy": {
    "startingPlace": "${places[0]?.name || 'First place'}",
    "optimizationPriorities": ["rating", "proximity", "time_efficiency"]
  },
  "recommendations": [
    "Start early to avoid crowds",
    "Book tickets in advance",
    "Carry water and snacks"
  ],
  "warnings": [
    "Some places are far apart - expect travel time"
  ],
  "budgetEstimate": {
    "total": ${places.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0) + 500}
  },
  "culturalTips": [
    "Dress modestly at temples",
    "Try local cuisine"
  ]
}`;

    console.log('üì§ Sending request to Gemini AI...');

    const result = await Promise.race([
      model.generateContent(analysisPrompt),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Gemini API timeout')), 15000)
      )
    ]);

    const response = await result.response;
    const aiResponse = response.text();

    console.log('üì• Gemini AI response received');

    // Parse JSON response
    try {
      const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const analysis = JSON.parse(jsonMatch[0]);
        console.log(üß† AI recommended algorithm: ${analysis.algorithmRecommendation?.algorithm});
        return analysis;
      } else {
        throw new Error('No JSON found in AI response');
      }
    } catch (parseError) {
      console.error('üö® JSON parsing failed:', parseError);
      throw new Error(Gemini response parsing failed: ${parseError.message});
    }

  } catch (error) {
    console.error('üö® Gemini analysis failed:', error);
    console.log('üîÑ Using fallback analysis...');
    return generateFallbackAnalysis(places, preferences, constraints);
  }
}

// Generate fallback analysis when Gemini fails
function generateFallbackAnalysis(places, preferences, constraints) {
  console.log('üîß Generating fallback analysis...');

  const coordinates = places.map(p => p.location).filter(loc => loc && loc.latitude && loc.longitude);
  const spread = coordinates.length >= 2 ? calculateGeographicSpread(coordinates) : {
    maxDistance: 0,
    averageDistance: 0,
    complexity: 'low'
  };

  // Algorithm selection logic
  let algorithm = 'advancedGreedy';
  let reason = 'General purpose optimization';

  if (places.length <= 6 && spread.complexity === 'low') {
    algorithm = 'dynamicProgramming';
    reason = 'Small number of places with low complexity - optimal solution possible';
  } else if (places.length >= 10 && spread.complexity === 'high') {
    algorithm = 'genetic';
    reason = 'Large number of places with high geographic complexity';
  } else if (spread.maxDistance > 100) {
    algorithm = 'nearestNeighbor';
    reason = 'Large distances between places - prioritizing travel efficiency';
  }

  return {
    tripOverview: A ${places.length}-place journey across ${getUniqueCities(places).length} cities in South India, featuring ${getMostCommonCategory(places)} attractions.,
    algorithmRecommendation: {
      algorithm: algorithm,
      reason: reason,
      confidence: 'medium'
    },
    routingStrategy: {
      startingPlace: places[0]?.name || 'First place',
      optimizationPriorities: ['rating', 'proximity', 'time_efficiency']
    },
    recommendations: [
      'Start early in the morning to maximize your time',
      'Check opening hours for all attractions in advance',
      spread.maxDistance > 50 ? 'Plan for significant travel time between distant places' : 'Compact route allows for relaxed pacing',
      'Carry water, snacks, and a power bank',
      'Book popular attractions in advance if possible'
    ],
    warnings: generateWarnings(places, spread, constraints),
    budgetEstimate: {
      entryFees: places.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0),
      transportation: Math.round(places.length * 150),
      food: Math.round(places.length * 100),
      total: places.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0) + Math.round(places.length * 250)
    },
    culturalTips: [
      'Remove shoes before entering temples and religious sites',
      'Dress modestly, especially at religious locations',
      'Try local South Indian cuisine at each destination',
      'Learn basic greetings in Tamil, Telugu, or Kannada',
      'Respect photography restrictions at certain locations'
    ]
  };
}

// Helper functions for fallback analysis
function getUniqueCities(places) {
  return [...new Set(places.map(p => p.city).filter(Boolean))];
}

function getMostCommonCategory(places) {
  const categoryCount = {};
  places.forEach(p => {
    const category = p.category || 'general';
    categoryCount[category] = (categoryCount[category] || 0) + 1;
  });

  const mostCommon = Object.keys(categoryCount).reduce((a, b) => 
    categoryCount[a] > categoryCount[b] ? a : b, 'mixed');

  return mostCommon === 'temple' ? 'religious' : mostCommon;
}

function safeJsonParse(jsonString) {
  try {
    return { success: true, data: JSON.parse(jsonString) };
  } catch (error) {
    console.error('JSON parse error:', error.message);
    console.error('Original AI response snippet:', jsonString.substring(0, 200));
    return { success: false, error };
  }
}

function generateWarnings(places, spread, constraints) {
  const warnings = [];

  if (spread.maxDistance > 100) {
    warnings.push('Some places are over 100km apart - expect significant travel time');
  }

  if (places.length > 10) {
    warnings.push('Large number of places - consider spreading over multiple days');
  }

  if (constraints.totalTimeAvailable && places.length * 90 > constraints.totalTimeAvailable) {
    warnings.push('Limited time available - some places may need to be skipped');
  }

  const fallbackPlaces = places.filter(p => p._source === 'fallback');
  if (fallbackPlaces.length > 0) {
    warnings.push(${fallbackPlaces.length} places not found in database - using approximate data);
  }

  return warnings.length > 0 ? warnings : ['No specific warnings for this itinerary'];
}

// Calculate geographic spread for algorithm selection
function calculateGeographicSpread(coordinates) {
  if (coordinates.length < 2) {
    return { maxDistance: 0, averageDistance: 0, density: 'high', complexity: 'low' };
  }

  const distances = [];
  for (let i = 0; i < coordinates.length; i++) {
    for (let j = i + 1; j < coordinates.length; j++) {
      const distance = distanceCalculator.calculateDistance(
        coordinates[i].latitude, coordinates[i].longitude,
        coordinates[j].latitude, coordinates[j].longitude
      );
      distances.push(distance);
    }
  }

  const maxDistance = Math.max(...distances);
  const averageDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;

  let density, complexity;

  if (averageDistance < 25) {
    density = 'high';
    complexity = 'low';
  } else if (averageDistance < 75) {
    density = 'medium';
    complexity = 'medium';
  } else {
    density = 'low';
    complexity = 'high';
  }

  return {
    maxDistance,
    averageDistance,
    density,
    complexity
  };
}

// FIXED: Apply optimization algorithm function
async function applyOptimizationAlgorithm(places, algorithmRecommendation, preferences, algorithmParams) {
  const algorithm = algorithmRecommendation.algorithm || 'advancedGreedy';

  console.log(üöÄ Applying ${algorithm} algorithm to ${places.length} places);

  try {
    let result;

    switch (algorithm) {
      case 'advancedGreedy':
        result = await optimizationAlgorithms.advancedGreedyOptimization(places, {
          ...preferences,
          ...algorithmParams
        });
        break;

      case 'genetic':
        result = await optimizationAlgorithms.geneticAlgorithmOptimization(places, {
          ...preferences,
          ...algorithmParams
        });
        break;

      case 'nearestNeighbor':
        result = await optimizationAlgorithms.nearestNeighborOptimization(places, {
          ...preferences,
          ...algorithmParams
        });
        break;

      case 'dynamicProgramming':
        result = await optimizationAlgorithms.dynamicProgrammingOptimization(places, {
          ...preferences,
          ...algorithmParams
        });
        break;

      default:
        console.warn(Unknown algorithm: ${algorithm}, falling back to advancedGreedy);
        result = await optimizationAlgorithms.advancedGreedyOptimization(places, {
          ...preferences,
          ...algorithmParams
        });
    }

    if (!result || !result.route) {
      throw new Error('Algorithm returned invalid result');
    }

    console.log(‚úÖ ${algorithm} completed: ${result.route.length} places in route);
    return {
      ...result,
      algorithm: algorithm,
      success: true
    };

  } catch (error) {
    console.error(üí• Algorithm ${algorithm} failed:, error);

    // Fallback to simple greedy algorithm
    console.log('üîÑ Falling back to simple greedy algorithm...');
    try {
      const fallbackResult = await optimizationAlgorithms.advancedGreedyOptimization(places, preferences);
      return {
        ...fallbackResult,
        algorithm: 'advancedGreedy',
        success: true,
        fallbackUsed: true,
        originalAlgorithm: algorithm,
        fallbackReason: error.message
      };
    } catch (fallbackError) {
      console.error('üí• Fallback algorithm also failed:', fallbackError);

      // Ultimate fallback - return places in original order
      return {
        route: places.slice(0, Math.min(places.length, 10)), // Limit to 10 places
        algorithm: 'original-order',
        totalTime: places.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
        totalDistance: 0,
        efficiency: 0,
        success: false,
        error: fallbackError.message
      };
    }
  }
}

// Generate detailed itinerary with Gemini AI
async function generateGeminiItinerary(route, geminiAnalysis, preferences, constraints) {
  if (!route || route.length === 0) {
    return {
      itinerary: 'No places in optimized route to create itinerary.',
      alternatives: ['Try with different places or constraints'],
      practicalInfo: {}
    };
  }

  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

    const itineraryPrompt = `Create a detailed day itinerary for this optimized South Indian route:

OPTIMIZED ROUTE (${route.length} places):
${route.map((place, index) => 
${index + 1}. ${place.name} (${place.city})
   ‚Ä¢ Duration: ${place.averageVisitDuration} minutes
   ‚Ä¢ Rating: ${place.rating}/5 ‚≠ê
   ‚Ä¢ Entry: ‚Çπ${place.entryFee?.indian || 0}
   ‚Ä¢ Category: ${place.category}
   ‚Ä¢ Source: ${place._source || 'database'}
).join('')}

PREFERENCES:
‚Ä¢ Start Time: ${constraints.startTime || '09:00'}
‚Ä¢ Time Available: ${constraints.totalTimeAvailable || 480} minutes
‚Ä¢ Budget: ${constraints.budget ? '‚Çπ' + constraints.budget : 'Flexible'}

Return detailed itinerary in JSON format:
{
  "itinerary": "Hour-by-hour schedule with timings and recommendations",
  "alternatives": ["Alternative suggestion 1", "Alternative suggestion 2"],
  "practicalInfo": {
    "totalDuration": "X hours",
    "transportationTips": "Transport recommendations",
    "budgetBreakdown": "Cost breakdown",
    "packingList": ["Item 1", "Item 2"]
  }
}`;

    const result = await model.generateContent(itineraryPrompt);
    const response = await result.response;
    const aiResponse = response.text();

    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch (error) {
    console.error('Gemini itinerary generation failed:', error);
  }

  // Fallback itinerary
  const startTime = constraints.startTime || '09:00';
  const totalHours = Math.round((constraints.totalTimeAvailable || 480) / 60);

  return {
    itinerary: Start your ${route.length}-place journey at ${startTime}. Visit ${route.map(p => p.name).join(' ‚Üí ')}. Total duration: approximately ${totalHours} hours including travel time.,
    alternatives: [
      'Consider starting 30 minutes earlier for a more relaxed pace',
      'Add buffer time between locations for traffic delays',
      'Split into multiple days if time permits'
    ],
    practicalInfo: {
      totalDuration: ${totalHours} hours,
      transportationTips: 'Use private vehicle or cab for flexibility between locations',
      budgetBreakdown: Entry fees: ‚Çπ${route.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0)}, Transport & meals: ‚Çπ${route.length * 300},
      packingList: ['Water bottle', 'Camera', 'Comfortable shoes', 'Sunscreen', 'Power bank']
    }
  };
}

// MAIN ROUTE OPTIMIZATION WITH ENHANCED ERROR HANDLING
const optimizeTripWithAI = async (req, res) => {
  const startTime = Date.now();

  try {
    console.log('ü§ñ STARTING ENHANCED GEMINI AI + ALGORITHM OPTIMIZATION');

    const {
      places,
      preferences = {},
      constraints = {},
      algorithmParams = {}
    } = req.body;

    // Enhanced input validation
    const validation = validateTripOptimizationInput(req.body);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: validation.errors
      });
    }

    console.log(üìä Input: ${places.length} places, Level: ${preferences.optimizationLevel || 'balanced'});

    // Step 1: Enhanced place enrichment from database
    console.log('üîç Enriching places from database...');
    const enrichedPlaces = await enrichPlacesFromDatabase(places);

    if (enrichedPlaces.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No valid places could be processed'
      });
    }

    // Step 2: Get Gemini AI analysis with fallback
    console.log('üß† Getting Gemini AI analysis...');
    const geminiAnalysis = await getGeminiTripAnalysis(enrichedPlaces, preferences, constraints);

    // Step 3: Apply optimization algorithm
    console.log(‚ö° Applying ${geminiAnalysis.algorithmRecommendation.algorithm} algorithm...);
    const algorithmResult = await applyOptimizationAlgorithm(
      enrichedPlaces,
      geminiAnalysis.algorithmRecommendation,
      { ...preferences, ...constraints },
      algorithmParams
    );

    // Step 4: Generate detailed itinerary
    console.log('üìã Generating detailed itinerary...');
    const detailedItinerary = await generateGeminiItinerary(
      algorithmResult.route,
      geminiAnalysis,
      preferences,
      constraints
    );

    // Step 5: Build comprehensive response
    const executionTime = Date.now() - startTime;

    const finalResult = {
      success: true,
      algorithm: algorithmResult.algorithm,
      route: algorithmResult.route,
      itinerary: detailedItinerary.itinerary,

      // Algorithm metrics
      metrics: {
        totalTime: algorithmResult.totalTime || 0,
        totalDistance: algorithmResult.totalDistance || 0,
        totalTravelTime: algorithmResult.totalTravelTime || 0,
        totalVisitTime: algorithmResult.totalVisitTime || 0,
        efficiency: algorithmResult.efficiency || 0,
        constraintsSatisfied: algorithmResult.constraintsSatisfied || true,
        placesVisited: algorithmResult.route?.length || 0,
        placesSkipped: places.length - (algorithmResult.route?.length || 0),
        executionTime: executionTime
      },

      // Gemini AI insights
      aiInsights: {
        tripOverview: geminiAnalysis.tripOverview,
        recommendations: geminiAnalysis.recommendations,
        warnings: geminiAnalysis.warnings,
        bestTimeToTravel: geminiAnalysis.bestTimeToTravel,
        budgetEstimate: geminiAnalysis.budgetEstimate,
        culturalTips: geminiAnalysis.culturalTips,
        routingStrategy: geminiAnalysis.routingStrategy
      },

      // Combined data
      optimizationDetails: {
        algorithmUsed: algorithmResult.algorithm,
        aiAnalysisUsed: true,
        aiRecommendedAlgorithm: geminiAnalysis.algorithmRecommendation?.algorithm,
        executionTime: executionTime,
        optimizationLevel: preferences.optimizationLevel || 'balanced',
        fallbackUsed: algorithmResult.fallbackUsed || false,
        placesEnriched: enrichedPlaces.filter(p => p._enriched).length,
        placesFallback: enrichedPlaces.filter(p => p._source === 'fallback').length
      },

      alternatives: detailedItinerary.alternatives || [],
      practicalInfo: detailedItinerary.practicalInfo || {},
      warnings: [
        ...(algorithmResult.warnings || []),
        ...(geminiAnalysis.warnings || []),
        ...enrichedPlaces.filter(p => p._warning).map(p => p._warning)
      ].filter((warning, index, arr) => arr.indexOf(warning) === index) // Remove duplicates
    };

    console.log('‚úÖ ENHANCED OPTIMIZATION COMPLETED:', {
      algorithm: finalResult.algorithm,
      placesOptimized: finalResult.route.length,
      placesEnriched: finalResult.optimizationDetails.placesEnriched,
      efficiency: ${finalResult.metrics.efficiency?.toFixed(1)}%,
      executionTime: ${executionTime}ms,
      aiInsightsGenerated: !!finalResult.aiInsights.tripOverview
    });

    res.status(200).json(finalResult);

  } catch (error) {
    const executionTime = Date.now() - startTime;
    console.error('üí• Enhanced optimization failed:', error);

    // Comprehensive fallback response
    try {
      console.log('üîÑ Executing comprehensive fallback...');

      const fallbackPlaces = req.body.places?.map((place, index) => ({
        ...place,
        id: place.id || fallback_${index},
        name: place.name || Place ${index + 1},
        location: place.location || { latitude: 11.0168, longitude: 76.9558 },
        averageVisitDuration: parseInt(place.averageVisitDuration) || 90,
        rating: parseFloat(place.rating) || 3.5,
        category: place.category || 'general',
        entryFee: place.entryFee || { indian: 0, foreign: 0 },
        _source: 'emergency_fallback'
      })) || [];

      if (fallbackPlaces.length === 0) {
        throw new Error('No places to process');
      }

      const fallbackRoute = fallbackPlaces.slice(0, Math.min(fallbackPlaces.length, 8));

      return res.status(200).json({
        success: true,
        route: fallbackRoute,
        algorithm: 'emergency-fallback',
        itinerary: Emergency itinerary: Visit ${fallbackRoute.map(p => p.name).join(' ‚Üí ')} starting at ${req.body.constraints?.startTime || '09:00'}.,

        metrics: {
          totalTime: fallbackRoute.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
          totalDistance: 0,
          totalTravelTime: 0,
          totalVisitTime: fallbackRoute.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
          efficiency: 0,
          placesVisited: fallbackRoute.length,
          placesSkipped: req.body.places?.length - fallbackRoute.length || 0,
          executionTime: executionTime
        },

        aiInsights: {
          tripOverview: 'Emergency trip plan created with available data.',
          recommendations: [
            'This is an emergency fallback plan - some data may be incomplete',
            'Verify place details before visiting',
            'Check opening hours and accessibility',
            'Consider regenerating the trip with better connectivity'
          ],
          warnings: [
            'AI optimization failed - using basic fallback',
            'Place data may be incomplete or outdated',
            'Manual verification of locations recommended'
          ],
          budgetEstimate: {
            total: fallbackRoute.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0) + 500
          },
          culturalTips: [
            'Respect local customs and traditions',
            'Dress appropriately for religious sites'
          ]
        },

        optimizationDetails: {
          algorithmUsed: 'emergency-fallback',
          aiAnalysisUsed: false,
          executionTime: executionTime,
          optimizationLevel: 'minimal',
          fallbackUsed: true,
          fallbackReason: error.message
        },

        warnings: [
          'Emergency fallback used due to system error',
          'Trip plan may not be optimized',
          'Verify all place details before departure'
        ],

        emergencyFallback: true,
        originalError: process.env.NODE_ENV === 'development' ? error.message : undefined
      });

    } catch (fallbackError) {
      console.error('üí• Emergency fallback also failed:', fallbackError);

      return res.status(500).json({
        success: false,
        message: 'Complete system failure - unable to process trip request',
        error: process.env.NODE_ENV === 'development' ? {
          original: error.message,
          fallback: fallbackError.message,
          stack: error.stack
        } : 'Multiple system errors occurred',
        suggestion: 'Please try again with fewer places or check your input data',
        executionTime: Date.now() - startTime
      });
    }
  }
};

// Validation function for trip optimization input
function validateTripOptimizationInput(body) {
  const errors = [];
  const { places, preferences = {}, constraints = {} } = body;

  // Validate places array
  if (!places || !Array.isArray(places)) {
    errors.push('places must be an array');
  } else if (places.length === 0) {
    errors.push('At least 1 place is required');
  } else if (places.length > 25) {
    errors.push('Maximum 25 places allowed');
  }

  // Validate individual places
  if (places && Array.isArray(places)) {
    places.forEach((place, index) => {
      if (!place.id && !place._id && !place.name) {
        errors.push(Place at index ${index} must have an id, _id, or name);
      }
    });
  }

  // Validate time constraints
  if (constraints.totalTimeAvailable && 
      (typeof constraints.totalTimeAvailable !== 'number' || constraints.totalTimeAvailable < 30)) {
    errors.push('totalTimeAvailable must be a number >= 30 minutes');
  }

  if (constraints.totalTimeAvailable && constraints.totalTimeAvailable > 1440) {
    errors.push('totalTimeAvailable cannot exceed 1440 minutes (24 hours)');
  }

  // Validate time format
  const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
  if (constraints.startTime && !timeRegex.test(constraints.startTime)) {
    errors.push('startTime must be in HH:MM format');
  }

  // Validate budget
  if (constraints.budget && 
      (typeof constraints.budget !== 'number' || constraints.budget < 0)) {
    errors.push('budget must be a positive number');
  }

  // Validate optimization level
  const validLevels = ['fast', 'balanced', 'optimal'];
  if (preferences.optimizationLevel && !validLevels.includes(preferences.optimizationLevel)) {
    errors.push(optimizationLevel must be one of: ${validLevels.join(', ')});
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

// Get quick trip suggestions with AI recommendations
const getTripSuggestions = async (req, res) => {
  try {
    const {
      location,
      timeAvailable = 480,
      interests = [],
      budget,
      groupSize = 2,
      travelDate
    } = req.query;

    console.log('üéØ Generating AI trip suggestions...');

    // Build query for places
    let query = { isActive: true };

    if (interests && interests.length > 0) {
      const interestArray = Array.isArray(interests) ? interests : interests.split(',');
      query.category = { $in: interestArray.map(i => i.toLowerCase()) };
    }

    // Get places
    let places = await Place.find(query)
      .sort({ rating: -1, reviewCount: -1 })
      .limit(50)
      .lean();

    // Filter by location if provided
    if (location && typeof location === 'string') {
      const coords = location.split(',').map(Number);
      if (coords.length === 2 && !coords.some(isNaN)) {
        const [lat, lng] = coords;
        try {
          const nearbyPlaces = await Place.findNearby(lat, lng, 100);
          if (nearbyPlaces.length > 0) {
            places = nearbyPlaces;
          }
        } catch (locationError) {
          console.warn('Location filtering failed:', locationError);
          // Continue with original places
        }
      }
    }

    if (places.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No places found matching your criteria',
        suggestion: 'Try adjusting your interests or location criteria'
      });
    }

    // Generate AI suggestions
    const suggestions = await generateAISuggestions(places, {
      timeAvailable: parseInt(timeAvailable),
      interests: Array.isArray(interests) ? interests : interests.split(','),
      budget: budget ? parseInt(budget) : undefined,
      groupSize: parseInt(groupSize),
      travelDate
    });

    res.status(200).json({
      success: true,
      suggestions: suggestions.suggestions || [],
      totalPlacesConsidered: places.length,
      criteria: {
        location,
        timeAvailable: parseInt(timeAvailable),
        interests: Array.isArray(interests) ? interests : interests.split(','),
        budget,
        groupSize: parseInt(groupSize)
      },
      metadata: {
        generatedAt: new Date().toISOString(),
        aiGenerated: true
      }
    });

  } catch (error) {
    console.error('Error generating trip suggestions:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating trip suggestions',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};

// Generate AI suggestions for different trip types
async function generateAISuggestions(places, criteria) {
  console.log('ü§ñ Generating AI trip suggestions...');

  if (!process.env.GEMINI_API_KEY) {
    console.warn('‚ö†Ô∏è Gemini API not available, using fallback suggestions');
    return generateFallbackSuggestions(places, criteria);
  }

  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

    const suggestionsPrompt = `Create 3 different trip suggestions from these South Indian places:

AVAILABLE PLACES (showing top ${Math.min(places.length, 20)}):
${places.slice(0, 20).map((place, index) => 
${index + 1}. ${place.name} (${place.city}, ${place.state})
   Rating: ${place.rating}/5 | Duration: ${place.averageVisitDuration}min | Fee: ‚Çπ${place.entryFee?.indian || 0}
   Category: ${place.category} | Kid-Friendly: ${place.kidFriendly ? 'Yes' : 'No'}
).join('')}

CRITERIA:
- Time Available: ${criteria.timeAvailable} minutes (${Math.floor(criteria.timeAvailable / 60)} hours)
- Interests: ${criteria.interests?.join(', ') || 'All types'}
- Budget: ${criteria.budget ? '‚Çπ' + criteria.budget : 'Flexible'}
- Group Size: ${criteria.groupSize} people

Create exactly 3 trip suggestions in this JSON format:

{
  "suggestions": [
    {
      "type": "Quick Explorer",
      "description": "Perfect for half-day trips with minimal travel",
      "recommendedPlaces": ["Place Name 1", "Place Name 2", "Place Name 3"],
      "estimatedTime": "3-4 hours",
      "estimatedCost": 500,
      "difficulty": "Easy",
      "highlights": ["Top-rated attractions", "Minimal travel time"],
      "suitableFor": ["families", "first-time visitors"]
    },
    {
      "type": "Cultural Heritage",
      "description": "Focus on historical, religious and cultural sites",
      "recommendedPlaces": ["Temple 1", "Heritage Site 2", "Museum 3"],
      "estimatedTime": "5-6 hours", 
      "estimatedCost": 800,
      "difficulty": "Moderate",
      "highlights": ["Rich history", "Cultural immersion"],
      "suitableFor": ["culture enthusiasts", "history buffs"]
    },
    {
      "type": "Comprehensive Adventure",
      "description": "Full day with diverse experiences and maximum places",
      "recommendedPlaces": ["Place 1", "Place 2", "Place 3", "Place 4", "Place 5"],
      "estimatedTime": "7-8 hours",
      "estimatedCost": 1200,
      "difficulty": "Challenging", 
      "highlights": ["Maximum variety", "Complete experience"],
      "suitableFor": ["adventure seekers", "detailed explorers"]
    }
  ]
}

Select places that best match the interests: ${criteria.interests?.join(', ')}, considering time and budget constraints.`;

    const result = await model.generateContent(suggestionsPrompt);
    const response = await result.response;
    const aiResponse = response.text();

    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const aiSuggestions = JSON.parse(jsonMatch[0]);
      console.log('‚úÖ AI suggestions generated successfully');
      return aiSuggestions;
    } else {
      throw new Error('No valid JSON in AI response');
    }

  } catch (error) {
    console.error('AI suggestions failed:', error);
    return generateFallbackSuggestions(places, criteria);
  }
}

// Generate fallback suggestions when AI fails
function generateFallbackSuggestions(places, criteria) {
  console.log('üîß Generating fallback trip suggestions...');

  // Sort places by rating and relevance
  const sortedPlaces = places
    .filter(p => p.rating >= 3.0) // Only include well-rated places
    .sort((a, b) => (b.rating || 0) - (a.rating || 0));

  // Filter by interests if provided
  let filteredPlaces = sortedPlaces;
  if (criteria.interests && criteria.interests.length > 0) {
    filteredPlaces = sortedPlaces.filter(place => 
      criteria.interests.some(interest => 
        place.category?.toLowerCase().includes(interest.toLowerCase())
      )
    );

    // If no matches, use all places
    if (filteredPlaces.length === 0) {
      filteredPlaces = sortedPlaces;
    }
  }

  // Filter by budget if provided
  if (criteria.budget) {
    filteredPlaces = filteredPlaces.filter(place => 
      (place.entryFee?.indian || 0) <= criteria.budget / 3 // Assume 3+ places
    );
  }

  const suggestions = [
    {
      type: "Quick Explorer",
      description: "Perfect for half-day trips with top-rated places and minimal travel time",
      recommendedPlaces: filteredPlaces.slice(0, 3).map(p => p.name),
      estimatedTime: "3-4 hours",
      estimatedCost: filteredPlaces.slice(0, 3).reduce((sum, p) => sum + (p.entryFee?.indian || 0), 300),
      difficulty: "Easy",
      highlights: ["Top-rated attractions", "Minimal travel time", "Perfect for beginners"],
      suitableFor: ["families", "first-time visitors", "time-constrained travelers"]
    },
    {
      type: "Cultural Heritage",
      description: "Focus on temples, heritage sites and cultural attractions for deep immersion",
      recommendedPlaces: filteredPlaces
        .filter(p => ['temple', 'heritage', 'museum', 'cultural', 'palace'].includes(p.category?.toLowerCase()))
        .slice(0, 4)
        .map(p => p.name),
      estimatedTime: "5-6 hours",
      estimatedCost: 800,
      difficulty: "Moderate", 
      highlights: ["Rich cultural experience", "Historical significance", "Spiritual journey"],
      suitableFor: ["culture enthusiasts", "history buffs", "spiritual seekers"]
    },
    {
      type: "Comprehensive Adventure",
      description: "Full day experience with maximum variety and diverse attractions",
      recommendedPlaces: filteredPlaces.slice(0, 6).map(p => p.name),
      estimatedTime: "7-8 hours",
      estimatedCost: 1200,
      difficulty: "Challenging",
      highlights: ["Maximum variety", "Complete regional experience", "Diverse categories"],
      suitableFor: ["adventure seekers", "detailed explorers", "photography enthusiasts"]
    }
  ];

  // Filter out suggestions with no places
  return {
    suggestions: suggestions.filter(s => s.recommendedPlaces.length > 0)
  };
}

// Analyze existing trip and provide AI improvements
const analyzeExistingTrip = async (req, res) => {
  try {
    const { places, currentOrder } = req.body;

    if (!places || !Array.isArray(places) || places.length < 2) {
      return res.status(400).json({
        success: false,
        message: 'At least 2 places required for analysis'
      });
    }

    console.log('üîç Analyzing existing trip with AI...');

    // Enrich places from database
    const enrichedPlaces = await enrichPlacesFromDatabase(places);

    if (enrichedPlaces.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No valid places found for analysis'
      });
    }

    // Get AI analysis
    const analysis = await getGeminiTripAnalysis(enrichedPlaces, {}, {});

    // Calculate current trip metrics (original order)
    let currentMetrics;
    try {
      currentMetrics = await optimizationAlgorithms.calculateRouteMetrics?.(enrichedPlaces) || {
        totalTime: enrichedPlaces.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
        totalDistance: 0,
        efficiency: 0
      };
    } catch (metricsError) {
      console.warn('Failed to calculate current metrics:', metricsError);
      currentMetrics = {
        totalTime: enrichedPlaces.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
        totalDistance: 0,
        efficiency: 0
      };
    }

    // Get optimized alternative
    const optimized = await applyOptimizationAlgorithm(
      enrichedPlaces,
      analysis.algorithmRecommendation,
      {},
      {}
    );

    let optimizedMetrics;
    try {
      optimizedMetrics = await optimizationAlgorithms.calculateRouteMetrics?.(optimized.route) || {
        totalTime: optimized.totalTime || 0,
        totalDistance: optimized.totalDistance || 0,
        efficiency: optimized.efficiency || 0
      };
    } catch (metricsError) {
      console.warn('Failed to calculate optimized metrics:', metricsError);
      optimizedMetrics = {
        totalTime: optimized.totalTime || 0,
        totalDistance: optimized.totalDistance || 0,
        efficiency: optimized.efficiency || 0
      };
    }

    // Calculate improvements
    const timeSaved = Math.max(0, currentMetrics.totalTime - optimizedMetrics.totalTime);
    const distanceSaved = Math.max(0, currentMetrics.totalDistance - optimizedMetrics.totalDistance);
    const efficiencyGain = optimizedMetrics.efficiency - currentMetrics.efficiency;

    res.status(200).json({
      success: true,
      analysis: {
        currentTrip: {
          route: enrichedPlaces,
          metrics: currentMetrics,
          order: 'original'
        },
        optimizedTrip: {
          route: optimized.route,
          metrics: optimizedMetrics,
          algorithm: optimized.algorithm
        },
        aiAnalysis: analysis,
        improvements: {
          timeSaved: Math.round(timeSaved),
          timeSavedFormatted: ${Math.floor(timeSaved / 60)}h ${Math.round(timeSaved % 60)}m,
          distanceSaved: Math.round(distanceSaved * 100) / 100,
          efficiencyGain: Math.round(efficiencyGain * 100) / 100,
          placesReordered: optimized.route?.length || 0,
          worthOptimizing: timeSaved > 30 || distanceSaved > 5 || efficiencyGain > 0.1
        },
        recommendations: analysis.recommendations || [
          'Consider the optimized route for better time management',
          'Check opening hours for all places',
          'Plan for traffic delays during peak hours'
        ]
      }
    });

  } catch (error) {
    console.error('Error analyzing trip:', error);
    res.status(500).json({
      success: false,
      message: 'Error analyzing trip',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};

// Add timing middleware
function addRequestTiming(req, res, next) {
  req.startTime = Date.now();
  next();
}

module.exports = {
  optimizeTripWithAI,
  getTripSuggestions,
  analyzeExistingTrip,
  addRequestTiming
};