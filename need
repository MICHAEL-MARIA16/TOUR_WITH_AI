i have 20 tourist places in my mongodb , 
it has opening time, closing time, average 
time needed to explore that specific place, 
best time to visit, ratings etc.. 
now take 10 district 1.coimbatore tidal park,2.thirunelveli,3.tanjore,4.allepey(kerela),5.chennai,6.salem,7.erode,8.kanniyakumari,9.banglore(karnataka),10.mysore->keep an option in the place selection page to choose the user location among these 10 places and what place the user is selecting ,the trip should start from that specific place and based on the user starting of the trip and the number of hours the user decided to spend in tour ,the tour plan should be given and need a live date and time update in the website like It should behave like a google map but with an extra feature of ai to chat and a detailed trip plan from start to end all the minute things should be suggested in a clear way so that the user follows only the things provided by our trip planner .so for a trip from leaving the home to completing the trip all should be organised by the ai and the algorithm in a detailed manner .note:work base on live date and time of the user



now take 10 district 1.coimbatore tidal park,2.thirunelveli,3.tanjore,4.allepey(kerela),5.chennai,6.salem,7.erode,8.kanniyakumari,9.banglore(karnataka),10.mysore->keep an option in the place selection page to choose the user location among these 10 places and what place the user is selecting ,the trip should start from that specific place and based on the user starting of the trip and the number of hours the user decided to spend in tour ,the tour plan should be given and need a live date and time update in the website like It should behave like a google map but with an extra feature of ai to chat and a detailed trip plan from start to end all the minute things should be suggested in a clear way so that the user follows only the things provided by our trip planner .so for a trip from leaving the home to completing the trip all should be organised by the ai and the algorithm in a detailed manner
---

User Location Selection Options
Your location configuration supports 10 starting locations across South India:

Tamil Nadu: Coimbatore, Chennai, Salem, Erode, Tirunelveli, Thanjavur, Kanyakumari
Kerala: Alleppey
Karnataka: Bangalore, Mysore

Each location includes precise coordinates, district info, and descriptions for contextual planning.
Place Data Structure
Your seeded places contain comprehensive data for optimization:

Temporal Data: openingHours, averageVisitDuration, bestTimeToVisit
Quality Metrics: rating, reviewCount, category
Accessibility: kidFriendly, wheelchairAccessible
Cost: entryFee (indian/foreign)
Location: Precise coordinates for distance calculations

----
// backend/routes/trips.js - Updated with Algorithm Explanation Endpoint

const express = require('express');
const router = express.Router();
const { 
  optimizeTripWithAI, 
  getTripSuggestions, 
  analyzeExistingTrip,
  generateAlgorithmExplanation, // NEW IMPORT
  addRequestTiming 
} = require('../controllers/tripController');

// Middleware for request timing
router.use(addRequestTiming);

// Existing routes
router.post('/optimize', optimizeTripWithAI);
router.get('/suggestions', getTripSuggestions);
router.post('/analyze', analyzeExistingTrip);

// NEW ROUTE: Generate AI Algorithm Explanation
router.post('/generate-algorithm-explanation', async (req, res) => {
  try {
    console.log('ðŸŽ¯ Algorithm explanation request received');
    console.log('ðŸ“Š Route length:', req.body.route?.length || 0);
    console.log('ðŸ§  Algorithm:', req.body.algorithm || 'unknown');
    console.log('ðŸ“ˆ Detail level:', req.body.explanationLevel || 'detailed');

    await generateAlgorithmExplanation(req, res);
  } catch (error) {
    console.error('Algorithm explanation route error:', error);
    res.status(500).json({
      success: false,
      message: 'Algorithm explanation failed',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

// Enhanced route for detailed trip plan generation (existing, but improved logging)
router.post('/generate-detailed-plan', async (req, res) => {
  try {
    console.log('ðŸ“‹ Detailed plan generation request received');
    console.log('ðŸ“Š Places:', req.body.places?.length || 0);
    console.log('ðŸ§  Algorithm:', req.body.algorithm || 'unknown');
    
    // This endpoint would call your existing detailed plan generation logic
    // For now, returning a structured response that matches the frontend expectations
    
    const { places, preferences, routeMetrics, algorithm, constraints } = req.body;
    
    if (!places || places.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Places array is required for detailed plan generation'
      });
    }

    // Generate comprehensive detailed plan
    const detailedPlan = {
      summary: {
        title: `${places.length}-Place South India Journey`,
        duration: `${Math.ceil((preferences?.totalTimeAvailable || 480) / 60)} hours`,
        totalDistance: routeMetrics?.totalDistance || 0,
        estimatedCost: places.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0),
        difficulty: getDifficultyLevel(places),
        startingLocation: constraints?.startLocation?.name || preferences?.userLocationId || 'Coimbatore'
      },
      
      timeline: generateEnhancedTimeline(places, preferences, constraints),
      
      insights: {
        diversity: [...new Set(places.map(p => p.category))].length / places.length,
        cityCount: [...new Set(places.map(p => p.city))].length,
        averageRating: (places.reduce((sum, p) => sum + (p.rating || 0), 0) / places.length).toFixed(1),
        totalDuration: places.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0),
        highlights: places.filter(p => (p.rating || 0) >= 4.5),
        categories: [...new Set(places.map(p => p.category))],
        experienceLevel: getExperienceLevel(places)
      },
      
      recommendations: generateEnhancedRecommendations(places, preferences),
      
      logistics: generateLogisticsInfo(places, preferences),
      
      cultural: generateCulturalTips(places),
      
      practicalInfo: {
        totalDuration: `${Math.ceil((preferences?.totalTimeAvailable || 480) / 60)} hours`,
        transportationTips: 'Private car or taxi recommended for flexible scheduling',
        budgetBreakdown: generateBudgetBreakdown(places, routeMetrics),
        packingList: generatePackingList(places),
        weatherConsiderations: generateWeatherTips(places),
        emergencyInfo: 'Keep emergency contacts handy: 108 for ambulance, 100 for police'
      }
    };

    res.status(200).json({
      success: true,
      data: detailedPlan,
      metadata: {
        algorithm: algorithm || 'advanced-optimization',
        generatedAt: new Date().toISOString(),
        placesProcessed: places.length,
        aiEnhanced: true
      }
    });

  } catch (error) {
    console.error('Detailed plan generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate detailed plan',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

// Real-time tracking endpoints (existing functionality)
router.post('/start-realtime-tracking', async (req, res) => {
  try {
    const { tripId, userId, startLocation } = req.body;
    
    // Store tracking session (implement with your database)
    const trackingSession = {
      tripId,
      userId, 
      startLocation,
      startTime: new Date(),
      status: 'active'
    };

    res.status(200).json({
      success: true,
      data: {
        trackingId: `track_${Date.now()}`,
        session: trackingSession,
        message: 'Real-time tracking started successfully'
      }
    });
  } catch (error) {
    console.error('Start tracking error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to start tracking',
      error: error.message
    });
  }
});

router.put('/update-progress', async (req, res) => {
  try {
    const { tripId, currentLocation, checkpointId, action } = req.body;
    
    // Update progress logic here
    const progressUpdate = {
      tripId,
      currentLocation,
      checkpointId,
      action,
      timestamp: new Date()
    };

    res.status(200).json({
      success: true,
      data: progressUpdate,
      message: 'Progress updated successfully'
    });
  } catch (error) {
    console.error('Update progress error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update progress',
      error: error.message
    });
  }
});

router.get('/real-time-updates', async (req, res) => {
  try {
    const { tripId, currentLocation, lastUpdateTime } = req.query;
    
    // Generate mock real-time updates
    const updates = [
      {
        type: 'traffic',
        message: 'Light traffic ahead - no delays expected',
        timestamp: new Date(),
        severity: 'info'
      },
      {
        type: 'weather',
        message: 'Clear skies - perfect for sightseeing!',
        timestamp: new Date(),
        severity: 'info'
      }
    ];

    res.status(200).json({
      success: true,
      data: {
        updates,
        nextUpdateIn: 40000 // 40 seconds
      }
    });
  } catch (error) {
    console.error('Real-time updates error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get updates',
      error: error.message
    });
  }
});

// Helper functions for detailed plan generation
function getDifficultyLevel(places) {
  const avgDuration = places.reduce((sum, p) => sum + (p.averageVisitDuration || 90), 0) / places.length;
  const hasComplexPlaces = places.some(p => ['heritage', 'fort', 'nature'].includes(p.category));
  
  if (avgDuration > 150 || hasComplexPlaces) return 'Challenging';
  if (avgDuration > 90) return 'Moderate';
  return 'Easy';
}

function getExperienceLevel(places) {
  const avgRating = places.reduce((sum, p) => sum + (p.rating || 0), 0) / places.length;
  if (avgRating >= 4.0) return 'Premium';
  if (avgRating >= 3.5) return 'Good';
  return 'Standard';
}

function generateEnhancedTimeline(places, preferences, constraints) {
  const startTime = preferences?.startTime || '09:00';
  let currentTime = timeToMinutes(startTime);
  
  return places.map((place, index) => {
    const arrivalTime = currentTime;
    const visitDuration = place.averageVisitDuration || 90;
    const departureTime = arrivalTime + visitDuration;
    
    const timelineItem = {
      time: minutesToTime(arrivalTime),
      endTime: minutesToTime(departureTime),
      place,
      duration: visitDuration,
      activities: getPlaceActivities(place),
      tips: getPlaceTips(place),
      mealSuggestion: getMealSuggestion(arrivalTime),
      travel: index < places.length - 1 ? {
        duration: 45,
        mode: 'car',
        distance: 25
      } : null
    };
    
    currentTime = departureTime + (index < places.length - 1 ? 45 : 0);
    return timelineItem;
  });
}

function generateEnhancedRecommendations(places, preferences) {
  return {
    photography: places.filter(p => ['palace', 'heritage', 'fort'].includes(p.category)).slice(0, 3),
    cultural: places.filter(p => p.category === 'temple').slice(0, 2),
    nature: places.filter(p => ['hill-station', 'beach', 'nature'].includes(p.category)).slice(0, 2),
    timing: [
      'Start early to avoid crowds and heat',
      'Carry sufficient water and energy snacks',
      'Wear comfortable walking shoes',
      'Respect local customs and dress codes',
      'Keep important documents safe and accessible'
    ],
    budgetTips: [
      'Many temples have free entry - take advantage of these cultural experiences',
      'Pack lunch to save money, especially for longer visits',
      'Negotiate taxi fares in advance for better rates',
      'Carry small denominations for entry fees and donations'
    ]
  };
}

function generateLogisticsInfo(places, preferences) {
  const hasTemples = places.some(p => p.category === 'temple');
  const hasOutdoorSites = places.some(p => ['fort', 'heritage', 'nature'].includes(p.category));
  
  return {
    transportation: 'Private car/taxi recommended for flexibility and comfort',
    parking: 'Most attractions have parking facilities - expect â‚¹10-50 parking fees',
    restrooms: 'Available at major attractions and restaurants along the route',
    food: 'Local restaurants available near most destinations - South Indian cuisine recommended',
    shopping: hasTemples ? 'Temple souvenir shops available for religious items and local crafts' : 'Local markets near heritage sites',
    accessibility: hasTemples ? 'Temple visits require removing footwear - carry socks' : 'Most sites have reasonable accessibility',
    emergency: '108 for medical emergencies, 100 for police, tourist helpline numbers available',
    connectivity: 'Good mobile network coverage in most areas - download offline maps as backup'
  };
}

function generateCulturalTips(places) {
  const tips = ['Learn basic Tamil/local language greetings', 'Try authentic South Indian cuisine at each stop'];
  
  if (places.some(p => p.category === 'temple')) {
    tips.push('Remove footwear before entering temples');
    tips.push('Dress modestly - cover shoulders and legs at religious sites');
    tips.push('Maintain silence and respect during prayer times');
    tips.push('Photography may be restricted in some temple areas');
  }
  
  if (places.some(p => p.category === 'heritage')) {
    tips.push('Hire local guides for historical context and stories');
    tips.push('Respect photography restrictions at heritage monuments');
  }
  
  if (places.some(p => p.category === 'palace')) {
    tips.push('Audio guides often available at palaces - worth the investment');
  }
  
  tips.push('Bargain respectfully at local markets');
  tips.push('Be patient with local customs and traditions');
  
  return tips;
}

function generateBudgetBreakdown(places, routeMetrics) {
  const entryFees = places.reduce((sum, p) => sum + (p.entryFee?.indian || 0), 0);
  const transportCost = Math.round((routeMetrics?.totalDistance || 100) * 8); // â‚¹8 per km estimate
  const foodCost = places.length * 200; // â‚¹200 per place for meals/snacks
  
  return {
    entryFees: `â‚¹${entryFees}`,
    transportation: `â‚¹${transportCost} (estimated â‚¹8/km)`,
    food: `â‚¹${foodCost} (â‚¹200 per location average)`,
    miscellaneous: `â‚¹${Math.round(places.length * 100)} (parking, tips, souvenirs)`,
    total: `â‚¹${entryFees + transportCost + foodCost + (places.length * 100)}`
  };
}

function generatePackingList(places) {
  const packingItems = ['Water bottle (essential)', 'Comfortable walking shoes', 'Camera or smartphone', 'Power bank', 'Small backpack or day bag'];
  
  if (places.some(p => p.category === 'temple')) {
    packingItems.push('Socks (for temple visits)');
    packingItems.push('Modest clothing (covering shoulders and legs)');
  }
  
  if (places.some(p => ['beach', 'nature', 'fort'].includes(p.category))) {
    packingItems.push('Sunscreen and hat');
    packingItems.push('Light rain jacket (seasonal)');
  }
  
  packingItems.push('Cash in small denominations');
  packingItems.push('Government ID proof');
  packingItems.push('Emergency contact numbers');
  
  return packingItems;
}

function generateWeatherTips(places) {
  const hasOutdoor = places.some(p => !['museum'].includes(p.category));
  
  if (hasOutdoor) {
    return 'Check weather forecast before departure. Carry light rain protection during monsoon season (June-October). Summer visits (March-May) require sun protection and extra hydration.';
  }
  
  return 'Mostly indoor attractions - weather impact minimal. Still carry basics like water and light jacket.';
}

function getPlaceActivities(place) {
  const activities = {
    'temple': ['Darshan and prayers', 'Architecture photography', 'Cultural immersion', 'Peaceful meditation'],
    'palace': ['Royal architecture tour', 'Museum exploration', 'Garden walk', 'Photography'],
    'heritage': ['Historical tour', 'Archaeological exploration', 'Photography', 'Cultural learning'],
    'fort': ['Historical exploration', 'Panoramic city views', 'Photography', 'Architecture study'],
    'beach': ['Beach walks', 'Water activities', 'Sunset viewing', 'Photography'],
    'hill-station': ['Nature walks', 'Scenic photography', 'Cool climate enjoyment', 'Fresh air'],
    'nature': ['Nature photography', 'Wildlife observation', 'Fresh air', 'Peaceful environment'],
    'museum': ['Educational exhibits', 'Art appreciation', 'Cultural learning', 'Photography (if allowed)']
  };
  
  return activities[place.category] || ['Sightseeing', 'Photography', 'Cultural experience'];
}

function getPlaceTips(place) {
  const tips = {
    'temple': ['Dress modestly', 'Remove footwear', 'Maintain silence', 'Respect photography rules'],
    'palace': ['Book guided tours if available', 'Check photography rules', 'Allow 2-3 hours', 'Visit gardens if present'],
    'heritage': ['Hire local guide for context', 'Carry water', 'Wear sun protection', 'Start early to avoid crowds'],
    'fort': ['Wear comfortable shoes', 'Carry water', 'Best visited morning/evening', 'Bring camera for views'],
    'beach': ['Apply sunscreen', 'Stay hydrated', 'Check tide timings', 'Avoid midday sun'],
    'hill-station': ['Carry light jacket', 'Check weather conditions', 'Book early if staying overnight', 'Enjoy cool climate'],
    'nature': ['Respect natural environment', 'Don\'t disturb wildlife', 'Carry insect repellent', 'Stay on marked paths'],
    'museum': ['Check opening hours', 'Allow sufficient time', 'Audio guides recommended', 'No flash photography usually']
  };
  
  return tips[place.category] || ['Plan sufficient time', 'Carry essentials', 'Follow local guidelines'];
}

function getMealSuggestion(arrivalTime) {
  if (arrivalTime >= 720 && arrivalTime <= 840) { // 12:00-14:00
    return 'Perfect timing for lunch break at nearby restaurants';
  } else if (arrivalTime >= 1020 && arrivalTime <= 1080) { // 17:00-18:00
    return 'Good time for evening snacks or early dinner';
  } else if (arrivalTime < 600) { // Before 10:00
    return 'Early visit - have breakfast before or pack energy snacks';
  }
  return null;
}

// Helper functions
function timeToMinutes(timeStr) {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
}

function minutesToTime(minutes) {
  const hours = Math.floor(minutes / 60) % 24;
  const mins = Math.round(minutes % 60);
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
}

module.exports = router;